{
  "type": "interface",
  "id": "aaa17170-98e0-4a3c-8fe3-de7fa758af69",
  "document": {
    "operations": [
      {
        "specification": "Retrieve a paginated, filtered, and sorted list of BBS articles. Associated with the 'bbs_articles' table in the Prisma schema. This includes support for searching by title, writer, creation date, and additional paging/sorting parameters for UI and data efficiency. Returns summarized information for each article, such as the title of the latest snapshot, author, comment count, and timestamps.",
        "description": "This API retrieves a paginated and filtered list of articles from the 'bbs_articles' table. The endpoint should support standard search fields, such as title, writer, or date range, reflecting the need for efficient querying and performance optimization as outlined in the requirements.\n\nThe response includes only the latest snapshot information (title, etc.) and not the complete snapshot history for each article, consistent with index usage and list performance needs. Security considerations include returning only non-deleted articles to general users; deleted articles may be included for admins based on role.\n\nRelated operations: GET /bbs/articles/{id} for detail view, PATCH /bbs/articles/{articleId}/snapshots for snapshots list, and CRUD operations for creation, update, and deletion. Consider error handling for invalid queries and paging boundaries.",
        "summary": "Retrieve a list of BBS articles ('bbs_articles' table) with filtering, search, and pagination.",
        "parameters": [],
        "requestBody": {
          "description": "Search criteria, filtering, sorting, and pagination for retrieving article list.",
          "typeName": "IBbsArticle.IRequest"
        },
        "responseBody": {
          "description": "Paginated list of summarized article information, showing title (latest snapshot), author, comment count, and timestamps.",
          "typeName": "IPageIBbsArticle.ISummary"
        },
        "path": "/bbs/articles",
        "method": "patch"
      },
      {
        "specification": "Create a new BBS article. Associated with the 'bbs_articles' table in Prisma. The request should include writer, password, initial title/body (for the first snapshot), initial file attachments, and format information. On creation, an initial snapshot (in 'bbs_article_snapshots') is formed, and attachment_files relationships are established.",
        "description": "This API creates a new article in the 'bbs_articles' table with all required fields, such as writer name, password (secure/encrypted), and creation time. The body and title are stored in the initial record in 'bbs_article_snapshots', while attached files are related via 'bbs_article_snapshot_files'.\n\nUpon success, a new article is created with its first snapshot and attachments, and all references are established. Security: password will be encrypted in storage. Ensure all fields follow validations in the DB schema, such as non-empty strings for essential fields, proper format for UUIDs, and file URL validation. The operation is atomic—all-or-nothing if file/attachment data is invalid.\n\nRelated: PATCH /bbs/articles for article listing and GET /bbs/articles/{id} for detail view.",
        "summary": "Create a new BBS article with initial snapshot and attachments (related to 'bbs_articles' table).",
        "parameters": [],
        "requestBody": {
          "description": "New article's information, including writer, password, body/title, format, and attachments.",
          "typeName": "IBbsArticle.ICreate"
        },
        "responseBody": {
          "description": "The created article with its first snapshot and uploaded attachments.",
          "typeName": "IBbsArticle"
        },
        "path": "/bbs/articles",
        "method": "post"
      },
      {
        "specification": "Retrieve detailed information about a specific BBS article, using its unique identifier. Associated with the 'bbs_articles' table. Returns all fields plus the latest snapshot, summary of comments count, and list of attachments (latest snapshot only).",
        "description": "This API provides detail for a single article from the 'bbs_articles' table, identified by its UUID. Main output fields are writer, creation/deletion time, the latest snapshot's title/body/format, and summary of attachments and comments.\n\nValidation includes ensuring the article exists and is not deleted (for general users), with soft-deleted articles only visible for admins/staff. Response incorporates summarized comment count, facilitating user interface efficiency. Error handling covers 'not found' and forbidden access on deleted items.\n\nRelated: PATCH /bbs/articles for lists, PATCH /bbs/articles/{articleId}/snapshots for modification history.",
        "summary": "Get detail information of a specific BBS article ('bbs_articles' table), including latest snapshot and attachments.",
        "parameters": [
          {
            "name": "id",
            "description": "UUID of the BBS article to retrieve.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Detailed article with latest snapshot, summary of attachments, and comment count.",
          "typeName": "IBbsArticle"
        },
        "path": "/bbs/articles/{id}",
        "method": "get"
      },
      {
        "specification": "Update details of a specific BBS article. For article modification: verifies password, creates a new snapshot, manages attachments, and saves updated content. Associated table is 'bbs_articles', but with new record in 'bbs_article_snapshots', and links to attachments in 'bbs_article_snapshot_files'.",
        "description": "This API modifies an existing BBS article. Upon update, password is verified then a new snapshot is inserted in 'bbs_article_snapshots', containing the revised title/body/format and new/updated attachments listed via 'bbs_article_snapshot_files'.\n\nThe original article's record in 'bbs_articles' is not overwritten; only new snapshot/attachments are created to preserve evidence, as per requirements. Security: password verification is strict, and all updates are timestamped. All DB constraints and validation are applied (e.g., title, body not empty).\n\nError cases include unauthorized access, not found, or validation failures. The operation is atomic—either the snapshot and all attachments are created, or none are.",
        "summary": "Update a specific BBS article ('bbs_articles' table); creates a new snapshot with attachments.",
        "parameters": [
          {
            "name": "id",
            "description": "UUID of the article to update.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Updated article content, verified via password, with attachments list.",
          "typeName": "IBbsArticle.IUpdate"
        },
        "responseBody": {
          "description": "Updated article model including the new snapshot and latest attachment state.",
          "typeName": "IBbsArticle"
        },
        "path": "/bbs/articles/{id}",
        "method": "put"
      },
      {
        "specification": "Soft delete a specific article. Associated with the 'bbs_articles' table, this operation marks an article as deleted by setting 'deleted_at', but never removes it physically. Password verification is required. Snapshots and attachments remain untouched for evidential purposes.",
        "description": "This API marks an article as logically deleted (soft delete) by setting the 'deleted_at' timestamp, per requirements. The request must provide password verification.\n\nThe operation does not alter existing snapshot or attachment file records, preserving all evidence. Soft-deleted articles are hidden from non-admin users. Security: password must match and be securely provided; deleted articles remain retrievable by admins for audits if needed.\n\nError scenarios: unauthorized/deletion of already deleted, or article not found. Proper error is returned (e.g., forbidden, not found).",
        "summary": "Soft-delete a specific article ('bbs_articles' table); sets 'deleted_at', preserves evidence.",
        "parameters": [
          {
            "name": "id",
            "description": "UUID of the article to delete.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Password for verification prior to soft-deletion.",
          "typeName": "IBbsArticle.IDelete"
        },
        "responseBody": {
          "description": "Updated article record with 'deleted_at' set; all historical data preserved.",
          "typeName": "IBbsArticle"
        },
        "path": "/bbs/articles/{id}",
        "method": "delete"
      },
      {
        "specification": "Retrieve the full snapshot (revision) history for a given article. Snapshots show all historical versions, including title, body, format, and metadata. Associated table is 'bbs_article_snapshots', filtered by articleId. Pagination/sorting may be supported for auditability.",
        "description": "This API lists all snapshots (modification revisions) for a specific article from the 'bbs_article_snapshots' table using the article's ID. Each snapshot includes title, body format, creation timestamp, ip address, and list of attachment files for that version.\n\nSupports pagination, important for heavily-edited articles (for performance). Access is generally open, but some security logic may be applied to deleted or restricted articles.\n\nRelated operations: PATCH /bbs/articles for lists, GET /bbs/articles/{id} for details, GET /bbs/articles/{articleId}/snapshots/{id} for individual revision.",
        "summary": "Get all revision snapshots for a given article ('bbs_article_snapshots' table, by articleId), with pagination.",
        "parameters": [
          {
            "name": "articleId",
            "description": "UUID of the article whose snapshots are being listed.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Optional pagination and filter parameters for snapshot history.",
          "typeName": "IBbsArticleSnapshot.IRequest"
        },
        "responseBody": {
          "description": "Paginated list of article snapshot histories, with metadata and attachment summaries for each.",
          "typeName": "IPageIBbsArticleSnapshot"
        },
        "path": "/bbs/articles/{articleId}/snapshots",
        "method": "patch"
      },
      {
        "specification": "Retrieve a specific snapshot (revision) of an article using both the article and snapshot UUIDs. Associated with 'bbs_article_snapshots'. Returns all details, including the exact title/body at that revision and its attachment list.",
        "description": "This API fetches a single snapshot (revision) of a given article using both IDs. The response includes the title, body, format, ip address, and the list of related attachments stored at the time of this revision. Used for auditing, difference viewing, or legal evidence of changes.\n\nSecurity checks ensure access to the underlying article. If the snapshot does not exist or is not linked to the specified article, a 'not found' is returned. No soft-delete applies to originals here; evidence is never removed.\n\nRelated: PATCH /bbs/articles/{articleId}/snapshots for revision history.",
        "summary": "Get detail of a specific snapshot for a given article ('bbs_article_snapshots' table, by articleId and snapshotId).",
        "parameters": [
          {
            "name": "articleId",
            "description": "UUID of the article to which the snapshot belongs.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "UUID of the snapshot to fetch.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Snapshot detail for given article and snapshotId, including attachments of that version.",
          "typeName": "IBbsArticleSnapshot"
        },
        "path": "/bbs/articles/{articleId}/snapshots/{id}",
        "method": "get"
      },
      {
        "specification": "Update a specific snapshot of an article. Associated with 'bbs_article_snapshots'. Used in administrative or rare correction scenarios. Generally not allowed for normal users, as snapshots are evidence, but sometimes required for system corrections. Both article and snapshotId required.",
        "description": "This API updates a snapshot 'bbs_article_snapshots' record. Normally, snapshot changes are forbidden for users (evidence preservation), but certain admin/system roles may execute corrections (e.g., unlawful content, typo fix). Updates may include modifications to title, body, format, or attachment relations; logs must track all changes for auditing.\n\nSecurity: restricted to admins or evidence maintainers. Standard validations apply, and revert possible for audit reasons. Related to PATCH /bbs/articles/{articleId}/snapshots.",
        "summary": "Update content or metadata of a specific article snapshot ('bbs_article_snapshots' table, by articleId and snapshotId); admin/system only.",
        "parameters": [
          {
            "name": "articleId",
            "description": "UUID of the article containing the snapshot.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "UUID of the snapshot to update.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Snapshot fields to update (title/body/attachments/format). Usually only by admin/system.",
          "typeName": "IBbsArticleSnapshot.IUpdate"
        },
        "responseBody": {
          "description": "Updated snapshot details after admin/system correction.",
          "typeName": "IBbsArticleSnapshot"
        },
        "path": "/bbs/articles/{articleId}/snapshots/{id}",
        "method": "put"
      },
      {
        "specification": "Logically delete a specific snapshot. Associated with 'bbs_article_snapshots'. Generally only available for administrative purposes—soft delete, not physical. Used to remove sensitive/illegal content from evidence (rare/emergency). Requires both articleId and snapshotId.",
        "description": "This API marks a specific article snapshot as deleted (logically), removing it from default user access. The actual snapshot record is not physically deleted, preserving historical evidence and references, but a status or timestamp is set as deleted.\n\nSecurity: strictly restricted to admin/system users. Normal users cannot delete snapshots (only create new ones for revisions). Soft-deleted snapshots may be included in audit/admin views with proper roles.\n\nRelated: PATCH /bbs/articles/{articleId}/snapshots for revisions, GET /bbs/articles/{articleId}/snapshots/{id} for detail.",
        "summary": "Logically delete a snapshot of an article ('bbs_article_snapshots'), admin/system only, for evidence management.",
        "parameters": [
          {
            "name": "articleId",
            "description": "UUID of the article containing the snapshot.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "UUID of the snapshot to delete.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Credentials or reason for deletion (admin/system use only).",
          "typeName": "IBbsArticleSnapshot.IDelete"
        },
        "responseBody": {
          "description": "Snapshot record marked as deleted (logically); record preserved for evidence.",
          "typeName": "IBbsArticleSnapshot"
        },
        "path": "/bbs/articles/{articleId}/snapshots/{id}",
        "method": "delete"
      },
      {
        "specification": "Retrieve list of all attached files for a given article snapshot. Associated with 'bbs_article_snapshot_files', filtered by articleId and snapshotId. Supports pagination and filtering for UI convenience.",
        "description": "This API fetches all files attached to a specific revision (snapshot) of an article. Filters on articleId and snapshotId provide the explicit context to retrieve sequence/order of files, file metadata (name, extension, URL, creation time, sequence). Pagination can be included for snapshots with many files.\n\nRelated operations: POST for attaching new files to a revision, DELETE for removing files, PATCH for reordering/updating attachment list.\n\nAttachment files must be publicly accessible (with proper security tokens if required).",
        "summary": "List all attachment files for a specific article snapshot (by articleId/snapshotId), using 'bbs_article_snapshot_files'.",
        "parameters": [
          {
            "name": "articleId",
            "description": "UUID of the article of the snapshot.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "UUID of the article snapshot whose files are being listed.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Options for filtering or paging attached files for this snapshot.",
          "typeName": "IBbsArticleSnapshotFile.IRequest"
        },
        "responseBody": {
          "description": "Paginated list of snapshot attachment file records with metadata.",
          "typeName": "IPageIBbsArticleSnapshotFile"
        },
        "path": "/bbs/articles/{articleId}/snapshots/{snapshotId}/files",
        "method": "patch"
      },
      {
        "specification": "Attach one or more files to a specific article snapshot (revision). Associated table: 'bbs_article_snapshot_files', 'attachment_files'. The operation links previously uploaded files by ID (or uploads new ones), sets their order (sequence), and updates metadata. Used for adding/rearranging files for a revision.",
        "description": "This API attaches files to a specific article snapshot. It accepts file IDs (already uploaded via separate process) or requires necessary file metadata if uploading new files. For existing files, establishes the link via 'bbs_article_snapshot_files'; for new uploads, creates a file record in 'attachment_files' then associates it.\n\nSequence/order is essential (for display order). Validation checks that files exist or are newly proper. Security: normal user edits require proper authentication; admin/system roles may bypass restrictions for evidence.</br>\n\nReturns updated list of attachments, with all associated metadata for the snapshot. Related: PATCH for updating the order, DELETE for deleting attachments.",
        "summary": "Attach one or more files to a specific snapshot of an article ('bbs_article_snapshot_files'), returning updated file list.",
        "parameters": [
          {
            "name": "articleId",
            "description": "UUID of the article of the snapshot being modified.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "UUID of the snapshot to attach files to.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Attachment file information to link/upload for this snapshot, plus order.",
          "typeName": "IBbsArticleSnapshotFile.ICreate"
        },
        "responseBody": {
          "description": "Updated attachment list for the specified snapshot, with file metadata.",
          "typeName": "IPageIBbsArticleSnapshotFile"
        },
        "path": "/bbs/articles/{articleId}/snapshots/{snapshotId}/files",
        "method": "post"
      },
      {
        "specification": "Retrieve a specific attachment file associated with a given article snapshot. This endpoint looks up the attachment file mapping for the specified snapshot of an article, identified by their UUIDs. It fetches data from the 'bbs_article_snapshot_files' table, and only returns file entries for the given combination. This API is crucial for displaying or downloading detailed file metadata such as filename, type, position (sequence), and its storage URL as attached to the article's modification history. Resolves access through 'bbs_articles' > 'bbs_article_snapshots' > 'bbs_article_snapshot_files'.",
        "description": "This GET operation retrieves a particular file attached to a specific snapshot of an article in the bulletin board system.\n\nThe endpoint path parameters (articleId, snapshotId, id) represent the article UUID, the snapshot UUID, and the file attachment relation UUID (bbs_article_snapshot_files.id) respectively. This strict mapping ensures the file's association is under the correct article version, upholding evidentiary record accuracy as described in the requirements.\n\nSecurity considerations include verifying the logical existence of the parent article and snapshot (not deleted), and checking the user's permission for file access.\n\nReturns metadata about the attachment (order, file metadata, and URL for download). Relies on the correct structure and associations as maintained within the attachment_files and bbs_article_snapshot_files Prisma models.\n\nHandles errors such as not-found (404) if any ancestor entity does not exist or is inaccessible, and forbidden (403) for unauthorized access attempts.",
        "summary": "Get a specific attached file (bbs_article_snapshot_files) in a snapshot of an article.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "Target snapshot ID (UUID) in bbs_article_snapshots",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Attachment relation ID in bbs_article_snapshot_files",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Attachment file metadata and relation info for a given snapshot of article.",
          "typeName": "IBbsArticleSnapshotFile"
        },
        "path": "/bbs/articles/{articleId}/snapshots/{snapshotId}/files/{id}",
        "method": "get"
      },
      {
        "specification": "Update the metadata and linking for a specific file attached to a given snapshot of an article, identified by the nested UUIDs. This allows updating only the metadata and sequence order in 'bbs_article_snapshot_files', not the file content itself. Based on the system's snapshot and evidentiary approach, the file's order/association can be changed for the current snapshot only. No cross-snapshot side-effects. Data stored in 'bbs_article_snapshot_files' and linked with 'attachment_files'.",
        "description": "This PUT operation updates the mapping information for a specific file attached to an article snapshot. A typical use case includes resequencing file orders or changing ancillary metadata about this attachment (the file itself is immutable for evidence, but linkage/metadata can change for the active revision).\n\nRequires verification of the parent article (not deleted), parent snapshot, and correct ownership/permissions, as defined by the evidentiary and logical deletion model.\n\nThe request body structure corresponds to updates for the 'bbs_article_snapshot_files' record, such as sequence reordering.\n\nUpdate is restricted to the targeted relation and does not affect historical data in previous snapshots.\n\nHandles error states including not-found for any path element, permission denial, and validation for business rules (e.g., not modifying a locked/evidence snapshot).",
        "summary": "Update attachment file entry (bbs_article_snapshot_files) metadata for a given article snapshot.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "Target snapshot ID (UUID) in bbs_article_snapshots",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Attachment relation ID in bbs_article_snapshot_files",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Info to update the attached file relation (e.g., sequence order) in a snapshot.",
          "typeName": "IBbsArticleSnapshotFile.IUpdate"
        },
        "responseBody": {
          "description": "Updated attachment file relation data for the snapshot.",
          "typeName": "IBbsArticleSnapshotFile"
        },
        "path": "/bbs/articles/{articleId}/snapshots/{snapshotId}/files/{id}",
        "method": "put"
      },
      {
        "specification": "Remove the linkage of a specific attachment file from a given article snapshot, performing logical deletion. The file-record association in 'bbs_article_snapshot_files' is marked as deleted, not physically removed, keeping with the evidence and audit log requirements. Applies only to the given snapshot; other snapshots are untouched. Underlying file record in 'attachment_files' may remain, subject to business logic.",
        "description": "This DELETE operation logically removes (unlinks) an attachment file from a specific article snapshot in the system. The operation targets the entry in 'bbs_article_snapshot_files', marking it as logically deleted if required by implementation, while preserving evidence as per requirements.\n\nDeleted file entries should no longer display for the target snapshot, but all historical records and actual file data are preserved for audit and evidence. Parent entity existence (article, snapshot) and permissions are always validated.\n\nThis operation may trigger side-effects such as reordering remaining files or revising display metadata for the snapshot, but never deletes actual file content.\n\nErrors handled include not-found for non-existing entities or relations, permission denial, and violation of audit-evidence policies.",
        "summary": "Delete (logically unlink) a file from a snapshot (bbs_article_snapshot_files) of an article.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "Target snapshot ID (UUID) in bbs_article_snapshots",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Attachment relation ID in bbs_article_snapshot_files",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Result of detach/logical deletion of the attachment file from the snapshot.",
          "typeName": "IBbsArticleSnapshotFile"
        },
        "path": "/bbs/articles/{articleId}/snapshots/{snapshotId}/files/{id}",
        "method": "delete"
      },
      {
        "specification": "List all comments (bbs_article_comments) for a specific article, with support for complex search/pagination/filtering. Results reflect logical deletion; only non-deleted comments are returned to typical users. Allows searching by writer, content, creation date, and hierarchical relationships (parent/child). Powered by 'bbs_article_comments' table with possible joins to 'bbs_articles' and snapshot info.",
        "description": "This PATCH operation fetches a paginated and searchable list of all comments related to a specific article, as defined in the requirements (nested structure, logical deletion, evidence). Search criteria can include author fields, timestamp range, parent/child linkage for hierarchical display, etc.\n\nResults present only comments not logically deleted for public users. Admins may access deleted items with proper authorization.\n\nHandles edge cases such as no results, excessive pagination, and filter security. Data comes from the 'bbs_article_comments' table, potentially joined with the latest comment snapshot for list views.\n\nFails with 404 if article doesn't exist, or appropriate error for permission issues.",
        "summary": "List all comments (bbs_article_comments) for an article, with search/filter.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Parameters for searching, filtering, and pagination for comment list.",
          "typeName": "IBbsArticleComment.IRequest"
        },
        "responseBody": {
          "description": "Paginated comment list objects for the article.",
          "typeName": "IPageBbsArticleComment"
        },
        "path": "/bbs/articles/{articleId}/comments",
        "method": "patch"
      },
      {
        "specification": "Add a new comment (bbs_article_comments) to an article. Comment submission requires writer info, content, optional parent (for nested replies), and password for later edits/deletion. File attachments supported via separate linkage. Data saved to 'bbs_article_comments' as parent, then first snapshot and attachments are created in related tables. Returns full comment info with the creation result.",
        "description": "This POST operation creates a new comment on a specific article in the bulletin board system. New comments must include required fields such as writer, password, and initial content, referenced by a parentId if this is a reply to another comment (enables hierarchical threading).\n\nThe operation first creates an entry in 'bbs_article_comments', then creates an initial bbs_article_comment_snapshots record with the comment's content. If files are attached, relevant mapping records are also created in bbs_article_comment_snapshot_files and attachment_files.\n\nEnforces password hashing, IP logging, timestamp recording, and initializes all evidence features.\n\nHandles validation errors (missing fields), permission enforcement, and ensures parent entities exist (article, parent comment if reply). Responds with the created comment structure, including snapshot references and attachment linkage.",
        "summary": "Create a new comment (bbs_article_comments) on an article.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Comment creation input for bbs_article_comments, including parentId, writer, password, and initial content.",
          "typeName": "IBbsArticleComment.ICreate"
        },
        "responseBody": {
          "description": "The created comment information, including snapshots and attachments.",
          "typeName": "IBbsArticleComment"
        },
        "path": "/bbs/articles/{articleId}/comments",
        "method": "post"
      },
      {
        "specification": "Get a specific comment (bbs_article_comments) within an article by ID. Returns detailed comment record, not including historical snapshots. Parent-child relationships are also available for building the hierarchy tree. Excludes logically deleted items for public access.",
        "description": "This GET operation retrieves a single comment by its unique identifier, attached to a specific article. It pulls data from 'bbs_article_comments', confirming article and comment association, and validates that the comment is not logically deleted for public views.\n\nInherited relationships allow easy nesting for replies. The result returns only top-level comment record info (writer, timestamps, parent, etc)–attachable snapshots and files are accessed through other APIs.\n\nPermission and logical deletion rules are enforced: only non-deleted comments are shown publicly, while admins may retrieve deleted comments for evidence or audit purposes.",
        "summary": "Retrieve a specific comment (bbs_article_comments) within an article by ID.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Target comment ID (UUID) in bbs_article_comments",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "The comment object matching the given article and ID, or error if not found.",
          "typeName": "IBbsArticleComment"
        },
        "path": "/bbs/articles/{articleId}/comments/{id}",
        "method": "get"
      },
      {
        "specification": "Update a specific comment (bbs_article_comments) within an article. Supports edits to writer, password, or parent comment linkage, but not the historical content (managed in snapshots). The edit process may trigger new comment snapshot creation for full content revision. Data is saved to 'bbs_article_comments' and related tables as required.",
        "description": "This PUT operation modifies a comment on a given article, addressing certain updatable fields in 'bbs_article_comments' such as writer, password, or parentId (for reply/nesting structure). The revision of contents (body) is handled by subsequent snapshot creation in a nested or parallel API.\n\nUpdates trigger standard evidence retention (audit trails, password verification), and may affect hierarchical threading. Parent entity existence must be verified. Logical deletion rules and permissions apply – deleted comments cannot be modified by typical users.",
        "summary": "Update a specific comment (metadata/relationships) in bbs_article_comments within an article.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Target comment ID (UUID) in bbs_article_comments",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Details for comments update, including writer, password, or parentId for nesting.",
          "typeName": "IBbsArticleComment.IUpdate"
        },
        "responseBody": {
          "description": "The updated comment information, excluding historical snapshots.",
          "typeName": "IBbsArticleComment"
        },
        "path": "/bbs/articles/{articleId}/comments/{id}",
        "method": "put"
      },
      {
        "specification": "Logically delete a comment (bbs_article_comments) by marking it as deleted. This does not remove the record, but sets the deleted_at timestamp. Only non-deleted comments can be targeted for logical deletion. Details governed by evidentiary requirements.",
        "description": "This DELETE operation performs a logical (soft) deletion of a comment on a given article. Instead of removing the record from 'bbs_article_comments', the 'deleted_at' timestamp is set to the current time (soft delete), preserving audit trails for evidence and dispute resolution as mandated by system requirements.\n\nChecks that the targeted comment exists, is not already deleted, and that any user access or password verification requirements are satisfied. Deleted comments are excluded from public retrieval but available for evidence by administrators.\n\nHandles not-found, already-deleted, and access-denial errors appropriately.",
        "summary": "Logically delete (soft-delete) a comment (bbs_article_comments) from an article.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Target comment ID (UUID) in bbs_article_comments",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "The updated information of the now-deleted comment, including timestamp.",
          "typeName": "IBbsArticleComment"
        },
        "path": "/bbs/articles/{articleId}/comments/{id}",
        "method": "delete"
      },
      {
        "specification": "Query all snapshots (bbs_article_comment_snapshots) belonging to a specific comment on a given article. Supports searching, pagination, and filtering by creation date, format, etc. Only returns snapshots for valid, logically available comments, reflecting the full historical evidence as required.",
        "description": "This PATCH operation retrieves all snapshots (revision history) for a given comment attached to an article. Returns paginated and/or filtered results, including metadata such as format, timestamp, author IP, and relevant attachments (linkage only). This allows evidence presentation and rollback investigation for all comment changes.\n\nAccess is restricted depending on logical deletion status and permissions (admins vs. general users). Snapshots provide information for audit, dispute resolution, or version comparison in the UI.\n\nHandles errors for invalid parameters, not-found comment/article ancestors, and respects maximum page size/policy limits.",
        "summary": "List all snapshots (bbs_article_comment_snapshots) for a comment on an article, with search/pagination.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "commentId",
            "description": "Comment ID in bbs_article_comments to which the snapshots belong",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Parameters for searching, pagination, and filtering of comment snapshots.",
          "typeName": "IBbsArticleCommentSnapshot.IRequest"
        },
        "responseBody": {
          "description": "Paginated and filtered list of all snapshots for the given comment.",
          "typeName": "IPageBbsArticleCommentSnapshot"
        },
        "path": "/bbs/articles/{articleId}/comments/{commentId}/snapshots",
        "method": "patch"
      },
      {
        "specification": "Fetch a specific comment snapshot (bbs_article_comment_snapshots) belonging to a given comment on an article. Used for providing evidence/history of comment edits. Returns detailed snapshot record with content, format, IP info, and attachments for that version.",
        "description": "This GET operation retrieves a single revision snapshot for a comment (bbs_article_comment_snapshots). The snapshot is uniquely identified by its attachment to a specific article, comment, and snapshot UUID.\n\nReturns detailed information about the snapshot content, including format, body, creation metadata, author IP, and file attachments (linkage only — actual files accessed through separate API calls).\n\nFails with not-found errors if any identified entity does not exist or is not accessible, and enforces necessary permissions and logical deletion rules.",
        "summary": "Retrieve a specific comment snapshot (bbs_article_comment_snapshots) for a given comment on an article.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "commentId",
            "description": "Comment ID in bbs_article_comments to which the snapshot belongs",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Comment snapshot ID (UUID) in bbs_article_comment_snapshots",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Snapshot details of the identified comment's revision, including format, content, IP, and attachments.",
          "typeName": "IBbsArticleCommentSnapshot"
        },
        "path": "/bbs/articles/{articleId}/comments/{commentId}/snapshots/{id}",
        "method": "get"
      },
      {
        "specification": "Edit details of a comment snapshot (bbs_article_comment_snapshots). Permits update of content, format, or (in some systems) relinking files. Applies to a specific version only; new modifications usually create new snapshots, but this may allow meta-corrections under special permissions.",
        "description": "This PUT operation updates metadata or content for a particular comment snapshot in the evidence system. While general edits typically create new snapshots, this can allow corrections under special administrative circumstances, for evidence correction or dispute resolution.\n\nAccepts content (body), format, and possibly file association adjustments. Must strictly validate parent article and comment, existing snapshot, and business rules for evidentiary control — typical users may not be allowed unless it's for error correction or privileged access.\n\nSide-effects are limited to only the indicated snapshot; evidence/integrity must be preserved.",
        "summary": "Update content or metadata for a specific comment snapshot (bbs_article_comment_snapshots) by ID.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article ID (UUID) in bbs_articles",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "commentId",
            "description": "Comment ID in bbs_article_comments to which the snapshot belongs",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Comment snapshot ID (UUID) in bbs_article_comment_snapshots",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "The content, format, or attachment linkage updates for this comment snapshot.",
          "typeName": "IBbsArticleCommentSnapshot.IUpdate"
        },
        "responseBody": {
          "description": "The updated comment snapshot details after editing.",
          "typeName": "IBbsArticleCommentSnapshot"
        },
        "path": "/bbs/articles/{articleId}/comments/{commentId}/snapshots/{id}",
        "method": "put"
      },
      {
        "specification": "Delete a specific snapshot of a comment in an article. This operation will set a logical deletion (soft delete) flag rather than physically removing the record from the database, according to the business requirement to preserve history for evidence. This API is tightly coupled with the logical structure of the bbs_article_comment_snapshots table in the Prisma schema, and will only be executed after verifying the existence of the parent comment and snapshot IDs. Proper permissions and password validation should be enforced as per requirements. Cascade relationships in the schema ensure child objects and foreign key integrity are preserved.",
        "description": "This operation enables the logical deletion (soft delete) of a comment snapshot record in the bbs_article_comment_snapshots table, nested under a specific comment within a specific article. According to the system's requirements for evidence preservation, this operation sets a deleted flag or timestamp field (rather than actually removing any history data) to make the snapshot invisible to regular end users but still retained in the system for administrative/audit purposes.\n\nThe operation involves several security considerations: only users with the correct password or administrators can perform deletions; IP addresses and audit trail information remain intact for compliance. The operation will fail if provided IDs do not correspond to existing entities.\n\nThis endpoint should be used only when absolutely necessary, such as in compliance with legal requirements or gross abuse. Otherwise, all history should remain permanently retained.",
        "summary": "Logically deletes a comment snapshot (bbs_article_comment_snapshots) by ID, nested under specific article and comment, as per evidence-preservation policy.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "commentId",
            "description": "Target comment's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Target comment snapshot's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": null,
        "path": "/bbs/articles/{articleId}/comments/{commentId}/snapshots/{id}",
        "method": "delete"
      },
      {
        "specification": "Partially updates the attachment files associated with a specific snapshot of a comment in an article by accepting an array of modifications in the request body. This corresponds to the bbs_article_comment_snapshot_files many-to-many join table in the Prisma schema and must ensure the correct mapping and ordering (sequence) of attachments. The PATCH method is ideal due to potentially complex update operations (e.g., order change, add/remove multiple files).",
        "description": "This endpoint provides partial update capability for attachment files on a specific comment snapshot, using a request body referencing ICommentSnapshotFile.IRequest or a similar input type. The underlying table is the bbs_article_comment_snapshot_files, which is responsible for maintaining the association and sequence of each file for each snapshot.\n\nRequest validation ensures atomicity and transactional integrity: all add/remove/order changes are applied in a single transaction. Each update respects the unique sequence field to preserve file display order, a feature critical for end-user UX. Security checks must ensure that users have permission to alter the snapshot (password check/admin rights), and operations must be logged for audit. Related endpoints for attachment_files management should be referenced for holistic file lifecycle control.",
        "summary": "Partially updates attachment files (bbs_article_comment_snapshot_files) for a specific comment snapshot, with support for sequence/order changes.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "commentId",
            "description": "Target comment's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "Target comment snapshot's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Partial update info with the new and/or reordered list of attachment files for the comment snapshot.",
          "typeName": "ICommentSnapshotFile.IRequest"
        },
        "responseBody": {
          "description": "Updated list/summary of the files now attached to the snapshot, including order.",
          "typeName": "ICommentSnapshotFile.ISummary"
        },
        "path": "/bbs/articles/{articleId}/comments/{commentId}/snapshots/{snapshotId}/files",
        "method": "patch"
      },
      {
        "specification": "Create (add) one or multiple attachment files to a specific snapshot of a comment in an article. In the database, this operation inserts new records into the bbs_article_comment_snapshot_files join table, enforcing referential and sequence integrity. The request body should reference the files to attach and their sequence order. Related files must already exist in the attachment_files table.",
        "description": "This endpoint enables the creation/association of one or several attachment files to a given comment snapshot (reference bbs_article_comment_snapshot_files in schema). File IDs must be valid and refer to pre-uploaded resources defined in attachment_files. The request body (ICommentSnapshotFile.ICreate) allows specification of the file(s) to attach and their display sequence/order, in accordance with UX/UI requirements.\n\nUpon success, the endpoint returns the new relationship(s) and order in the response type. All additions occur in a database transaction. Proper authentication, permission, and validation against duplicate/illegal operations are required. Usage of this endpoint is fundamental to supporting evidence‐preserving file associations in comment histories.",
        "summary": "Associates new file(s) with a comment snapshot (bbs_article_comment_snapshot_files), specifying attachment and order.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "commentId",
            "description": "Target comment's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "Target comment snapshot's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Association info (file IDs and any sequence/order) for new attachments to the comment snapshot.",
          "typeName": "ICommentSnapshotFile.ICreate"
        },
        "responseBody": {
          "description": "Details/summary of the newly attached file(s) and their association to the snapshot.",
          "typeName": "ICommentSnapshotFile"
        },
        "path": "/bbs/articles/{articleId}/comments/{commentId}/snapshots/{snapshotId}/files",
        "method": "post"
      },
      {
        "specification": "Retrieve details of a specific attachment file associated with a comment snapshot. This endpoint gets a single bbs_article_comment_snapshot_files record, including file metadata and sequence information, referencing both bbs_article_comment_snapshots and attachment_files in the DB. Access control ensures only users with permissions can retrieve private or deleted resources.",
        "description": "Fetch comprehensive metadata and relational info for a specific attachment file linked to a given comment snapshot. This involves joining bbs_article_comment_snapshot_files to bbs_article_comment_snapshots and attachment_files entities. The response provides display order (sequence), file name, extension, and URL for download/display purposes. Logical deletion/visibility rules apply as per system evidence-retaining policy, and audit trails/documentation should describe how to acquire both current and historical attachment file relationships.",
        "summary": "Retrieves a specific attached file (bbs_article_comment_snapshot_files) for a comment snapshot, with file metadata and order.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "commentId",
            "description": "Target comment's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "Target comment snapshot's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Target attachment relation (bbs_article_comment_snapshot_files.id)",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Metadata and relationship details for specified attached file, including order and file resource info.",
          "typeName": "ICommentSnapshotFile"
        },
        "path": "/bbs/articles/{articleId}/comments/{commentId}/snapshots/{snapshotId}/files/{id}",
        "method": "get"
      },
      {
        "specification": "Update the information (mainly sequence/order) for a specific file associated with a comment snapshot. This operation affects a single join record in the bbs_article_comment_snapshot_files join table. Use for reordering or changing metadata of the association (not of the underlying file resource).",
        "description": "This operation enables updating the relationship data between a comment snapshot and an attached file by modifying the join table record (bbs_article_comment_snapshot_files). It's primarily for changing the file's display order (sequence) or other association-specific metadata. The request body conforms to ICommentSnapshotFile.IUpdate. This operation does not affect the physical file resource stored in attachment_files; use the dedicated API for file asset updates.\n\nPermission and integrity checks are necessary; only authorized users can update attachment associations. Related endpoints for partial update and file creation/deletion should be referenced for a complete file management lifecycle.",
        "summary": "Updates order/association data for an attached file (bbs_article_comment_snapshot_files) for a comment snapshot.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "commentId",
            "description": "Target comment's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "Target comment snapshot's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Target attachment relation (bbs_article_comment_snapshot_files.id)",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Update information, typically just the sequence/order, for the attached file association.",
          "typeName": "ICommentSnapshotFile.IUpdate"
        },
        "responseBody": {
          "description": "Updated relationship/association record with new metadata.",
          "typeName": "ICommentSnapshotFile"
        },
        "path": "/bbs/articles/{articleId}/comments/{commentId}/snapshots/{snapshotId}/files/{id}",
        "method": "put"
      },
      {
        "specification": "Delete the association between a comment snapshot and an attached file from the bbs_article_comment_snapshot_files table. The physical file may remain, but this operation removes the relationship, affecting only the current mapping (not the underlying asset in attachment_files).",
        "description": "This endpoint removes the association between a specific attachment file and a comment snapshot by deleting the join table record (bbs_article_comment_snapshot_files). The file asset remains in the system unless explicitly deleted elsewhere. All deletions must be authorized by permissions consistent with the evidence retention policy. Cascade rules in Prisma model keep referential integrity; access is restricted to users with modification/review rights.\n\nThis operation supports the requirement that, although all evidence must be preserved, attachment relationships may sometimes be retracted per user request or content update, but full delete of history is by exception only.",
        "summary": "Deletes a comment snapshot's file association (bbs_article_comment_snapshot_files) by record ID, keeping asset file intact.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "commentId",
            "description": "Target comment's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "snapshotId",
            "description": "Target comment snapshot's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Target attachment relation (bbs_article_comment_snapshot_files.id)",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": null,
        "path": "/bbs/articles/{articleId}/comments/{commentId}/snapshots/{snapshotId}/files/{id}",
        "method": "delete"
      },
      {
        "specification": "Retrieve a paginated, filterable list of attachment_files records. Enables searching/filtering by name, extension, creation date, or other file metadata. This matches the attachment_files table in the Prisma schema, supporting file management needs for all articles and comments.",
        "description": "This operation retrieves a list of file resources managed in the system (attachment_files table), supporting flexible searching and filtering capabilities according to user, admin, or system automation needs. Supports pagination, sorting by date/filename, and querying by file type or other metadata, improving file list usability in UI grids and admin panels.\n\nSearch requests reference the IAttachmentFile.IRequest schema, encapsulating search and filter parameters, and responses return IPageIAttachmentFile, containing pagination metadata plus file entries. Deletion/creation is handled via separate endpoints, and logical deletion policies must be respected if implemented in the table.",
        "summary": "Retrieves a paginated, searchable, sortable list of file resources (attachment_files).",
        "parameters": [],
        "requestBody": {
          "description": "File search and filter parameters (filename, extension, createdAt, etc.)",
          "typeName": "IAttachmentFile.IRequest"
        },
        "responseBody": {
          "description": "Paginated result of file resources matching query/filter, with pagination info.",
          "typeName": "IPageIAttachmentFile"
        },
        "path": "/attachmentFiles",
        "method": "patch"
      },
      {
        "specification": "Create a new file resource in the attachment_files table, tracking all required metadata. The request typically contains file handle/upload URL, name, and extension; physical file upload is handled separately, and this creates the DB reference.",
        "description": "This endpoint provisions a new file record in the attachment_files table, referencing metadata for an already-uploaded asset. The request body conforms to IAttachmentFile.ICreate, containing the file name, extension (nullable), and file URL. On success, it returns the created file resource with full metadata and unique assigned UUID. Cascade relationships in the schema guarantee that any later association to articles or comments snapshots is transactional and consistent.\n\nThe file must be accessible by given URL and reserved for evidence retention purposes. Multiple objects can reference the same file asset as attachments, enabled by the join tables. Security and validation ensure the integrity and uniqueness of file records.",
        "summary": "Creates a new attachment file resource (attachment_files) with required metadata and file URL.",
        "parameters": [],
        "requestBody": {
          "description": "File resource metadata including name, extension, and file URL.",
          "typeName": "IAttachmentFile.ICreate"
        },
        "responseBody": {
          "description": "The newly created file resource metadata and unique system ID.",
          "typeName": "IAttachmentFile"
        },
        "path": "/attachmentFiles",
        "method": "post"
      },
      {
        "specification": "Retrieve a specific attachment file resource by its id. Gets metadata (name, extension, url, createdAt) for the target attachment_files record, supporting download/render functionality for attachments.",
        "description": "Fetch details for a single file resource from attachment_files by its system ID (UUID). Results include filename, extension, download URL, and other metadata for correct rendering and download in UI or for API-based consumption. Soft/hard delete status must be respected by this endpoint if supported in the schema, showing only valid, non-deleted resources as appropriate. Error handling required for missing IDs.",
        "summary": "Gets a specific attachment file resource (attachment_files) by its UUID ID.",
        "parameters": [
          {
            "name": "id",
            "description": "Target file resource's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "All metadata for the specified file resource, including download/render info.",
          "typeName": "IAttachmentFile"
        },
        "path": "/attachmentFiles/{id}",
        "method": "get"
      },
      {
        "specification": "Update (PUT) operation to modify the attributes of an existing file resource in attachment_files. Used for changing filename, extension, or file URL. Does not affect file content, only DB metadata.",
        "description": "This endpoint enables authorized changes to metadata for an attachment file in the attachment_files table, such as filename, extension, or URL. The request body IAttachmentFile.IUpdate allows for one or more of these fields to be edited. Cascade relationships maintain referential integrity with join tables; updating file resources is critical for correcting errors or unifying data.\n\nAudit/compliance logging recommended for all changes; proper permission checks are required. Actual file content is not altered by this DB operation, only system-associated metadata.",
        "summary": "Updates metadata for an attachment file (attachment_files), e.g., filename, extension, or URL.",
        "parameters": [
          {
            "name": "id",
            "description": "Target file resource's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Updated metadata values for the attachment file (name, extension, url).",
          "typeName": "IAttachmentFile.IUpdate"
        },
        "responseBody": {
          "description": "The updated file resource data after modification.",
          "typeName": "IAttachmentFile"
        },
        "path": "/attachmentFiles/{id}",
        "method": "put"
      },
      {
        "specification": "Delete a file resource from the attachment_files table by its unique ID. This operation physically removes file metadata and may trigger external file deletion (handled separately). Carefully coordinate with join tables and soft-deletion policies in the evidence-preserving context.",
        "description": "This endpoint allows full (hard) deletion of a file resource from the attachment_files table. It is restricted to situations where evidence retention policy and all association constraints are addressed. All children join records (bbs_article_snapshot_files, bbs_article_comment_snapshot_files) must be evaluated for foreign key safety—usually via ON DELETE CASCADE.\n\nLogical deletion may be preferable in auditing scenarios; however, this endpoint completely removes the file record, thus any download or reference links will become defunct. Only highly privileged actions and system clean-up tasks should invoke this.",
        "summary": "Physically deletes (fully removes) a file resource (attachment_files) by its system ID.",
        "parameters": [
          {
            "name": "id",
            "description": "Target file resource's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": null,
        "path": "/attachmentFiles/{id}",
        "method": "delete"
      }
    ],
    "components": {
      "schemas": {
        "IBbsArticle.IRequest": {
          "type": "object",
          "description": "Query data type for bulletin board article search or pagination.\n\nThis type corresponds to search, filter, sort, and pagination input for the BBS article listing endpoint. Each property enables selection or limitation by various fields and is mapped to the business context described in the requirements (efficient retrieval, search by writer/title/date, etc).",
          "properties": {
            "title": {
              "type": "string",
              "description": "Title search keyword.\n\nIf provided, filters to articles whose latest snapshot's title matches or contains the value.\n\nRef: bbs_article_snapshots.title"
            },
            "writer": {
              "type": "string",
              "description": "Exact or partial writer name for search.\n\nUsed to filter articles by the 'writer' value in bbs_articles.writer."
            },
            "createdAtFrom": {
              "type": "string",
              "format": "date-time",
              "description": "Lower bound (inclusive) for article creation time.\n\nFilters articles newer than or equal to the specified date/time.\n\nRef: bbs_articles.created_at"
            },
            "createdAtTo": {
              "type": "string",
              "format": "date-time",
              "description": "Upper bound (inclusive) for article creation time (latest).\n\nShow articles created before or at the specified date/time."
            },
            "deleted": {
              "type": "boolean",
              "description": "Show logically deleted articles also.\n\nIf true, include soft-deleted articles (bbs_articles.deleted_at is non-null). Only allowed for admins."
            },
            "orderBy": {
              "oneOf": [
                {
                  "const": "createdAtDesc",
                  "description": "Sort field for article listing.\n\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first."
                },
                {
                  "const": "createdAtAsc",
                  "description": "Sort field for article listing.\n\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first."
                },
                {
                  "const": "titleAsc",
                  "description": "Sort field for article listing.\n\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first."
                },
                {
                  "const": "titleDesc",
                  "description": "Sort field for article listing.\n\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first."
                }
              ],
              "description": "Sort field for article listing.\n\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first."
            },
            "page": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "description": "Page number for pagination (1-based).\nDefaults to 1."
            },
            "limit": {
              "type": "integer",
              "format": "int32",
              "minimum": 1,
              "maximum": 100,
              "default": 20,
              "description": "Number of articles per page. Enforced max 100 to prevent overload."
            }
          },
          "required": []
        },
        "IPageIBbsArticle.ISummary": {
          "type": "object",
          "description": "Paginated response type for BBS article summaries.\n\nContains both pagination metadata and actual list of article summary objects as required for efficient list display in UI, referencing the standard IPage<T> approach.",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination"
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticle.ISummary"
              },
              "description": "Array of summarized articles for the list page."
            }
          },
          "required": []
        },
        "IBbsArticle.ICreate": {
          "type": "object",
          "description": "Request body type for creating a new BBS article.\n\nCorresponds to the requirements for BBS post creation (including author, password, content, and initial attachments). On creation, both bbs_articles and the initial bbs_article_snapshots record are created in a transaction. All properties are mapped to the data fields and business constraints described for posting in the requirements and the DB schema.",
          "properties": {
            "writer": {
              "type": "string",
              "description": "Author's name for the new article (required).\n\nMaps to bbs_articles.writer. Required on creation, displayable in list/detail."
            },
            "password": {
              "type": "string",
              "format": "password",
              "description": "Author password for edit/delete. Set on create and used for future auth/verification.\n\nMapped to bbs_articles.password (stored encrypted). Required on creation, write-only, not retrievable via detail endpoints."
            },
            "title": {
              "type": "string",
              "description": "Title text for the new article's first version/snapshot.\n\nMapped to bbs_article_snapshots.title. Required for creation."
            },
            "body": {
              "type": "string",
              "description": "Body/content for the initial snapshot of the article.\n\nMapped to bbs_article_snapshots.body. Required on creation."
            },
            "format": {
              "type": "string",
              "description": "Format of the body (e.g., 'html', 'md', 'txt').\n\nMapped to bbs_article_snapshots.format (content format for body storage)."
            },
            "ip": {
              "type": "string",
              "description": "IP address for evidence. Recorded at creation and snapshot."
            },
            "attachments": {
              "type": "array",
              "description": "Initial attachment files for the article's first snapshot (optional).\n\nLinks to attachment_files via bbs_article_snapshot_files. Specify as list of IDs and sequence/order.",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleSnapshotFile.ICreate"
              }
            }
          },
          "required": [
            "writer",
            "password",
            "title",
            "body",
            "format",
            "ip"
          ]
        },
        "IBbsArticle": {
          "type": "object",
          "description": "Main entity type for BBS articles.\n\nRepresents the core article record, corresponding to bbs_articles in Prisma and ERD, but including related entities such as the latest snapshot, comment count, and attachments list as described in the requirements. Used for article detail, creation, and mutation result.\n\nIncludes all mandatory and optional fields required for full persistence and evidence, as described in requirements and schema. Each property is fully documented for clarity and legal traceability.",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier of article (UUID), primary key of bbs_articles.\n\nGenerated at creation, used for all subsequent operations."
            },
            "writer": {
              "type": "string",
              "description": "Original author's name, as entered on creation.\n\nRead-only after creation, except for admin/system update."
            },
            "password": {
              "type": "string",
              "format": "password",
              "description": "Encrypted password for proof of authorship and modification/deletion verification.\n\nNever returned in detail or list APIs, write-only (masked in UI)."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp of original article creation.\n\nMapped to bbs_articles.created_at."
            },
            "deleted_at": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Timestamp when logically deleted (soft delete).\n\nIndicates deletion in soft-delete model. Null if not deleted, else deleted. Mapped to bbs_articles.deleted_at."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Timestamp when logically deleted (soft delete).\n\nIndicates deletion in soft-delete model. Null if not deleted, else deleted. Mapped to bbs_articles.deleted_at."
            },
            "latestSnapshot": {
              "$ref": "#/components/schemas/IBbsArticleSnapshot.ISummary",
              "description": "Latest content snapshot for this article, showing title, body (current), format, ip, and related metadata. Used for basic detail and list views."
            },
            "commentCount": {
              "type": "integer",
              "format": "int32",
              "description": "Total number of comments directly associated with this article (non-deleted only). For UI performance and sorting."
            },
            "attachments": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleSnapshotFile.ISummary"
              },
              "description": "List of attachments of the current (latest) snapshot, ordered by sequence."
            },
            "snapshots": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleSnapshot"
              },
              "description": "Complete snapshot revision history (usually only for admin or dedicated history endpoint)."
            },
            "comments": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleComment"
              },
              "description": "All associated comments (hierarchical structure not encoded here, only flat by default)."
            }
          },
          "required": [
            "id",
            "writer",
            "created_at",
            "latestSnapshot"
          ]
        },
        "IBbsArticle.IUpdate": {
          "type": "object",
          "description": "Request body type for updating/editing a BBS article.\n\nCorresponds to the business process of verifying password, establishing a new snapshot with changed contents (title/body/format), and adjusting attachments. All changes create new evidence records. Mapped to the 'edit post' requirement and Prisma/ERD structure.",
          "properties": {
            "password": {
              "type": "string",
              "format": "password",
              "description": "Author password to verify permission for update. Required for editing or deleting articles for evidence."
            },
            "title": {
              "type": "string",
              "description": "New title text for update. Used for the new snapshot. Optional if not changed."
            },
            "body": {
              "type": "string",
              "description": "New body/content for update. Used for the new snapshot. Optional if not changed."
            },
            "format": {
              "type": "string",
              "description": "New format string (html/md/txt/etc.). Optional."
            },
            "attachments": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleSnapshotFile.ICreate"
              },
              "description": "Updated list of attachment files (add/delete/reorder) for this snapshot (optional)."
            },
            "ip": {
              "type": "string",
              "description": "IP address for evidence. Must be included for auditing."
            }
          },
          "required": [
            "password",
            "ip"
          ]
        },
        "IBbsArticle.IDelete": {
          "type": "object",
          "description": "Request body for logical deletion (soft-delete) of a BBS article by ID.\n\nAs per specifications, the password verifies authorship for the deletion. Deletion sets deleted_at only. Evidence/history is retained. Admins may have alternate logic for forced deletion.",
          "properties": {
            "password": {
              "type": "string",
              "format": "password",
              "description": "Password for logical deletion verification. Required to authorize soft-delete."
            }
          },
          "required": [
            "password"
          ]
        },
        "IBbsArticleSnapshot.IRequest": {
          "type": "object",
          "description": "Pagination/filter/search type for listing all revision snapshots of a given article.\n\nMaps to the need to efficiently retrieve long modification histories. Used for PATCH /bbs/articles/{articleId}/snapshots.",
          "properties": {
            "format": {
              "type": "string",
              "description": "Filter by snapshot body format (e.g., md/html/txt)."
            },
            "createdAtFrom": {
              "type": "string",
              "format": "date-time",
              "description": "Lower date/time filter for snapshot creation."
            },
            "createdAtTo": {
              "type": "string",
              "format": "date-time",
              "description": "Upper date/time filter for snapshot creation."
            },
            "orderBy": {
              "oneOf": [
                {
                  "const": "createdAtDesc",
                  "description": "Sort by creation date (default to latest first)."
                },
                {
                  "const": "createdAtAsc",
                  "description": "Sort by creation date (default to latest first)."
                }
              ],
              "description": "Sort by creation date (default to latest first)."
            },
            "page": {
              "type": "integer",
              "format": "int32",
              "description": "Pagination; page number, starting from 1."
            },
            "limit": {
              "type": "integer",
              "format": "int32",
              "description": "Per-page record limit, default 20."
            }
          },
          "required": []
        },
        "IPageIBbsArticleSnapshot": {
          "type": "object",
          "description": "Paging container for lists of article snapshot revision records.\n\nConforms to standard paging shape, with IPage.IPagination and data (IBbsArticleSnapshot[]). For use when listing all revisions of an article.",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination"
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleSnapshot"
              },
              "description": "Array of all revision snapshot records for given article."
            }
          },
          "required": []
        },
        "IBbsArticleSnapshot": {
          "type": "object",
          "description": "Represents a single revision snapshot of an article (bbs_article_snapshots table).\n\nIncludes all fields for audit/evidence (body, title, format, ip, attachments list, creation time, etc.). Used for both detail views and snapshot histories.",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for this snapshot (UUID).\n\nPrimary key of bbs_article_snapshots."
            },
            "bbs_article_id": {
              "type": "string",
              "format": "uuid",
              "description": "Reference article ID for this snapshot.\n\nForeign key to bbs_articles.id."
            },
            "title": {
              "type": "string",
              "description": "Title of the post at this revision.\n\nSnapshots record the state as of this revision; may differ from current."
            },
            "body": {
              "type": "string",
              "description": "Body/content of article at this specific revision."
            },
            "format": {
              "type": "string",
              "description": "Format for body—one of html/md/txt/etc."
            },
            "ip": {
              "type": "string",
              "description": "Writer's IP address at time of modification."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp of when this revision was created. Used for precise evidence chain."
            },
            "attachments": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleSnapshotFile.ISummary"
              },
              "description": "Attachment files list at this revision (may differ per snapshot, follows sequence/order property)."
            }
          },
          "required": [
            "id",
            "bbs_article_id",
            "title",
            "body",
            "format",
            "created_at"
          ]
        },
        "IBbsArticleSnapshot.IUpdate": {
          "type": "object",
          "description": "Request schema for updating an article snapshot (admin/system only).\n\nAllows updating title/body/format or file association for special cases. For general users, only new snapshots are created instead.",
          "properties": {
            "title": {
              "type": "string",
              "description": "Updated title for this snapshot (optional)."
            },
            "body": {
              "type": "string",
              "description": "Updated body/content for this snapshot (optional)."
            },
            "format": {
              "type": "string",
              "description": "Updated format (e.g., html/md/txt) for this snapshot (optional)."
            },
            "attachments": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleSnapshotFile.IUpdate"
              },
              "description": "Adjusted list of attached files for this snapshot."
            }
          },
          "required": []
        },
        "IBbsArticleSnapshot.IDelete": {
          "type": "object",
          "description": "Request body for logical deletion of an article snapshot (admin/system only).\n\nAs evidence, snapshots are generally not deleted, but this API allows logical deletion for policy/compliance needs. Fields for metadata or reason may be added.",
          "properties": {
            "reason": {
              "type": "string",
              "description": "Reason for deletion (optional, for audit/compliance logging)."
            }
          },
          "required": []
        },
        "IBbsArticleSnapshotFile.IRequest": {
          "type": "object",
          "description": "Request schema for paginated listing/partial update/complex query of files attached to an article snapshot.\n\nUsed to filter, search, or modify attachment order for snapshot files. Maps sequences and handles per-snapshot association maintenance.",
          "properties": {
            "attachment_file_id": {
              "type": "string",
              "format": "uuid",
              "description": "Filter for specific attachment file UUID."
            },
            "orderBy": {
              "oneOf": [
                {
                  "const": "createdAtDesc",
                  "description": "Sort order for files attached to a snapshot."
                },
                {
                  "const": "createdAtAsc",
                  "description": "Sort order for files attached to a snapshot."
                },
                {
                  "const": "sequenceAsc",
                  "description": "Sort order for files attached to a snapshot."
                },
                {
                  "const": "sequenceDesc",
                  "description": "Sort order for files attached to a snapshot."
                }
              ],
              "description": "Sort order for files attached to a snapshot."
            },
            "page": {
              "type": "integer",
              "format": "int32"
            },
            "limit": {
              "type": "integer",
              "format": "int32"
            }
          },
          "required": []
        },
        "IPage.IPagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "format": "uint32",
              "description": "Current page number.\n\nHelps the client understand which subset of total records is being viewed."
            },
            "limit": {
              "type": "integer",
              "format": "uint32",
              "description": "Number of records per page (default 100).\n\nAssists performance tuning for UI grids and API result limits."
            },
            "records": {
              "type": "integer",
              "format": "uint32",
              "description": "Total available records in the database matching current query.\n\nAllows accurate pagination and total count calculations."
            },
            "pages": {
              "type": "integer",
              "format": "uint32",
              "description": "Total number of pages available for the data set.\n\nComputed as records/limit with ceiling, helps navigation controls."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Pagination metadata for paged OpenAPI results.\n\nStandardizes page navigation and client-side page controls per IPage<T>."
        },
        "IBbsArticle.ISummary": {
          "type": "object",
          "description": "Summary data for a BBS article, for list display.\n\nSynced to list view requirements (title, writer, comment count, created_at, etc.). Does not include full snapshot/attachments/comments.",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "ID of the article."
            },
            "writer": {
              "type": "string",
              "description": "Author's name."
            },
            "title": {
              "type": "string",
              "description": "Title from the latest snapshot."
            },
            "commentCount": {
              "type": "integer",
              "format": "int32",
              "description": "Number of comments attached (non-deleted only)."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Creation time for article."
            },
            "deleted_at": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Soft delete timestamp, if present."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Soft delete timestamp, if present."
            }
          },
          "required": [
            "id",
            "writer",
            "title",
            "commentCount",
            "created_at"
          ]
        },
        "IBbsArticleSnapshot.ISummary": {
          "type": "object",
          "description": "Summary view of an article snapshot.\n\nFor embedding only the essential info about the content body/version for displays or relationships. Contains fields such as title, body, format, and creation time.",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Snapshot UUID."
            },
            "title": {
              "type": "string",
              "description": "Title (as of this snapshot)."
            },
            "body": {
              "type": "string",
              "description": "Content/body of this snapshot."
            },
            "format": {
              "type": "string",
              "description": "Body format at the time (html/md/txt)."
            },
            "ip": {
              "type": "string",
              "description": "IP address for evidence (stored at snapshot creation)."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Snapshot creation date/time."
            }
          },
          "required": [
            "id",
            "title",
            "body",
            "format",
            "created_at"
          ]
        },
        "IBbsArticleSnapshotFile.ICreate": {
          "type": "object",
          "properties": {
            "attachment_file_id": {
              "type": "string",
              "format": "uuid",
              "description": "ID of the attachment file to link (attachment_files.id).\n\nMust reference an existing uploaded file resource."
            },
            "sequence": {
              "type": "integer",
              "description": "Display order (sequence) for the file in this snapshot's file list.\n\nMandatory in UI/UX so that download or preview order can be explicit."
            }
          },
          "required": [
            "attachment_file_id",
            "sequence"
          ],
          "description": "Request body for attaching a file to a specific article snapshot in the BBS system.\n\nFields provide file reference (attachment_file_id) and ordering (sequence) per business needs and evidentiary requirements."
        },
        "IBbsArticleSnapshotFile.IUpdate": {
          "type": "object",
          "properties": {
            "sequence": {
              "type": "integer",
              "description": "Updated display order (sequence) for this file in the snapshot.\n\nUtilized for user-driven attachment reordering or administrative correction."
            }
          },
          "required": [
            "sequence"
          ],
          "description": "Request body for updating the attachment sequence/order in a given article snapshot's attachment file list.\n\nOnly reordering field (sequence) allowed for normal operations; for evidence preservation, other fields are not modifiable by typical users."
        },
        "IBbsArticleSnapshotFile.ISummary": {
          "type": "object",
          "description": "Summary object for an individual file attached to an article snapshot (bbs_article_snapshot_files), for display in list/detail views.\n\nIncludes both the relationship (sequence, etc.) and the core file metadata (name, extension, url, created_at) from attachment_files.",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "UUID relation key for the file in this snapshot (bbs_article_snapshot_files.id)"
            },
            "sequence": {
              "type": "integer",
              "description": "Display order of the file in the snapshot."
            },
            "file": {
              "$ref": "#/components/schemas/IAttachmentFile.ISummary",
              "description": "Basic metadata for the file asset (name, extension, url, created_at, etc.)"
            }
          },
          "required": [
            "id",
            "sequence",
            "file"
          ]
        },
        "IAttachmentFile.ISummary": {
          "type": "object",
          "description": "Summary view of attachment file info (attachment_files), for use in detail/list views.\n\nContains only identifying and most-accessed metadata properties for files attached to snapshots or comments.",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "File's unique ID (attachment_files.id)"
            },
            "name": {
              "type": "string",
              "description": "Filename, excluding extension."
            },
            "extension": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "File extension (can be null, e.g., README)"
                },
                {
                  "type": "null"
                }
              ],
              "description": "File extension (can be null, e.g., README)"
            },
            "url": {
              "type": "string",
              "description": "URL link to actual file storage."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Time at which the file was added/registered."
            }
          },
          "required": [
            "id",
            "name",
            "url",
            "created_at"
          ]
        },
        "IBbsArticleComment": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the comment (bbs_article_comments.id)."
            },
            "bbs_article_id": {
              "type": "string",
              "format": "uuid",
              "description": "UUID for the parent article (bbs_articles.id) this comment belongs to."
            },
            "parent_id": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "description": "Parent comment UUID (for replies/subcomments).\n\nNull for top-level comments."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Parent comment UUID (for replies/subcomments).\n\nNull for top-level comments."
            },
            "writer": {
              "type": "string",
              "description": "Display name of the comment's author (bbs_article_comments.writer)."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "When the comment was first created (bbs_article_comments.created_at)."
            },
            "deleted_at": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Logical deletion timestamp for evidence compliance. Null if active."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Logical deletion timestamp for evidence compliance. Null if active."
            },
            "snapshots": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleCommentSnapshot"
              },
              "description": "Revision history snapshots for this comment.\n\nEach represents a modification state (title, body, files, IP, time, etc.)."
            },
            "children": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleComment"
              },
              "description": "Immediate child/nested replies. Recursive for unlimited hierarchy depth."
            }
          },
          "required": [
            "id",
            "bbs_article_id",
            "writer",
            "created_at",
            "snapshots"
          ],
          "description": "Main comment entity for the evidence-preserving BBS system.\n\nMaps to bbs_article_comments, holds hierarchical relationships, attached snapshots, and logical deletion flags."
        },
        "IPageIBbsArticleSnapshotFile": {
          "type": "object",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination",
              "description": "Pagination information.\n\nIndicates the current page, page size, total record count, and number of pages. See IPage.IPagination for field-level details."
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleSnapshotFile"
              },
              "description": "Array of files attached to the article snapshot on this page.\n\nEach entry represents a file relationship, including sequence/order and file metadata."
            }
          },
          "required": [
            "pagination",
            "data"
          ],
          "description": "Paginated list of files attached to an article snapshot, for the evidence-preserving bulletin board system.\n\nBased on the 'bbs_article_snapshot_files' and related attachment_files tables from the Prisma schema. Designed for performance in UI file listing and audit views. Includes detailed pagination and attachment sequence information."
        },
        "IBbsArticleSnapshotFile": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Primary Key for this attachment relation (bbs_article_snapshot_files.id).\n\nUniquely identifies the relationship, not the physical file."
            },
            "bbs_article_snapshot_id": {
              "type": "string",
              "format": "uuid",
              "description": "ID of the snapshot to which this file is attached.\n\nReferences bbs_article_snapshots.id. Connects relationship and enables evidence-based traceability."
            },
            "attachment_file_id": {
              "type": "string",
              "format": "uuid",
              "description": "ID of the attached file (attachment_files.id)."
            },
            "sequence": {
              "type": "integer",
              "description": "Display sequence within the list of this snapshot's attachments.\n\nUsed for end-user UX (order of preview/download) and for forensics."
            },
            "file": {
              "$ref": "#/components/schemas/IAttachmentFile",
              "description": "Metadata about the attached file resource. See AttachmentFile for detailed member info."
            }
          },
          "required": [
            "id",
            "bbs_article_snapshot_id",
            "attachment_file_id",
            "sequence",
            "file"
          ],
          "description": "Represents the file attachment relationship for a specific article snapshot in the evidence-preserving bulletin board system.\n\nBased on bbs_article_snapshot_files, includes file reference, sequence order, and resolved file metadata for full download and auditability."
        },
        "IBbsArticleComment.IRequest": {
          "type": "object",
          "properties": {
            "page": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "description": "Optional page number for pagination.\n\nDefines which page of the comment list to fetch."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional page number for pagination.\n\nDefines which page of the comment list to fetch."
            },
            "limit": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "description": "How many comment entries should be returned per page (default 100).\n\nSupports UI efficiency and server protection."
                },
                {
                  "type": "null"
                }
              ],
              "description": "How many comment entries should be returned per page (default 100).\n\nSupports UI efficiency and server protection."
            },
            "writer": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "Optional comment writer to filter results (bbs_article_comments.writer).\n\nEnables search by author display name."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional comment writer to filter results (bbs_article_comments.writer).\n\nEnables search by author display name."
            },
            "created_at_from": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Optional lower bound for comment creation datetime.\n\nUsed for filtering searches by time window."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional lower bound for comment creation datetime.\n\nUsed for filtering searches by time window."
            },
            "created_at_to": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Optional upper bound for comment creation datetime."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional upper bound for comment creation datetime."
            },
            "parent_id": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "description": "Parent comment's ID. Used for hierarchy filtering.\n\nSet for displaying top-level comments (null) or replies (non-null)."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Parent comment's ID. Used for hierarchy filtering.\n\nSet for displaying top-level comments (null) or replies (non-null)."
            }
          },
          "description": "Request parameters for listing, searching, and paging comments for an article.\n\nSupports flexible filtering by author, date, parent comment (for hierarchy), and standard pagination.",
          "required": []
        },
        "IPageBbsArticleComment": {
          "type": "object",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination",
              "description": "Paging metadata for the comment list."
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleComment"
              },
              "description": "Array of comments in this response page. Each contains BBS article comment metadata and references to parent/hierarchy info."
            }
          },
          "required": [
            "pagination",
            "data"
          ],
          "description": "Paginated response for a list of comments attached to an article in the evidence-preserving bulletin board system.\n\nBuilt upon bbs_article_comments."
        },
        "IBbsArticleComment.ICreate": {
          "type": "object",
          "properties": {
            "bbs_article_id": {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the parent article (bbs_articles.id) to which this comment is posted."
            },
            "parent_id": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "description": "UUID of the parent comment if this is a reply.\n\nFor flat comments, null. Enables unlimited depth hierarchies."
                },
                {
                  "type": "null"
                }
              ],
              "description": "UUID of the parent comment if this is a reply.\n\nFor flat comments, null. Enables unlimited depth hierarchies."
            },
            "writer": {
              "type": "string",
              "description": "Display name used for this comment's author. Stored in bbs_article_comments.writer."
            },
            "password": {
              "type": "string",
              "description": "Password for comment modification/deletion.\n\nEncrypted in storage per evidence/compliance requirements."
            },
            "initial_body": {
              "type": "string",
              "description": "The text body for the initial comment content (used in first snapshot record creation)."
            },
            "initial_format": {
              "type": "string",
              "description": "Format type of the comment body: 'md', 'html', 'txt', etc.\n\nAligns with the body format field in bbs_article_comment_snapshots."
            },
            "initial_files": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleCommentSnapshotFile.ICreate"
              },
              "description": "Initial list of files attached to this comment when first posted.\n\nRelates to evidence/attachment mapping. Optional—may be empty."
            }
          },
          "required": [
            "bbs_article_id",
            "writer",
            "password",
            "initial_body",
            "initial_format"
          ],
          "description": "Request body to create a new comment on a BBS article.\n\nInitial content/format and files are included for atomic evidence creation and ease of use."
        },
        "IBbsArticleComment.IUpdate": {
          "type": "object",
          "properties": {
            "writer": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "If updated, replaces current display name for comment's author."
                },
                {
                  "type": "null"
                }
              ],
              "description": "If updated, replaces current display name for comment's author."
            },
            "parent_id": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "description": "If changed, will update nesting/parent of the comment."
                },
                {
                  "type": "null"
                }
              ],
              "description": "If changed, will update nesting/parent of the comment."
            },
            "password": {
              "type": "string",
              "description": "New password value, if changed.\n\nStored securely (hash/encrypt) per evidence/audit policy."
            }
          },
          "description": "Editable fields for updating a comment's metadata/relationships in bbs_article_comments.\n\nComment body/content is not updated here (managed via snapshot creation).",
          "required": []
        },
        "IBbsArticleCommentSnapshot.IRequest": {
          "type": "object",
          "properties": {
            "page": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "description": "Page number for snapshot history pagination."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Page number for snapshot history pagination."
            },
            "limit": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "description": "Number of snapshots per page; default is 100."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Number of snapshots per page; default is 100."
            }
          },
          "description": "Request body for paginated retrieval of a comment's revision snapshot history.\n\nUsed in PATCH /bbs/articles/{articleId}/comments/{commentId}/snapshots.",
          "required": []
        },
        "IPageBbsArticleCommentSnapshot": {
          "type": "object",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination",
              "description": "Pagination information for comment snapshot history."
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleCommentSnapshot"
              },
              "description": "Snapshots found for this comment and page."
            }
          },
          "required": [
            "pagination",
            "data"
          ],
          "description": "Paginated response for a comment's snapshot history in the evidence-preserving BBS.\n\nMaps from bbs_article_comment_snapshots and associated relationships."
        },
        "IBbsArticleCommentSnapshot": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Primary key of the comment snapshot (bbs_article_comment_snapshots.id)."
            },
            "bbs_article_comment_id": {
              "type": "string",
              "format": "uuid",
              "description": "ID of the parent comment this snapshot is for."
            },
            "format": {
              "type": "string",
              "description": "Format of the snapshot's text body (md/html/txt/...)."
            },
            "body": {
              "type": "string",
              "description": "Body/content text of the comment at this revision."
            },
            "ip": {
              "type": "string",
              "description": "Writer's IP at this revision for evidence purposes."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Revision/snapshot creation timestamp."
            },
            "files": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleCommentSnapshotFile"
              },
              "description": "Array of files attached to this specific snapshot version."
            }
          },
          "required": [
            "id",
            "bbs_article_comment_id",
            "format",
            "body",
            "ip",
            "created_at"
          ],
          "description": "Snapshot version record for a BBS article comment in the evidence-preserving system.\n\nAllows auditability of all edits, preserving prior versions and attached files."
        },
        "IBbsArticleCommentSnapshotFile.ICreate": {
          "type": "object",
          "properties": {
            "attachment_file_id": {
              "type": "string",
              "format": "uuid",
              "description": "The file's system UUID to link."
            },
            "sequence": {
              "type": "integer",
              "description": "Order/position for file display."
            }
          },
          "required": [
            "attachment_file_id",
            "sequence"
          ],
          "description": "Used for initial file attachment when creating a new comment snapshot."
        },
        "IBbsArticleCommentSnapshotFile": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Primary key (join record) for comment snapshot to file attachment."
            },
            "bbs_article_comment_snapshot_id": {
              "type": "string",
              "format": "uuid",
              "description": "Comment snapshot this file is associated with."
            },
            "attachment_file_id": {
              "type": "string",
              "format": "uuid",
              "description": "The linked file's unique system id."
            },
            "sequence": {
              "type": "integer",
              "description": "File ordering for user-facing presentation and audit."
            },
            "file": {
              "$ref": "#/components/schemas/IAttachmentFile",
              "description": "File resource metadata—name, extension, URL, upload info, etc."
            }
          },
          "required": [
            "id",
            "bbs_article_comment_snapshot_id",
            "attachment_file_id",
            "sequence",
            "file"
          ],
          "description": "Models relationship between a comment snapshot and an attached file in the evidence system.\n\nMirrors bbs_article_comment_snapshot_files in Prisma with metadata for retrieval/rendering/audit."
        },
        "IAttachmentFile": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Primary key of the attachment file resource (attachment_files.id).\n\nGuarantees unique identification for download, display, and management."
            },
            "name": {
              "type": "string",
              "description": "File name (without extension).\n\nDirectly from attachment_files.name; guides human-readable file listings."
            },
            "extension": {
              "type": "string",
              "description": "File extension if present (nullable).\n\nTaken from attachment_files.extension, may be null for files like README or LICENSE."
            },
            "url": {
              "type": "string",
              "description": "File URL for download/storage reference.\n\nProvided by attachment_files.url in the Prisma schema."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp of file creation (ISO 8601).\n\nFrom attachment_files.created_at; ensures evidence and lifecycle audit for this resource."
            }
          },
          "required": [
            "id",
            "name",
            "url",
            "created_at"
          ],
          "description": "Attachment file resource object for all file entities (attachment_files).\n\nRepresents a managed asset for evidence, with metadata used throughout the BBS UI and evidence system."
        },
        "IBbsArticleCommentSnapshot.IUpdate": {
          "type": "object",
          "properties": {
            "format": {
              "type": "string",
              "description": "Format of the comment content body (e.g., 'html', 'md', 'txt').\n\nCorresponds to the 'format' column in bbs_article_comment_snapshots, denoting the format of the comment body for the specific snapshot."
            },
            "body": {
              "type": "string",
              "description": "Content body of the comment.\n\nReflects the 'body' in bbs_article_comment_snapshots, holding the modified text of this specific revision."
            },
            "to_files": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ICommentSnapshotFile.ICreate"
              },
              "description": "List of file associations to be attached with this snapshot update.\n\nReferences new or changed file linkage when updating the snapshot. Each file entry conforms to ICommentSnapshotFile.ICreate."
            }
          },
          "required": [],
          "description": "Update request body for a comment snapshot (bbs_article_comment_snapshots).\n\nAllows admin/system-level correction of snapshot details: format, body, and updated file attachments. Fulfills evidentiary correction by privileged actors as described in BBS requirements and Prisma schema."
        },
        "ICommentSnapshotFile.IRequest": {
          "type": "object",
          "properties": {
            "file_ids": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "Array of attachment file UUIDs to associate with the comment snapshot.\n\nReflects intended linkage/reordering/removal during partial update of the snapshot's file attachments. Must correspond to valid attachment_files records."
            },
            "sequences": {
              "type": "array",
              "items": {
                "type": "integer"
              },
              "description": "Optional mapping for the display order (sequence) of the files.\n\nAllows explicit reordering of file attachments for UI/UX accuracy; order must match file_ids array if included."
            }
          },
          "required": [
            "file_ids"
          ],
          "description": "Request body for partial update of attachment files for a comment snapshot (bbs_article_comment_snapshot_files).\n\nUsed to reorder, add, or remove associations, maintaining the correct sequence field per UI and evidence requirements."
        },
        "ICommentSnapshotFile.ISummary": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Primary key of the attachment file relationship (bbs_article_comment_snapshot_files.id).\n\nUnique identifier for the attachment mapping for audit and management."
            },
            "file": {
              "$ref": "#/components/schemas/IAttachmentFile",
              "description": "Metadata of the attached file at this sequence/relationship.\n\nLinks to the actual file resource in attachment_files, enabling metadata retrieval such as filename, extension, and URL."
            },
            "sequence": {
              "type": "integer",
              "description": "Display order (sequence) for the file in the comment snapshot.\n\nEnsures the intended order of files for the given revision. Sourced from the 'sequence' column of bbs_article_comment_snapshot_files."
            }
          },
          "required": [
            "id",
            "file",
            "sequence"
          ],
          "description": "Summary type for a file association in a comment snapshot (bbs_article_comment_snapshot_files), including file metadata and order.\n\nProvides ordering and audit fields for client-side rendering and review in revision history UIs."
        },
        "ICommentSnapshotFile.ICreate": {
          "type": "object",
          "properties": {
            "attachment_file_id": {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the file to be attached (attachment_files.id).\n\nReferences a pre-uploaded file for association with the comment snapshot mapping."
            },
            "sequence": {
              "type": "integer",
              "description": "Display order (sequence) for this file in the snapshot.\n\nRepresents the association's intended display order as seen by users."
            }
          },
          "required": [
            "attachment_file_id",
            "sequence"
          ],
          "description": "Request body for creating a new attached file record in a comment snapshot (bbs_article_comment_snapshot_files).\n\nSupplies file and sequence information to establish a new file association under the BBS comment revision evidence framework."
        },
        "ICommentSnapshotFile": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Primary key (ID) for the file association (bbs_article_comment_snapshot_files.id).\n\nUniquely identifies this mapping between comment snapshot and attachment file."
            },
            "bbs_article_comment_snapshot_id": {
              "type": "string",
              "format": "uuid",
              "description": "UUID indicating the snapshot this file is attached to (bbs_article_comment_snapshots.id).\n\nEstablishes relationship context for this attachment mapping."
            },
            "attachment_file_id": {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the attached file record (attachment_files.id).\n\nConnects association to the actual file record for download/display."
            },
            "sequence": {
              "type": "integer",
              "description": "The display order (sequence) in the snapshot list (bbs_article_comment_snapshot_files.sequence).\n\nUsed for rendering attached files in the correct order."
            },
            "file": {
              "$ref": "#/components/schemas/IAttachmentFile",
              "description": "File metadata for the associated file resource (attachment_files).\n\nEnables in-context display, download, and audit in UI clients."
            }
          },
          "required": [
            "id",
            "bbs_article_comment_snapshot_id",
            "attachment_file_id",
            "sequence"
          ],
          "description": "Attachment file association for comment snapshots (bbs_article_comment_snapshot_files).\n\nRepresents the evidentiary link between a snapshot version and an attachment file, with rich details and order management, referencing Prisma schema join structure."
        },
        "ICommentSnapshotFile.IUpdate": {
          "type": "object",
          "properties": {
            "sequence": {
              "type": "integer",
              "description": "Update the file's display order (sequence value) in the association record.\n\nDirectly alters the sequence column to reorder attachments."
            }
          },
          "required": [
            "sequence"
          ],
          "description": "Update model for an attachment file mapping (bbs_article_comment_snapshot_files) for a comment snapshot.\n\nPrimarily used for resequencing file attachments as per UI/UX needs; only sequence can be changed in evidence context."
        },
        "IAttachmentFile.IRequest": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "File name (without extension) to search/filter.\n\nCorresponds to the 'name' attribute in attachment_files; supports partial-matching, case-insensitive filters."
            },
            "extension": {
              "type": "string",
              "description": "File extension to search/filter (optional).\n\nChecks the 'extension' column in attachment_files; can be null or empty for extensionless files."
            },
            "created_at_min": {
              "type": "string",
              "format": "date-time",
              "description": "Minimum file creation time for filter (ISO 8601 format).\n\nMatches attachment_files.created_at greater or equal for time-based queries."
            },
            "created_at_max": {
              "type": "string",
              "format": "date-time",
              "description": "Maximum file creation time for filter (ISO 8601 format).\n\nMatches attachment_files.created_at less or equal for time-based queries."
            }
          },
          "required": [],
          "description": "Request body for searching/filtering attachment files (attachment_files).\n\nProvides a variety of fields for querying files for BBS management UI, per requirements."
        },
        "IPageIAttachmentFile": {
          "type": "object",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination",
              "description": "Pagination metadata for file list results.\n\nIncludes page number, limit, total records, and pages for UI and API usability."
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IAttachmentFile"
              },
              "description": "Attachment file data entries for this page of results.\n\nEach entry corresponds to a file metadata record defined in attachment_files."
            }
          },
          "required": [
            "pagination",
            "data"
          ],
          "description": "Paged result container for attachment file search results (attachment_files).\n\nFollows IPage<T> interface for consistency, referencing Prisma indexing and UI performance requirements."
        },
        "IAttachmentFile.ICreate": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "File name, without extension.\n\nAs per attachment_files.name; provides semantic name used for identifying files by users and clients."
            },
            "extension": {
              "type": "string",
              "description": "File extension (nullable).\n\nCorresponds to attachment_files.extension, allows for both normal and extensionless files (e.g., README).\nMay be null or omitted."
            },
            "url": {
              "type": "string",
              "description": "URL of the physical file resource.\n\nMatches attachment_files.url; must be a valid, accessible path or download location for this resource."
            }
          },
          "required": [
            "name",
            "url"
          ],
          "description": "Request body to create a new file record in the attachment_files table.\n\nAll fields necessary for building file metadata and supporting system evidence requirements."
        },
        "IAttachmentFile.IUpdate": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "New file name without extension.\n\nUpdates the attachment_files.name field for renamed assets."
            },
            "extension": {
              "type": "string",
              "description": "New or updated extension (nullable).\n\nModifies attachment_files.extension; supports cases like file format correction or metadata update."
            },
            "url": {
              "type": "string",
              "description": "New or corrected file URL.\n\nMay be used if the file has been re-uploaded or migrated to new storage."
            }
          },
          "required": [],
          "description": "Update model for editing attributes of an attachment file record (attachment_files).\n\nSupports correction and data hygiene activities by admins or automation systems."
        }
      }
    }
  },
  "files": {
    "/.env.local": "API_PORT=37001",
    "/.eslintrc.cjs": "module.exports = {\n  root: true,\n  plugins: [\"@typescript-eslint\", \"deprecation\"],\n  extends: [\"plugin:@typescript-eslint/recommended\"],\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    project: [\"tsconfig.json\", \"test/tsconfig.json\"],\n  },\n  overrides: [\n    {\n      files: [\"src/**/*.ts\", \"test/**/*.ts\"],\n      rules: {\n        \"@typescript-eslint/consistent-type-definitions\": \"off\",\n        \"@typescript-eslint/no-empty-function\": \"off\",\n        \"@typescript-eslint/no-empty-interface\": \"off\",\n        \"@typescript-eslint/no-explicit-any\": \"off\",\n        \"@typescript-eslint/no-inferrable-types\": \"off\",\n        \"@typescript-eslint/no-namespace\": \"off\",\n        \"@typescript-eslint/no-non-null-assertion\": \"off\",\n        \"@typescript-eslint/no-unused-vars\": \"off\",\n        \"@typescript-eslint/no-var-requires\": \"off\",\n        \"@typescript-eslint/no-floating-promises\": \"error\",\n        \"@typescript-eslint/no-require-imports\": \"off\",\n        \"@typescript-eslint/no-empty-object-type\": \"off\",\n      },\n    },\n  ],\n};\n",
    ".github/workflows/build.yml": "name: build\non:\n  pull_request:\n    paths:\n      - 'src/**'\n      - 'test/**'\n      - 'package.json'\njobs:\n  Ubuntu:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20.x\n      - uses: pnpm/action-setup@v4\n        with:\n          version: 8\n      \n      - name: Install Backend-Server\n        run: pnpm install\n\n      - name: Build Swagger\n        run: npm run build:swagger\n\n      - name: Build SDK\n        run: npm run build:sdk\n\n      - name: Compile Backend-Server\n        run: npm run build\n\n      - name: Run Test Program\n        run: npm run test -- --simultaneous 16\n\n      - name: EsLint\n        run: npm run eslint\n",
    ".github/workflows/typos.yml": "name: typos\non:\n  pull_request:\n\njobs:\n  typos:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Actions Repository\n        uses: actions/checkout@v4\n\n      - uses: crate-ci/typos@master\n        with:\n          config: ./typos.toml\n",
    "/.gitignore": ".git/\nbin/\ndist/\nlib/\nnode_modules/\npackages/api/lib/\n\n.env\npackage-lock.json\npnpm-lock.yaml",
    "/.prettierignore": "dist\nbin\nnode_modules\npackages\nsrc/api/functional\nsrc/api/utils/NestiaSimulator.ts\nREADME.md\ntsconfig.json",
    ".vscode/launch.json": "{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n  {\n    \"type\": \"node\",\n    \"request\": \"launch\",\n    \"name\": \"Backend Test\",\n    \"program\": \"${workspaceRoot}/test/index.ts\",\n    \"cwd\": \"${workspaceRoot}\",\n    \"args\": [\n      // //----\n      // // Not possible to reset DB in debugging mode\n      // //\n      // // Therefore, if you need DB reset, then do it \n      // // through `npm run reset-for-debugging` command\n      // //----\n      // \"--reset\", \"false\",\n      // \"--mode\", \"local\",\n      \n      //----\n      // You can run specific test functions\n      //\n      // If you want to include or exclude multiple words,\n      // then separate them with space character\n      //----\n      // \"--include\", \"some-words-to-include\",\n      // \"--exclude\", \"some-word another-word\",\n  ],\n    \"outFiles\": [\"${workspaceRoot}/bin/**/*.js\"],\n  }\n]\n}",
    ".vscode/settings.json": "{\n  \"editor.tabSize\": 2,\n  \"editor.formatOnSave\": true,\n  \"[javascript][typescript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n    \"editor.codeActionsOnSave\": {\n      \"source.fixAll.eslint\": \"explicit\"\n    },\n  }\n}",
    "/LICENSE": "MIT License\n\nCopyright (c) 2022 Jeongho Nam\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
    "/README.md": "# Nestia Template\n## Outline\n[![Build Status](https://github.com/samchon/nestia-start/workflows/build/badge.svg)](https://github.com/samchon/nestia-start/actions?query=workflow%3Abuild)\n\nA template repository for backend projects using [nestia](https://github.com/samchon/nestia).\n\nYou can create a new project from this boilerplate by running below command:\n\n```bash\nnpx nestia start <directory>\n```\n\nFor reference, this is a minimal boilerplate project concentrating only on [nestia](https://github.com/samchon/nestia) SDK generation. \n\nIf you wanna much detailed boilerplate project, visit [`@samchon/backend`](https://github.com/samchon/backend).\n\n\n\n\n## Directories and Files\nThis template project has categorized directories like below.\n\nAs you can see from the below, all of the Backend source files are placed into the [src](src/) directory. When you build the TypeScript source files, compiled files would be placed into the `lib` directory following the [tsconfig.json](tsconfig.json) configuration. Otherwise you build client [SDK](#32-sdk) library for npm publishing and their compiled files would be placed into the [packages](packages) directory.\n\n  - [packages/api/](packages/api): SDK module built by `npm run build:api`\n  - [src/](src): Backend source directory\n    - [src/api/](src/api/): Client SDK that would be published to the `@ORGANIZATION/PROJECT-api`\n      - [**src/api/functional/**](src/api/functional/): API functions generated by the [`nestia`](https://github.com/samchon/nestia)\n      - [**src/api/structures/**](src/api/structures/): DTO structures\n    - [src/controllers/](src/controllers/): Controller classes of the Main Program\n  - [**test/**](test): Test Automation Program\n  - [nestia.config.ts](nestia.config.ts): Configuration file of [`nestia`](https://github.com/samchon/nestia)\n  - [package.json](package.json): NPM configuration\n  - [tsconfig.json](tsconfig.json): TypeScript configuration for the main program\n\n\n\n\n## NPM Run Commands\nList of the run commands defined in the [package.json](package.json) are like below:\n\n  - Test\n    - **`test`**: Run test automation program\n    - `benchmark`: Run performance benchmark program\n  - Build\n    - `build`: Build everything\n    - `build:main`: Build main program (`src` directory)\n    - `build:test` Build test automation program (`test` directory)\n    - `build:sdk`: Build SDK into main program only\n    - `build:swagger`: Build Swagger Documents\n    - **`dev`**: Incremental build for development (test program)\n  - Deploy\n    - `package:api`: Build and deploy the SDK library to the NPM\n    - `start`: Start the backend server\n    - `start:dev`: Start the backend server with incremental build and reload\n  - Webpack\n    - `webpack`: Run webpack bundler\n    - `webpack:start`: Start the backend server built by webpack\n    - `webpack:test`: Run test program to the webpack built\n\n\n\n\n## Specialization\nTransform this template project to be yours.\n\nWhen you've created a new backend project through this template project, you can specialize it to be suitable for you by changing some words. Replace below words through IDE specific function like `Edit > Replace in Files` (*Ctrl + Shift + H*), who've been supported by the VSCode.\n\n| Before          | After\n|-----------------|----------------------------------------\n| ORGANIZATION | Your account or corporation name\n| PROJECT      | Your own project name\n| AUTHOR       | Author name\n| https://github.com/samchon/nestia-start | Your repository URL\n\n\n\n\n## Test Driven Development\nWith [nestia](https://github.com/samchon/nestia) helps to accomplish TDD (Test Driven Development). \n\nJust define DTOs and API controllers' methods (only declarations) first. After the definitions, and build SDK (Software Development Kit) through [nestia](https://github.com/samchon/nestia) (`npm run build:sdk`). After buildling those SDK, develop test automation program using the SDK, following use-case scenarios in the framework of client side.\n\nDuring the test automation program development, you can find that which API is miss-designed or which requirement analysis is not exact. Development of the main program must be the last step after such validation process during TDD.\n\n> Visit the [samchon/backend](https://github.com/samchon/backend), then you may find much detailed story about this TDD.\n>\n> 1. Definitions\n> 2. SDK\n> 3. Test Automation Program\n> 4. Main Program\n\n```typescript\nimport {\n  ArrayUtil,\n  GaffComparator,\n  RandomGenerator,\n  TestValidator,\n} from \"@nestia/e2e\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\n\nexport async function test_api_bbs_article_index_sort(\n  connection: api.IConnection,\n): Promise<void> {\n  // GENERATE 100 ARTICLES\n  const section: string = \"general\";\n  await ArrayUtil.asyncRepeat(100)(() =>\n    api.functional.bbs.articles.create(connection, section, {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(5)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [],\n      password: RandomGenerator.alphabets(8),\n    }),\n  );\n\n  // PREPARE VALIDATOR\n  const validator = TestValidator.sort(\"BbsArticleProvider.index()\")(async (\n    sort: IPage.Sort<IBbsArticle.IRequest.SortableColumns>,\n  ) => {\n    const page: IPage<IBbsArticle.ISummary> =\n      await api.functional.bbs.articles.index(connection, section, {\n        limit: 100,\n        sort,\n      });\n    return page.data;\n  });\n\n  // DO VALIDATE\n  const components = [\n    validator(\"created_at\")(GaffComparator.dates((x) => x.created_at)),\n    validator(\"updated_at\")(GaffComparator.dates((x) => x.updated_at)),\n    validator(\"title\")(GaffComparator.strings((x) => x.title)),\n    validator(\"writer\")(GaffComparator.strings((x) => x.writer)),\n    validator(\n      \"writer\",\n      \"title\",\n    )(GaffComparator.strings((x) => [x.writer, x.title])),\n  ];\n  for (const comp of components) {\n    await comp(\"+\", false);\n    await comp(\"-\", false);\n  }\n}\n```\n\nFor reference, if you run `npm run benchmark` command, your test functions defined in the [test/features/api](test/features/api) directory would be utilized for performance benchmarking. If you want to see the performance bench result earlier, visit below link please:\n\n  - [docs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md](https://github.com/samchon/nestia-start/blob/master/docs/benchmarks/AMD%20Ryzen%209%207940HS%20w%20Radeon%20780M%20Graphics.md)",
    "build/env.ts": "import fs from \"fs\";\n\nif (fs.existsSync(`${__dirname}/../.env`) === false)\n  fs.copyFileSync(`${__dirname}/../.env.local`, `${__dirname}/../.env`);\n",
    "docs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md": "# Benchmark Report\n> Generated by [`@nestia/benchmark`](https://github.com/samchon/nestia)\n\n  - Specifications\n    - CPU: AMD Ryzen 9 7940HS w/ Radeon 780M Graphics     \n    - RAM: 31 GB\n    - NodeJS Version: v20.10.0\n    - Backend Server: 1 core / 1 thread\n  - Arguments\n    - Count: 40,000\n    - Threads: 4\n    - Simultaneous: 32\n  - Time\n    - Start: 2024-10-29T19:14:35.941Z\n    - Complete: 2024-10-29T19:16:11.418Z\n    - Elapsed: 95,477 ms\n\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nTotal | 41,586 | 41,586 | 69.24 | 73.05 | 5 | 546\n\n> Unit: milliseconds\n\n## Memory Consumptions\n```mermaid\nxychart-beta\n  x-axis \"Time (second)\"\n  y-axis \"Memory (MB)\"\n  line \"Resident Set Size\" [122, 156, 159, 142, 154, 165, 184, 185, 187, 189, 200, 205, 209, 217, 221, 225, 229, 224, 230, 235, 242, 250, 256, 262, 267, 272, 234, 237, 249, 259, 266, 273, 285, 292, 291, 216, 225, 235, 243, 200, 208, 214, 186, 186, 171, 177, 187, 199, 185, 192, 205, 171, 180, 158, 170, 179, 163, 163, 176, 188, 193, 202, 213, 219, 230, 239, 256, 265, 283, 301, 240, 249, 257, 267, 284, 282, 290, 202, 213, 166, 178, 188, 200, 203, 208, 180, 191, 199, 175]\n  line \"Heap Total\" [85, 116, 120, 103, 114, 124, 146, 146, 147, 148, 158, 166, 170, 176, 180, 184, 187, 185, 190, 195, 203, 211, 217, 222, 225, 229, 194, 197, 209, 218, 225, 232, 241, 249, 247, 176, 185, 194, 202, 160, 168, 173, 146, 146, 130, 136, 146, 158, 145, 151, 165, 129, 139, 116, 128, 137, 120, 123, 136, 148, 152, 161, 172, 179, 189, 198, 215, 223, 241, 257, 200, 209, 216, 227, 244, 242, 249, 163, 174, 127, 136, 147, 159, 162, 166, 138, 150, 158, 132]\n  line \"Heap Used + External\" [69, 94, 62, 82, 88, 107, 71, 83, 93, 107, 136, 72, 76, 85, 92, 106, 139, 48, 68, 69, 86, 95, 108, 116, 140, 175, 67, 74, 88, 112, 125, 136, 142, 169, 180, 91, 104, 105, 121, 60, 71, 91, 64, 74, 86, 110, 121, 135, 76, 82, 103, 70, 93, 66, 91, 107, 76, 75, 95, 101, 115, 127, 136, 154, 165, 168, 196, 193, 214, 232, 84, 94, 101, 118, 145, 147, 149, 86, 96, 72, 90, 112, 126, 133, 132, 78, 87, 107, 88]\n  line \"Heap Used Only\" [66, 89, 59, 78, 83, 100, 68, 79, 88, 101, 129, 68, 72, 80, 86, 100, 131, 45, 64, 65, 81, 90, 103, 110, 133, 168, 64, 71, 84, 108, 120, 130, 136, 162, 173, 88, 100, 101, 117, 58, 68, 87, 61, 71, 83, 107, 118, 130, 73, 79, 99, 67, 89, 63, 88, 103, 74, 72, 91, 98, 111, 123, 132, 149, 160, 163, 190, 187, 208, 225, 81, 90, 97, 114, 140, 143, 145, 83, 93, 70, 87, 108, 122, 130, 128, 76, 84, 104, 85]\n```\n\n> - 🟦 Resident Set Size\n> - 🟢 Heap Total\n> - 🔴 Heap Used + External\n> - 🟡 Heap Used Only\n\n## Endpoints\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nPATCH /bbs/articles/:section | 6,439 | 6,439 | 108.37 | 76.56 | 6 | 546\nPUT /bbs/articles/:section/:id | 380 | 380 | 78.52 | 69.03 | 6 | 296\nGET /bbs/articles/:section/:id | 917 | 917 | 77.65 | 69.84 | 6 | 463\nDELETE /bbs/articles/:section/:id | 201 | 201 | 73.89 | 63.55 | 7 | 307\nPOST /bbs/articles/:section | 33,649 | 33,649 | 61.39 | 70.04 | 5 | 546\n\n> Unit: milliseconds\n\n## Failures\nMethod | Path | Count | Failures\n-------|------|-------|----------",
    "/nest-cli.json": "{\n  \"$schema\": \"https://json.schemastore.org/nest-cli\",\n  \"collection\": \"@nestjs/schematics\",\n  \"sourceRoot\": \"src\",\n  \"entryFile\": \"executable/server\",\n  \"compilerOptions\": {\n    \"deleteOutDir\": true\n  }\n}\n",
    "/nestia.config.ts": "// nestia configuration file\nimport type sdk from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyModule } from \"./src/MyModule\";\n\nconst NESTIA_CONFIG: sdk.INestiaConfig = {\n  input: () => NestFactory.create(MyModule),\n  output: \"src/api\",\n  swagger: {\n    output: \"packages/api/swagger.json\",\n    servers: [\n      {\n        url: \"http://localhost:37001\",\n        description: \"Local Server\",\n      },\n    ],\n    beautify: true,\n  },\n  distribute: \"packages/api\",\n  primitive: false,\n  simulate: true,\n};\nexport default NESTIA_CONFIG;\n",
    "/package.json": "{\n  \"private\": true,\n  \"name\": \"@ORGANIZATION/PROJECT\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Starter kit of Nestia\",\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"benchmark\": \"node bin/test/benchmark\",\n    \"test\": \"node bin/test\",\n    \"test:webpack\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------BUILDS------------------------\": \"\",\n    \"build\": \"npm run build:sdk && npm run build:main && npm run build:test\",\n    \"build:api\": \"rimraf packages/api/lib && nestia all && rimraf packages/api/lib && tsc -p packages/api/tsconfig.json && rollup -c packages/api/rollup.config.js\",\n    \"build:main\": \"rimraf lib && tsc\",\n    \"build:sdk\": \"rimraf src/api/functional && nestia sdk\",\n    \"build:swagger\": \"npx nestia swagger\",\n    \"build:test\": \"rimraf bin && tsc -p test/tsconfig.json\",\n    \"dev\": \"npm run build:test -- --watch\",\n    \"eslint\": \"eslint src && eslint test\",\n    \"eslint:fix\": \"eslint --fix src && eslint --fix test\",\n    \"prepare\": \"ts-patch install && ts-node build/env.ts\",\n    \"prettier\": \"prettier src --write && prettier test --write\",\n    \"------------------------WEBPACK------------------------\": \"\",\n    \"webpack\": \"rimraf dist && webpack\",\n    \"webpack:start\": \"cd dist && node dist/server\",\n    \"webpack:test\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------DEPLOYS------------------------\": \"\",\n    \"package:api\": \"npm run build:api && cd packages/api && npm publish\",\n    \"start\": \"node lib/executable/server\",\n    \"start:dev\": \"nest start --watch\",\n    \"start:swagger\": \"ts-node src/executable/swagger.ts\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia-start\"\n  },\n  \"keywords\": [\n    \"nestia\",\n    \"template\",\n    \"boilerplate\"\n  ],\n  \"author\": \"AUTHOR\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia-start/issues\"\n  },\n  \"homepage\": \"https://github.com/samchon/nestia-start#readme\",\n  \"devDependencies\": {\n    \"@nestia/benchmark\": \"^6.0.4\",\n    \"@nestia/e2e\": \"^6.0.4\",\n    \"@nestia/sdk\": \"^6.0.6\",\n    \"@nestjs/cli\": \"^11.0.7\",\n    \"@rollup/plugin-terser\": \"^0.4.4\",\n    \"@rollup/plugin-typescript\": \"^11.1.6\",\n    \"@trivago/prettier-plugin-sort-imports\": \"^4.3.0\",\n    \"@types/cli\": \"^0.11.21\",\n    \"@types/cli-progress\": \"^3.11.5\",\n    \"@types/express\": \"^4.17.21\",\n    \"@types/inquirer\": \"^8.2.5\",\n    \"@types/node\": \"^18.11.0\",\n    \"@types/uuid\": \"^8.3.4\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.1.0\",\n    \"@typescript-eslint/parser\": \"^8.1.0\",\n    \"chalk\": \"^4.1.2\",\n    \"cli\": \"^1.0.1\",\n    \"cli-progress\": \"^3.12.0\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"eslint-plugin-deprecation\": \"^3.0.0\",\n    \"express\": \"^4.18.2\",\n    \"nestia\": \"^7.0.0\",\n    \"prettier\": \"^3.2.4\",\n    \"prettier-plugin-prisma\": \"^5.0.0\",\n    \"rimraf\": \"^3.0.2\",\n    \"rollup\": \"^4.18.0\",\n    \"source-map-support\": \"^0.5.21\",\n    \"swagger-ui-express\": \"^5.0.0\",\n    \"ts-loader\": \"^9.5.1\",\n    \"ts-node\": \"^10.9.1\",\n    \"ts-patch\": \"^3.3.0\",\n    \"typescript\": \"~5.8.3\",\n    \"typescript-transform-paths\": \"^3.5.5\",\n    \"webpack\": \"^5.89.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"write-file-webpack-plugin\": \"^4.5.1\"\n  },\n  \"dependencies\": {\n    \"@nestia/core\": \"^6.0.6\",\n    \"@nestia/fetcher\": \"^6.0.6\",\n    \"@nestjs/common\": \"^11.1.1\",\n    \"@nestjs/core\": \"^11.1.1\",\n    \"@nestjs/platform-express\": \"^11.1.1\",\n    \"commander\": \"10.0.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"dotenv-expand\": \"^10.0.0\",\n    \"inquirer\": \"8.2.5\",\n    \"serialize-error\": \"^4.1.0\",\n    \"tgrid\": \"^1.1.0\",\n    \"tstl\": \"^3.0.0\",\n    \"typia\": \"^9.3.1\",\n    \"uuid\": \"^9.0.0\"\n  },\n  \"stackblitz\": {\n    \"startCommand\": \"npm run prepare && npm run build:test && npm run test -- --simultaneous 1\"\n  }\n}",
    "packages/api/.gitignore": "lib/\nnode_modules/\n\nswagger.json\nopenai.json",
    "packages/api/LICENSE": "MIT License\n\nCopyright (c) 2021 ORGANIZATION\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
    "packages/api/README.md": "# SDK Library\nThis is a SDK library generated by [`nestia`](https://nestia.io).\n\nWith this SDK library, you can easily and safely interact with backend server.\n\nJust import and call some API functions like gif image below:\n\n![nestia-sdk-demo](https://user-images.githubusercontent.com/13158709/215004990-368c589d-7101-404e-b81b-fbc936382f05.gif)\n\n> Left is server code, and right is client code utilizing the SDK\n\n\n\n\n# What [`Nestia`](https://nestia.io) is:\n![Nestia Logo](https://nestia.io/logo.png)\n\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/samchon/nestia/blob/master/LICENSE)\n[![npm version](https://img.shields.io/npm/v/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Downloads](https://img.shields.io/npm/dm/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Build Status](https://github.com/samchon/nestia/workflows/build/badge.svg)](https://github.com/samchon/nestia/actions?query=workflow%3Abuild)\n[![Guide Documents](https://img.shields.io/badge/guide-documents-forestgreen)](https://nestia.io/docs/)\n\nNestia is a set of helper libraries for NestJS, supporting below features:\n\n  - `@nestia/core`: super-fast decorators\n  - `@nestia/sdk`:\n    - Swagger generator evolved than ever\n    - SDK library generator for clients\n    - Mockup Simulator for client applications\n    - Automatic E2E test functions generator\n  - `@nestia/migrate`: migration from Swagger to NestJS\n  - `nestia`: just CLI (command line interface) tool\n\n> **Note**\n> \n> - **Only one line** required, with pure TypeScript type\n> - Enhance performance **30x** up\n>   - Runtime validator is **20,000x faster** than `class-validator`\n>   - JSON serialization is **200x faster** than `class-transformer`\n> - Software Development Kit\n>   - SDK is a collection of `fetch` functions with type definitions like [tRPC](https://trpc.io/)\n>   - Mockup simulator means embedded backend simulator in SDK\n>     - similar with [msw](https://mswjs.io/), but fully automated",
    "packages/api/package.json": "{\n  \"name\": \"@ORGANIZATION/PROJECT-api\",\n  \"version\": \"0.1.0\",\n  \"description\": \"SDK library generated by Nestia\",\n  \"main\": \"lib/index.js\",\n  \"module\": \"lib/index.mjs\",\n  \"typings\": \"lib/index.d.ts\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia\"\n  },\n  \"author\": \"Jeongho Nam\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia/issues\"\n  },\n  \"homepage\": \"https://nestia.io\",\n  \"files\": [\n    \"lib\",\n    \"package.json\",\n    \"swagger.json\",\n    \"openai.json\",\n    \"README.md\"\n  ],\n  \"dependencies\": {\n    \"@nestia/fetcher\": \"^6.0.6\",\n    \"tgrid\": \"^1.1.0\",\n    \"typia\": \"^9.3.1\"\n  }\n}",
    "packages/api/rollup.config.js": "const typescript = require(\"@rollup/plugin-typescript\");\nconst terser = require(\"@rollup/plugin-terser\");\n\nmodule.exports = {\n  input: `${__dirname}/../../src/api/index.ts`,\n  output: {\n    dir: `${__dirname}/lib`,\n    format: \"esm\",\n    entryFileNames: \"[name].mjs\",\n    sourcemap: true,\n  },\n  plugins: [\n    typescript({\n      tsconfig: `${__dirname}/tsconfig.json`,\n      module: \"ESNext\",\n      target: \"ESNext\",\n    }),\n    terser({\n      format: {\n        comments: \"some\",\n        beautify: true,\n        ecma: \"2020\",\n      },\n      compress: false,\n      mangle: false,\n      module: true,\n    }),\n  ],\n};\n",
    "packages/api/tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n    /* Language and Environment */\n    \"target\": \"ES5\", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    \"lib\": [\n      \"DOM\",\n      \"ES2015\"\n    ], /* Specify a set of bundled library declaration files that describe the target runtime environment. */// \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    // \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    // \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n    /* Modules */\n    \"module\": \"commonjs\", /* Specify what module code is generated. */// \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    // \"paths\": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n    /* Emit */\n    \"declaration\": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */// \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true, /* Create source map files for emitted JavaScript files. */// \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\", /* Specify an output folder for all emitted files. */// \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    \"downlevelIteration\": true, /* Emit more compliant, but verbose and less performant JavaScript for iteration. */// \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\", /* Set the newline character for emitting files. */// \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */// \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true, /* Ensure that casing is correct in imports. *//* Type Checking */\n    \"strict\": true, /* Enable all strict type-checking options. */// \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    // \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    // \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    // \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    // \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true, /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\"\n      }\n    ],\n    \"strictNullChecks\": true\n  },\n  \"include\": [\n    \"../../src/api\"\n  ]\n}",
    "/prettier.config.js": "module.exports = {\n  // DEFAULT CONFIGURATIONS\n  parser: \"typescript\",\n  printWidth: 80,\n  semi: true,\n  tabWidth: 2,\n  trailingComma: \"all\",\n\n  // PLUG-IN CONFIGURATIONS\n  plugins: [\"@trivago/prettier-plugin-sort-imports\"],\n  importOrder: [\n    \"<THIRD_PARTY_MODULES>\",\n    \"^@ORGANIZATION/PROJECT-api(.*)$\",\n    \"^[./]\",\n  ],\n  importOrderSeparation: true,\n  importOrderSortSpecifiers: true,\n  importOrderParserPlugins: [\"decorators-legacy\", \"typescript\"],\n};\n",
    "src/MyBackend.ts": "import { WebSocketAdaptor } from \"@nestia/core\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyConfiguration } from \"./MyConfiguration\";\nimport { MyModule } from \"./MyModule\";\n\nexport class MyBackend {\n  private application_?: INestApplication;\n\n  public async open(): Promise<void> {\n    //----\n    // OPEN THE BACKEND SERVER\n    //----\n    // MOUNT CONTROLLERS\n    this.application_ = await NestFactory.create(MyModule, { logger: false });\n    await WebSocketAdaptor.upgrade(this.application_);\n\n    // DO OPEN\n    this.application_.enableCors();\n    await this.application_.listen(MyConfiguration.API_PORT(), \"0.0.0.0\");\n\n    //----\n    // POST-PROCESSES\n    //----\n    // INFORM TO THE PM2\n    if (process.send) process.send(\"ready\");\n\n    // WHEN KILL COMMAND COMES\n    process.on(\"SIGINT\", async () => {\n      await this.close();\n      process.exit(0);\n    });\n  }\n\n  public async close(): Promise<void> {\n    if (this.application_ === undefined) return;\n\n    // DO CLOSE\n    await this.application_.close();\n    delete this.application_;\n  }\n}\n",
    "src/MyConfiguration.ts": "import fs from \"fs\";\nimport path from \"path\";\n\nimport { MyGlobal } from \"./MyGlobal\";\n\nexport namespace MyConfiguration {\n  export const API_PORT = () => Number(MyGlobal.env.API_PORT);\n\n  export const ROOT = (() => {\n    const split: string[] = __dirname.split(path.sep);\n    return split.at(-1) === \"src\" && split.at(-2) === \"bin\"\n      ? path.resolve(__dirname + \"/../..\")\n      : fs.existsSync(__dirname + \"/.env\")\n        ? __dirname\n        : path.resolve(__dirname + \"/..\");\n  })();\n}\n",
    "src/MyGlobal.ts": "import dotenv from \"dotenv\";\nimport dotenvExpand from \"dotenv-expand\";\nimport { Singleton } from \"tstl\";\nimport typia from \"typia\";\n\n/* eslint-disable */\nexport class MyGlobal {\n  public static testing: boolean = false;\n  public static get env(): MyGlobal.IEnvironments {\n    return environments.get();\n  }\n}\nexport namespace MyGlobal {\n  export interface IEnvironments {\n    API_PORT: `${number}`;\n  }\n}\n\nconst environments = new Singleton(() => {\n  const env = dotenv.config();\n  dotenvExpand.expand(env);\n  return typia.assert<MyGlobal.IEnvironments>(process.env);\n});\n",
    "src/api/HttpError.ts": "export { HttpError } from \"@nestia/fetcher\";\n",
    "src/api/IConnection.ts": "export type { IConnection } from \"@nestia/fetcher\";\n",
    "src/api/Primitive.ts": "export type { Primitive } from \"typia\";\n",
    "src/api/Resolved.ts": "export type { Resolved } from \"typia\";\n",
    "src/api/index.ts": "import * as api from \"./module\";\n\nexport * from \"./module\";\nexport default api;\n",
    "src/api/module.ts": "export type * from \"./IConnection\";\nexport * from \"./HttpError\";\n\nexport * as functional from \"./functional\";\n",
    "src/executable/server.ts": "import { MyBackend } from \"../MyBackend\";\n\nconst EXTENSION = __filename.substring(__filename.length - 2);\nif (EXTENSION === \"js\") require(\"source-map-support/register\");\n\nasync function main(): Promise<void> {\n  // BACKEND SEVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // UNEXPECTED ERRORS\n  global.process.on(\"uncaughtException\", console.error);\n  global.process.on(\"unhandledRejection\", console.error);\n}\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
    "src/executable/swagger.ts": "import cp from \"child_process\";\nimport express from \"express\";\n\nconst execute = (command: string): void => {\n  console.log(`\\n$ ${command}\\n`);\n  cp.execSync(command, { stdio: \"inherit\" });\n};\n\nconst main = async (): Promise<void> => {\n  if (!process.argv.some((str) => str === \"--skipBuild\"))\n    execute(\"npm run build:swagger\");\n\n  const docs = await import(\"../../packages/api/swagger.json\" as any);\n\n  const app = express();\n  const swaggerUi = require(\"swagger-ui-express\");\n  app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(docs));\n  app.listen(37810);\n\n  console.log(\"\\n\");\n  console.log(\"-----------------------------------------------------------\");\n  console.log(\"\\n Swagger UI Address: http://127.0.0.1:37810/api-docs \\n\");\n  console.log(\"-----------------------------------------------------------\");\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
    "src/utils/ErrorUtil.ts": "import serializeError = require(\"serialize-error\");\n\nexport namespace ErrorUtil {\n  export const toJSON = (err: any): object =>\n    err instanceof Object && err.toJSON instanceof Function\n      ? err.toJSON()\n      : serializeError(err);\n}\n",
    "src/utils/MapUtil.ts": "export namespace MapUtil {\n  export function take<Key, T>(\n    dict: Map<Key, T>,\n    key: Key,\n    generator: () => T,\n  ): T {\n    const oldbie: T | undefined = dict.get(key);\n    if (oldbie) return oldbie;\n\n    const value: T = generator();\n    dict.set(key, value);\n    return value;\n  }\n}\n",
    "test/TestAutomation.ts": "import { DynamicExecutor } from \"@nestia/e2e\";\nimport chalk from \"chalk\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport api from \"../src/api\";\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\n\nexport namespace TestAutomation {\n  export interface IProps<T> {\n    open(options: IOptions): Promise<T>;\n    close(backend: T): Promise<void>;\n  }\n\n  export interface IOptions {\n    simultaneous: number;\n    include?: string[];\n    exclude?: string[];\n  }\n\n  export const execute = async <T,>(props: IProps<T>): Promise<void> => {\n    // OPEN BACKEND\n    const options: IOptions = await getOptions();\n    const backend: T = await props.open(options);\n\n    // DO TEST\n    const connection: api.IConnection = {\n      host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n    };\n    const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\n      prefix: \"test\",\n      location: __dirname + \"/features\",\n      parameters: () => [\n        {\n          host: connection.host,\n          encryption: connection.encryption,\n        },\n      ],\n      filter: (func) =>\n        (!options.include?.length ||\n          (options.include ?? []).some((str) => func.includes(str))) &&\n        (!options.exclude?.length ||\n          (options.exclude ?? []).every((str) => !func.includes(str))),\n      onComplete: (exec) => {\n        const trace = (str: string) =>\n          console.log(`  - ${chalk.green(exec.name)}: ${str}`);\n        if (exec.error === null) {\n          const elapsed: number =\n            new Date(exec.completed_at).getTime() -\n            new Date(exec.started_at).getTime();\n          trace(`${chalk.yellow(elapsed.toLocaleString())} ms`);\n        } else trace(chalk.red(exec.error.name));\n      },\n      simultaneous: options.simultaneous,\n    });\n\n    // TERMINATE - WAIT FOR BACKGROUND EVENTS\n    await sleep_for(2500);\n    await props.close(backend);\n\n    const failures: DynamicExecutor.IExecution[] = report.executions.filter(\n      (exec) => exec.error !== null,\n    );\n    if (failures.length === 0) {\n      console.log(\"Success\");\n      console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n    } else {\n      for (const f of failures) console.log(f.error);\n      process.exit(-1);\n    }\n\n    console.log(\n      [\n        `All: #${report.executions.length}`,\n        `Success: #${report.executions.length - failures.length}`,\n        `Failed: #${failures.length}`,\n      ].join(\"\\n\"),\n    );\n  };\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<TestAutomation.IOptions>(\n    async (command, prompt, action) => {\n      command.option(\n        \"--simultaneous <number>\",\n        \"number of simultaneous requests\",\n      );\n      command.option(\"--include <string...>\", \"include feature files\");\n      command.option(\"--exclude <string...>\", \"exclude feature files\");\n\n      return action(async (options) => {\n        options.simultaneous = Number(\n          options.simultaneous ??\n            (await prompt.number(\"simultaneous\")(\n              \"Number of simultaneous requests to make\",\n            )),\n        );\n        if (isNaN(options.simultaneous) || options.simultaneous <= 0)\n          options.simultaneous = 1;\n        return options as TestAutomation.IOptions;\n      });\n    },\n  );\n",
    "test/benchmark/index.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\nimport cliProgress from \"cli-progress\";\nimport fs from \"fs\";\nimport os from \"os\";\nimport { IPointer } from \"tstl\";\n\nimport { MyBackend } from \"../../src/MyBackend\";\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\nimport { MyGlobal } from \"../../src/MyGlobal\";\nimport { ArgumentParser } from \"../helpers/ArgumentParser\";\n\ninterface IOptions {\n  include?: string[];\n  exclude?: string[];\n  count: number;\n  threads: number;\n  simultaneous: number;\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<IOptions>(async (command, prompt, action) => {\n    // command.option(\"--mode <string>\", \"target mode\");\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\n    command.option(\"--include <string...>\", \"include feature files\");\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\n    command.option(\"--count <number>\", \"number of requests to make\");\n    command.option(\"--threads <number>\", \"number of threads to use\");\n    command.option(\n      \"--simultaneous <number>\",\n      \"number of simultaneous requests to make\",\n    );\n    return action(async (options) => {\n      // if (typeof options.reset === \"string\")\n      //     options.reset = options.reset === \"true\";\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\n      //     \"LOCAL\",\n      //     \"DEV\",\n      //     \"REAL\",\n      // ]);\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\n      options.count = Number(\n        options.count ??\n          (await prompt.number(\"count\")(\"Number of requests to make\")),\n      );\n      options.threads = Number(\n        options.threads ??\n          (await prompt.number(\"threads\")(\"Number of threads to use\")),\n      );\n      options.simultaneous = Number(\n        options.simultaneous ??\n          (await prompt.number(\"simultaneous\")(\n            \"Number of simultaneous requests to make\",\n          )),\n      );\n      return options as IOptions;\n    });\n  });\n\nconst main = async (): Promise<void> => {\n  // CONFIGURATIONS\n  const options: IOptions = await getOptions();\n  MyGlobal.testing = true;\n\n  // BACKEND SERVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // DO BENCHMARK\n  const prev: IPointer<number> = { value: 0 };\n  const bar: cliProgress.SingleBar = new cliProgress.SingleBar(\n    {},\n    cliProgress.Presets.shades_classic,\n  );\n  bar.start(options.count, 0);\n\n  const report: DynamicBenchmarker.IReport = await DynamicBenchmarker.master({\n    servant: `${__dirname}/servant.js`,\n    count: options.count,\n    threads: options.threads,\n    simultaneous: options.simultaneous,\n    filter: (func) =>\n      (!options.include?.length ||\n        (options.include ?? []).some((str) => func.includes(str))) &&\n      (!options.exclude?.length ||\n        (options.exclude ?? []).every((str) => !func.includes(str))),\n    progress: (value: number) => {\n      if (value >= 100 + prev.value) {\n        bar.update(value);\n        prev.value = value;\n      }\n    },\n    stdio: \"ignore\",\n  });\n  bar.stop();\n\n  // DOCUMENTATION\n  try {\n    await fs.promises.mkdir(`${MyConfiguration.ROOT}/docs/benchmarks`, {\n      recursive: true,\n    });\n  } catch {}\n  await fs.promises.writeFile(\n    `${MyConfiguration.ROOT}/docs/benchmarks/${os\n      .cpus()[0]\n      .model.trim()\n      .split(\"\\\\\")\n      .join(\"\")\n      .split(\"/\")\n      .join(\"\")}.md`,\n    DynamicBenchmarker.markdown(report),\n    \"utf8\",\n  );\n\n  // CLOSE\n  await backend.close();\n};\nmain().catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
    "test/benchmark/servant.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\n\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\n\nDynamicBenchmarker.servant({\n  connection: {\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n  },\n  location: `${__dirname}/../features`,\n  parameters: (connection) => [connection],\n  prefix: \"test_api_\",\n}).catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
    "test/helpers/ArgumentParser.ts": "import commander from \"commander\";\nimport * as inquirer from \"inquirer\";\n\nexport namespace ArgumentParser {\n  export type Inquiry<T> = (\n    command: commander.Command,\n    prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule,\n    action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n  ) => Promise<T>;\n\n  export interface Prompt {\n    select: (\n      name: string,\n    ) => (\n      message: string,\n    ) => <Choice extends string>(choices: Choice[]) => Promise<Choice>;\n    boolean: (name: string) => (message: string) => Promise<boolean>;\n    number: (name: string) => (message: string) => Promise<number>;\n  }\n\n  export const parse = async <T,>(\n    inquiry: (\n      command: commander.Command,\n      prompt: Prompt,\n      action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n    ) => Promise<T>,\n  ): Promise<T> => {\n    // TAKE OPTIONS\n    const action = (closure: (options: Partial<T>) => Promise<T>) =>\n      new Promise<T>((resolve, reject) => {\n        commander.program.action(async (options) => {\n          try {\n            resolve(await closure(options));\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n        commander.program.parseAsync().catch(reject);\n      });\n\n    const select =\n      (name: string) =>\n      (message: string) =>\n      async <Choice extends string>(choices: Choice[]): Promise<Choice> =>\n        (\n          await inquirer.createPromptModule()({\n            type: \"list\",\n            name,\n            message,\n            choices,\n          })\n        )[name];\n    const boolean = (name: string) => async (message: string) =>\n      (\n        await inquirer.createPromptModule()({\n          type: \"confirm\",\n          name,\n          message,\n        })\n      )[name] as boolean;\n    const number = (name: string) => async (message: string) =>\n      Number(\n        (\n          await inquirer.createPromptModule()({\n            type: \"number\",\n            name,\n            message,\n          })\n        )[name],\n      );\n\n    const output: T | Error = await (async () => {\n      try {\n        return await inquiry(\n          commander.program,\n          { select, boolean, number },\n          action,\n        );\n      } catch (error) {\n        return error as Error;\n      }\n    })();\n\n    // RETURNS\n    if (output instanceof Error) throw output;\n    return output;\n  };\n}\n",
    "test/index.ts": "import { MyBackend } from \"../src/MyBackend\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: MyBackend = new MyBackend();\n      await backend.open();\n      return backend;\n    },\n    close: (backend) => backend.close(),\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
    "test/tsconfig.json": "{\n  \"extends\": \"../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"../bin\",\n  },\n  \"include\": [\".\", \"../src\"]\n}",
    "test/webpack.ts": "import cp from \"child_process\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst wait = async (): Promise<void> => {\n  while (true)\n    try {\n      await fetch(`http://localhost:${MyConfiguration.API_PORT()}/dsafdsafsd`);\n      return;\n    } catch (exp) {\n      await sleep_for(100);\n    }\n};\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: cp.ChildProcess = cp.fork(\n        `${MyConfiguration.ROOT}/dist/server.js`,\n        {\n          cwd: `${MyConfiguration.ROOT}/dist`,\n        },\n      );\n      await wait();\n      return backend;\n    },\n    close: async (backend) => {\n      backend.kill();\n    },\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
    "/tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n\n    /* Language and Environment */\n    \"target\": \"ES2015\",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    // \"lib\": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */\n    // \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n\n    /* Modules */\n    \"module\": \"commonjs\",                                /* Specify what module code is generated. */\n    // \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    \"paths\": {\n      \"@ORGANIZATION/PROJECT-api/lib/*\": [\"./src/api/*\"],\n      \"@ORGANIZATION/PROJECT-api\": [\"./src/api\"],\n    },                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n\n    /* Emit */\n    // \"declaration\": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */\n    // \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true,                                /* Create source map files for emitted JavaScript files. */\n    // \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\",                                   /* Specify an output folder for all emitted files. */\n    // \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    // \"downlevelIteration\": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */\n    // \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\",                                /* Set the newline character for emitting files. */\n    \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */\n    // \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true,            /* Ensure that casing is correct in imports. */\n\n    /* Type Checking */\n    \"strict\": true,                                      /* Enable all strict type-checking options. */\n    // \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true,                                 /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      { \"transform\": \"typescript-transform-paths\" },\n      { \"transform\": \"typia/lib/transform\" },\n      { \n        \"transform\": \"@nestia/core/lib/transform\",\n        /**\n         * Validate request body.\n         * \n         *   - \"assert\": Use typia.assert() function\n         *   - \"is\": Use typia.is() function\n         *   - \"validate\": Use typia.validate() function\n         *   - \"assertEquals\": Use typia.assertEquals() function\n         *   - \"equals\": Use typia.equals() function\n         *   - \"validateEquals\": Use typia.validateEquals() function\n         */\n        \"validate\": \"validate\",\n        /**\n         * Validate JSON typed response body.\n         * \n         *   - \"assert\": Use typia.assertStringify() function\n         *   - \"is\": Use typia.isStringify() function\n         *   - \"validate\": Use typia.validateStringify() function\n         *   - \"validate.log\": typia.validateStringify(), but do not throw and just log it\n         *   - \"stringify\": Use typia.stringify() function, but dangerous\n         *   - null: Just use JSON.stringify() function, without boosting\n         */\n        \"stringify\": \"assert\",\n      },\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"packages\",\n  ]\n}\n",
    "/typos.toml": "[default]\nlocale = 'en-us'\nextend-ignore-re = [\n  \"(?Rm)^.*(<!--|#|//)\\\\s*spellchecker:disable-line(-->|\\n)?$\",\n  \"(?s)(<!--|#|//)\\\\s*spellchecker:off\\\\s*(-->|\\n).*?(<!--|#|//)\\\\s*spellchecker:on\",\n]\n\n[default.extend-words]\nJeongho = \"Jeongho\"\nNam = \"Nam\"\ntypia = \"typia\"\n\n[files]\nextend-exclude = [\"*.json\"]",
    "/webpack.config.js": "const path = require(\"path\");\n\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\nconst WriteFilePlugin = require(\"write-file-webpack-plugin\");\nconst { IgnorePlugin } = require(\"webpack\");\n\nconst lazyImports = [\n  \"@fastify/static\",\n  \"@fastify/view\",\n  \"@nestjs/microservices\",\n  \"@nestjs/websockets\",\n  \"class-transformer\",\n  \"class-validator\",\n];\n\n// @reference https://tech-blog.s-yoshiki.com/entry/297\nmodule.exports = {\n  // CUSTOMIZE HERE\n  entry: {\n    server: \"./src/executable/server.ts\",\n  },\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"[name].js\",\n  },\n  optimization: {\n    minimize: true,\n  },\n\n  // JUST KEEP THEM\n  mode: \"production\",\n  target: \"node\",\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        loader: \"ts-loader\",\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".js\"],\n  },\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: \".env\",\n          to: \"[name][ext]\",\n        },\n        // {\n        //   from: \"./node_modules/.prisma/client/*.node\",\n        //   to: () => Promise.resolve(\"[path][name][ext]\"),\n        //   globOptions: {\n        //     dot: true,\n        //   },\n        // },\n      ],\n    }),\n    new WriteFilePlugin(),\n    new IgnorePlugin({\n      checkResource: (resource) => {\n        if (lazyImports.some((modulo) => resource.startsWith(modulo))) {\n          try {\n            require.resolve(resource);\n          } catch (err) {\n            return true;\n          }\n        }\n        return false;\n      },\n    }),\n  ],\n};\n",
    "src/MyModule.ts": "import { Module } from \"@nestjs/common\";\n\nimport { BbsArticlesController } from \"./controllers/bbs/articles/BbsArticlesController\";\nimport { BbsArticlesSnapshotsController } from \"./controllers/bbs/articles/snapshots/BbsArticlesSnapshotsController\";\nimport { BbsArticlesSnapshotsFilesController } from \"./controllers/bbs/articles/snapshots/files/BbsArticlesSnapshotsFilesController\";\nimport { BbsArticlesCommentsController } from \"./controllers/bbs/articles/comments/BbsArticlesCommentsController\";\nimport { BbsArticlesCommentsSnapshotsController } from \"./controllers/bbs/articles/comments/snapshots/BbsArticlesCommentsSnapshotsController\";\nimport { BbsArticlesCommentsSnapshotsFilesController } from \"./controllers/bbs/articles/comments/snapshots/files/BbsArticlesCommentsSnapshotsFilesController\";\nimport { AttachmentfilesController } from \"./controllers/attachmentFiles/AttachmentfilesController\";\n\n@Module({\n  controllers: [\n    BbsArticlesController,\n    BbsArticlesSnapshotsController,\n    BbsArticlesSnapshotsFilesController,\n    BbsArticlesCommentsController,\n    BbsArticlesCommentsSnapshotsController,\n    BbsArticlesCommentsSnapshotsFilesController,\n    AttachmentfilesController,\n  ],\n})\nexport class MyModule {}\n",
    "src/controllers/bbs/articles/BbsArticlesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"../../../api/structures/IBbsArticle\";\nimport { IPageIBbsArticle } from \"../../../api/structures/IPageIBbsArticle\";\n\n@Controller(\"/bbs/articles\")\nexport class BbsArticlesController {\n  /**\n   * Create a new BBS article with initial snapshot and attachments (related\n   * to 'bbs_articles' table).\n   *\n   * This API creates a new article in the 'bbs_articles' table with all\n   * required fields, such as writer name, password (secure/encrypted), and\n   * creation time. The body and title are stored in the initial record in\n   * 'bbs_article_snapshots', while attached files are related via\n   * 'bbs_article_snapshot_files'.\n   *\n   * Upon success, a new article is created with its first snapshot and\n   * attachments, and all references are established. Security: password will\n   * be encrypted in storage. Ensure all fields follow validations in the DB\n   * schema, such as non-empty strings for essential fields, proper format for\n   * UUIDs, and file URL validation. The operation is atomic—all-or-nothing if\n   * file/attachment data is invalid.\n   *\n   * Related: PATCH /bbs/articles for article listing and GET\n   * /bbs/articles/{id} for detail view.\n   *\n   * @param body New article's information, including writer, password,\n   *   body/title, format, and attachments.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IBbsArticle.ICreate,\n  ): Promise<IBbsArticle> {\n    body;\n    return typia.random<IBbsArticle>();\n  }\n\n  /**\n   * Retrieve a list of BBS articles ('bbs_articles' table) with filtering,\n   * search, and pagination.\n   *\n   * This API retrieves a paginated and filtered list of articles from the\n   * 'bbs_articles' table. The endpoint should support standard search fields,\n   * such as title, writer, or date range, reflecting the need for efficient\n   * querying and performance optimization as outlined in the requirements.\n   *\n   * The response includes only the latest snapshot information (title, etc.)\n   * and not the complete snapshot history for each article, consistent with\n   * index usage and list performance needs. Security considerations include\n   * returning only non-deleted articles to general users; deleted articles\n   * may be included for admins based on role.\n   *\n   * Related operations: GET /bbs/articles/{id} for detail view, PATCH\n   * /bbs/articles/{articleId}/snapshots for snapshots list, and CRUD\n   * operations for creation, update, and deletion. Consider error handling\n   * for invalid queries and paging boundaries.\n   *\n   * @param body Search criteria, filtering, sorting, and pagination for\n   *   retrieving article list.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IBbsArticle.IRequest,\n  ): Promise<IPageIBbsArticle.ISummary> {\n    body;\n    return typia.random<IPageIBbsArticle.ISummary>();\n  }\n\n  /**\n   * Get detail information of a specific BBS article ('bbs_articles' table),\n   * including latest snapshot and attachments.\n   *\n   * This API provides detail for a single article from the 'bbs_articles'\n   * table, identified by its UUID. Main output fields are writer,\n   * creation/deletion time, the latest snapshot's title/body/format, and\n   * summary of attachments and comments.\n   *\n   * Validation includes ensuring the article exists and is not deleted (for\n   * general users), with soft-deleted articles only visible for admins/staff.\n   * Response incorporates summarized comment count, facilitating user\n   * interface efficiency. Error handling covers 'not found' and forbidden\n   * access on deleted items.\n   *\n   * Related: PATCH /bbs/articles for lists, PATCH\n   * /bbs/articles/{articleId}/snapshots for modification history.\n   *\n   * @param id UUID of the BBS article to retrieve.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticle> {\n    id;\n    return typia.random<IBbsArticle>();\n  }\n\n  /**\n   * Update a specific BBS article ('bbs_articles' table); creates a new\n   * snapshot with attachments.\n   *\n   * This API modifies an existing BBS article. Upon update, password is\n   * verified then a new snapshot is inserted in 'bbs_article_snapshots',\n   * containing the revised title/body/format and new/updated attachments\n   * listed via 'bbs_article_snapshot_files'.\n   *\n   * The original article's record in 'bbs_articles' is not overwritten; only\n   * new snapshot/attachments are created to preserve evidence, as per\n   * requirements. Security: password verification is strict, and all updates\n   * are timestamped. All DB constraints and validation are applied (e.g.,\n   * title, body not empty).\n   *\n   * Error cases include unauthorized access, not found, or validation\n   * failures. The operation is atomic—either the snapshot and all attachments\n   * are created, or none are.\n   *\n   * @param id UUID of the article to update.\n   * @param body Updated article content, verified via password, with\n   *   attachments list.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticle.IUpdate,\n  ): Promise<IBbsArticle> {\n    id;\n    body;\n    return typia.random<IBbsArticle>();\n  }\n\n  /**\n   * Soft-delete a specific article ('bbs_articles' table); sets 'deleted_at',\n   * preserves evidence.\n   *\n   * This API marks an article as logically deleted (soft delete) by setting\n   * the 'deleted_at' timestamp, per requirements. The request must provide\n   * password verification.\n   *\n   * The operation does not alter existing snapshot or attachment file\n   * records, preserving all evidence. Soft-deleted articles are hidden from\n   * non-admin users. Security: password must match and be securely provided;\n   * deleted articles remain retrievable by admins for audits if needed.\n   *\n   * Error scenarios: unauthorized/deletion of already deleted, or article not\n   * found. Proper error is returned (e.g., forbidden, not found).\n   *\n   * @param id UUID of the article to delete.\n   * @param body Password for verification prior to soft-deletion.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticle.IDelete,\n  ): Promise<IBbsArticle> {\n    id;\n    body;\n    return typia.random<IBbsArticle>();\n  }\n}\n",
    "src/controllers/bbs/articles/snapshots/BbsArticlesSnapshotsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIBbsArticleSnapshot } from \"../../../../api/structures/IPageIBbsArticleSnapshot\";\nimport { IBbsArticleSnapshot } from \"../../../../api/structures/IBbsArticleSnapshot\";\n\n@Controller(\"/bbs/articles/:articleId/snapshots\")\nexport class BbsArticlesSnapshotsController {\n  /**\n   * Get all revision snapshots for a given article ('bbs_article_snapshots'\n   * table, by articleId), with pagination.\n   *\n   * This API lists all snapshots (modification revisions) for a specific\n   * article from the 'bbs_article_snapshots' table using the article's ID.\n   * Each snapshot includes title, body format, creation timestamp, ip\n   * address, and list of attachment files for that version.\n   *\n   * Supports pagination, important for heavily-edited articles (for\n   * performance). Access is generally open, but some security logic may be\n   * applied to deleted or restricted articles.\n   *\n   * Related operations: PATCH /bbs/articles for lists, GET /bbs/articles/{id}\n   * for details, GET /bbs/articles/{articleId}/snapshots/{id} for individual\n   * revision.\n   *\n   * @param articleId UUID of the article whose snapshots are being listed.\n   * @param body Optional pagination and filter parameters for snapshot\n   *   history.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByArticleid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleSnapshot.IRequest,\n  ): Promise<IPageIBbsArticleSnapshot> {\n    articleId;\n    body;\n    return typia.random<IPageIBbsArticleSnapshot>();\n  }\n\n  /**\n   * Get detail of a specific snapshot for a given article\n   * ('bbs_article_snapshots' table, by articleId and snapshotId).\n   *\n   * This API fetches a single snapshot (revision) of a given article using\n   * both IDs. The response includes the title, body, format, ip address, and\n   * the list of related attachments stored at the time of this revision. Used\n   * for auditing, difference viewing, or legal evidence of changes.\n   *\n   * Security checks ensure access to the underlying article. If the snapshot\n   * does not exist or is not linked to the specified article, a 'not found'\n   * is returned. No soft-delete applies to originals here; evidence is never\n   * removed.\n   *\n   * Related: PATCH /bbs/articles/{articleId}/snapshots for revision history.\n   *\n   * @param articleId UUID of the article to which the snapshot belongs.\n   * @param id UUID of the snapshot to fetch.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByArticleidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleSnapshot> {\n    articleId;\n    id;\n    return typia.random<IBbsArticleSnapshot>();\n  }\n\n  /**\n   * Update content or metadata of a specific article snapshot\n   * ('bbs_article_snapshots' table, by articleId and snapshotId);\n   * admin/system only.\n   *\n   * This API updates a snapshot 'bbs_article_snapshots' record. Normally,\n   * snapshot changes are forbidden for users (evidence preservation), but\n   * certain admin/system roles may execute corrections (e.g., unlawful\n   * content, typo fix). Updates may include modifications to title, body,\n   * format, or attachment relations; logs must track all changes for\n   * auditing.\n   *\n   * Security: restricted to admins or evidence maintainers. Standard\n   * validations apply, and revert possible for audit reasons. Related to\n   * PATCH /bbs/articles/{articleId}/snapshots.\n   *\n   * @param articleId UUID of the article containing the snapshot.\n   * @param id UUID of the snapshot to update.\n   * @param body Snapshot fields to update (title/body/attachments/format).\n   *   Usually only by admin/system.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putByArticleidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleSnapshot.IUpdate,\n  ): Promise<IBbsArticleSnapshot> {\n    articleId;\n    id;\n    body;\n    return typia.random<IBbsArticleSnapshot>();\n  }\n\n  /**\n   * Logically delete a snapshot of an article ('bbs_article_snapshots'),\n   * admin/system only, for evidence management.\n   *\n   * This API marks a specific article snapshot as deleted (logically),\n   * removing it from default user access. The actual snapshot record is not\n   * physically deleted, preserving historical evidence and references, but a\n   * status or timestamp is set as deleted.\n   *\n   * Security: strictly restricted to admin/system users. Normal users cannot\n   * delete snapshots (only create new ones for revisions). Soft-deleted\n   * snapshots may be included in audit/admin views with proper roles.\n   *\n   * Related: PATCH /bbs/articles/{articleId}/snapshots for revisions, GET\n   * /bbs/articles/{articleId}/snapshots/{id} for detail.\n   *\n   * @param articleId UUID of the article containing the snapshot.\n   * @param id UUID of the snapshot to delete.\n   * @param body Credentials or reason for deletion (admin/system use only).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseByArticleidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleSnapshot.IDelete,\n  ): Promise<IBbsArticleSnapshot> {\n    articleId;\n    id;\n    body;\n    return typia.random<IBbsArticleSnapshot>();\n  }\n}\n",
    "src/controllers/bbs/articles/snapshots/files/BbsArticlesSnapshotsFilesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIBbsArticleSnapshotFile } from \"../../../../../api/structures/IPageIBbsArticleSnapshotFile\";\nimport { IBbsArticleSnapshotFile } from \"../../../../../api/structures/IBbsArticleSnapshotFile\";\n\n@Controller(\"/bbs/articles/:articleId/snapshots/:snapshotId/files\")\nexport class BbsArticlesSnapshotsFilesController {\n  /**\n   * Attach one or more files to a specific snapshot of an article\n   * ('bbs_article_snapshot_files'), returning updated file list.\n   *\n   * This API attaches files to a specific article snapshot. It accepts file\n   * IDs (already uploaded via separate process) or requires necessary file\n   * metadata if uploading new files. For existing files, establishes the link\n   * via 'bbs_article_snapshot_files'; for new uploads, creates a file record\n   * in 'attachment_files' then associates it.\n   *\n   * Sequence/order is essential (for display order). Validation checks that\n   * files exist or are newly proper. Security: normal user edits require\n   * proper authentication; admin/system roles may bypass restrictions for\n   * evidence.</br>\n   *\n   * Returns updated list of attachments, with all associated metadata for the\n   * snapshot. Related: PATCH for updating the order, DELETE for deleting\n   * attachments.\n   *\n   * @param articleId UUID of the article of the snapshot being modified.\n   * @param snapshotId UUID of the snapshot to attach files to.\n   * @param body Attachment file information to link/upload for this snapshot,\n   *   plus order.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByArticleidAndSnapshotid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleSnapshotFile.ICreate,\n  ): Promise<IPageIBbsArticleSnapshotFile> {\n    articleId;\n    snapshotId;\n    body;\n    return typia.random<IPageIBbsArticleSnapshotFile>();\n  }\n\n  /**\n   * List all attachment files for a specific article snapshot (by\n   * articleId/snapshotId), using 'bbs_article_snapshot_files'.\n   *\n   * This API fetches all files attached to a specific revision (snapshot) of\n   * an article. Filters on articleId and snapshotId provide the explicit\n   * context to retrieve sequence/order of files, file metadata (name,\n   * extension, URL, creation time, sequence). Pagination can be included for\n   * snapshots with many files.\n   *\n   * Related operations: POST for attaching new files to a revision, DELETE\n   * for removing files, PATCH for reordering/updating attachment list.\n   *\n   * Attachment files must be publicly accessible (with proper security tokens\n   * if required).\n   *\n   * @param articleId UUID of the article of the snapshot.\n   * @param snapshotId UUID of the article snapshot whose files are being\n   *   listed.\n   * @param body Options for filtering or paging attached files for this\n   *   snapshot.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByArticleidAndSnapshotid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleSnapshotFile.IRequest,\n  ): Promise<IPageIBbsArticleSnapshotFile> {\n    articleId;\n    snapshotId;\n    body;\n    return typia.random<IPageIBbsArticleSnapshotFile>();\n  }\n\n  /**\n   * Get a specific attached file (bbs_article_snapshot_files) in a snapshot\n   * of an article.\n   *\n   * This GET operation retrieves a particular file attached to a specific\n   * snapshot of an article in the bulletin board system.\n   *\n   * The endpoint path parameters (articleId, snapshotId, id) represent the\n   * article UUID, the snapshot UUID, and the file attachment relation UUID\n   * (bbs_article_snapshot_files.id) respectively. This strict mapping ensures\n   * the file's association is under the correct article version, upholding\n   * evidentiary record accuracy as described in the requirements.\n   *\n   * Security considerations include verifying the logical existence of the\n   * parent article and snapshot (not deleted), and checking the user's\n   * permission for file access.\n   *\n   * Returns metadata about the attachment (order, file metadata, and URL for\n   * download). Relies on the correct structure and associations as maintained\n   * within the attachment_files and bbs_article_snapshot_files Prisma\n   * models.\n   *\n   * Handles errors such as not-found (404) if any ancestor entity does not\n   * exist or is inaccessible, and forbidden (403) for unauthorized access\n   * attempts.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param snapshotId Target snapshot ID (UUID) in bbs_article_snapshots\n   * @param id Attachment relation ID in bbs_article_snapshot_files\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByArticleidAndSnapshotidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleSnapshotFile> {\n    articleId;\n    snapshotId;\n    id;\n    return typia.random<IBbsArticleSnapshotFile>();\n  }\n\n  /**\n   * Update attachment file entry (bbs_article_snapshot_files) metadata for a\n   * given article snapshot.\n   *\n   * This PUT operation updates the mapping information for a specific file\n   * attached to an article snapshot. A typical use case includes resequencing\n   * file orders or changing ancillary metadata about this attachment (the\n   * file itself is immutable for evidence, but linkage/metadata can change\n   * for the active revision).\n   *\n   * Requires verification of the parent article (not deleted), parent\n   * snapshot, and correct ownership/permissions, as defined by the\n   * evidentiary and logical deletion model.\n   *\n   * The request body structure corresponds to updates for the\n   * 'bbs_article_snapshot_files' record, such as sequence reordering.\n   *\n   * Update is restricted to the targeted relation and does not affect\n   * historical data in previous snapshots.\n   *\n   * Handles error states including not-found for any path element, permission\n   * denial, and validation for business rules (e.g., not modifying a\n   * locked/evidence snapshot).\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param snapshotId Target snapshot ID (UUID) in bbs_article_snapshots\n   * @param id Attachment relation ID in bbs_article_snapshot_files\n   * @param body Info to update the attached file relation (e.g., sequence\n   *   order) in a snapshot.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putByArticleidAndSnapshotidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleSnapshotFile.IUpdate,\n  ): Promise<IBbsArticleSnapshotFile> {\n    articleId;\n    snapshotId;\n    id;\n    body;\n    return typia.random<IBbsArticleSnapshotFile>();\n  }\n\n  /**\n   * Delete (logically unlink) a file from a snapshot\n   * (bbs_article_snapshot_files) of an article.\n   *\n   * This DELETE operation logically removes (unlinks) an attachment file from\n   * a specific article snapshot in the system. The operation targets the\n   * entry in 'bbs_article_snapshot_files', marking it as logically deleted if\n   * required by implementation, while preserving evidence as per\n   * requirements.\n   *\n   * Deleted file entries should no longer display for the target snapshot,\n   * but all historical records and actual file data are preserved for audit\n   * and evidence. Parent entity existence (article, snapshot) and permissions\n   * are always validated.\n   *\n   * This operation may trigger side-effects such as reordering remaining\n   * files or revising display metadata for the snapshot, but never deletes\n   * actual file content.\n   *\n   * Errors handled include not-found for non-existing entities or relations,\n   * permission denial, and violation of audit-evidence policies.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param snapshotId Target snapshot ID (UUID) in bbs_article_snapshots\n   * @param id Attachment relation ID in bbs_article_snapshot_files\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseByArticleidAndSnapshotidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleSnapshotFile> {\n    articleId;\n    snapshotId;\n    id;\n    return typia.random<IBbsArticleSnapshotFile>();\n  }\n}\n",
    "src/controllers/bbs/articles/comments/BbsArticlesCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"../../../../api/structures/IBbsArticleComment\";\nimport { IPageBbsArticleComment } from \"../../../../api/structures/IPageBbsArticleComment\";\n\n@Controller(\"/bbs/articles/:articleId/comments\")\nexport class BbsArticlesCommentsController {\n  /**\n   * Create a new comment (bbs_article_comments) on an article.\n   *\n   * This POST operation creates a new comment on a specific article in the\n   * bulletin board system. New comments must include required fields such as\n   * writer, password, and initial content, referenced by a parentId if this\n   * is a reply to another comment (enables hierarchical threading).\n   *\n   * The operation first creates an entry in 'bbs_article_comments', then\n   * creates an initial bbs_article_comment_snapshots record with the\n   * comment's content. If files are attached, relevant mapping records are\n   * also created in bbs_article_comment_snapshot_files and attachment_files.\n   *\n   * Enforces password hashing, IP logging, timestamp recording, and\n   * initializes all evidence features.\n   *\n   * Handles validation errors (missing fields), permission enforcement, and\n   * ensures parent entities exist (article, parent comment if reply).\n   * Responds with the created comment structure, including snapshot\n   * references and attachment linkage.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param body Comment creation input for bbs_article_comments, including\n   *   parentId, writer, password, and initial content.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByArticleid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleComment.ICreate,\n  ): Promise<IBbsArticleComment> {\n    articleId;\n    body;\n    return typia.random<IBbsArticleComment>();\n  }\n\n  /**\n   * List all comments (bbs_article_comments) for an article, with\n   * search/filter.\n   *\n   * This PATCH operation fetches a paginated and searchable list of all\n   * comments related to a specific article, as defined in the requirements\n   * (nested structure, logical deletion, evidence). Search criteria can\n   * include author fields, timestamp range, parent/child linkage for\n   * hierarchical display, etc.\n   *\n   * Results present only comments not logically deleted for public users.\n   * Admins may access deleted items with proper authorization.\n   *\n   * Handles edge cases such as no results, excessive pagination, and filter\n   * security. Data comes from the 'bbs_article_comments' table, potentially\n   * joined with the latest comment snapshot for list views.\n   *\n   * Fails with 404 if article doesn't exist, or appropriate error for\n   * permission issues.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param body Parameters for searching, filtering, and pagination for\n   *   comment list.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByArticleid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleComment.IRequest,\n  ): Promise<IPageBbsArticleComment> {\n    articleId;\n    body;\n    return typia.random<IPageBbsArticleComment>();\n  }\n\n  /**\n   * Retrieve a specific comment (bbs_article_comments) within an article by\n   * ID.\n   *\n   * This GET operation retrieves a single comment by its unique identifier,\n   * attached to a specific article. It pulls data from\n   * 'bbs_article_comments', confirming article and comment association, and\n   * validates that the comment is not logically deleted for public views.\n   *\n   * Inherited relationships allow easy nesting for replies. The result\n   * returns only top-level comment record info (writer, timestamps, parent,\n   * etc)–attachable snapshots and files are accessed through other APIs.\n   *\n   * Permission and logical deletion rules are enforced: only non-deleted\n   * comments are shown publicly, while admins may retrieve deleted comments\n   * for evidence or audit purposes.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param id Target comment ID (UUID) in bbs_article_comments\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByArticleidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleComment> {\n    articleId;\n    id;\n    return typia.random<IBbsArticleComment>();\n  }\n\n  /**\n   * Update a specific comment (metadata/relationships) in\n   * bbs_article_comments within an article.\n   *\n   * This PUT operation modifies a comment on a given article, addressing\n   * certain updatable fields in 'bbs_article_comments' such as writer,\n   * password, or parentId (for reply/nesting structure). The revision of\n   * contents (body) is handled by subsequent snapshot creation in a nested or\n   * parallel API.\n   *\n   * Updates trigger standard evidence retention (audit trails, password\n   * verification), and may affect hierarchical threading. Parent entity\n   * existence must be verified. Logical deletion rules and permissions apply\n   * – deleted comments cannot be modified by typical users.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param id Target comment ID (UUID) in bbs_article_comments\n   * @param body Details for comments update, including writer, password, or\n   *   parentId for nesting.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putByArticleidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleComment.IUpdate,\n  ): Promise<IBbsArticleComment> {\n    articleId;\n    id;\n    body;\n    return typia.random<IBbsArticleComment>();\n  }\n\n  /**\n   * Logically delete (soft-delete) a comment (bbs_article_comments) from an\n   * article.\n   *\n   * This DELETE operation performs a logical (soft) deletion of a comment on\n   * a given article. Instead of removing the record from\n   * 'bbs_article_comments', the 'deleted_at' timestamp is set to the current\n   * time (soft delete), preserving audit trails for evidence and dispute\n   * resolution as mandated by system requirements.\n   *\n   * Checks that the targeted comment exists, is not already deleted, and that\n   * any user access or password verification requirements are satisfied.\n   * Deleted comments are excluded from public retrieval but available for\n   * evidence by administrators.\n   *\n   * Handles not-found, already-deleted, and access-denial errors\n   * appropriately.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param id Target comment ID (UUID) in bbs_article_comments\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseByArticleidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleComment> {\n    articleId;\n    id;\n    return typia.random<IBbsArticleComment>();\n  }\n}\n",
    "src/controllers/bbs/articles/comments/snapshots/BbsArticlesCommentsSnapshotsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageBbsArticleCommentSnapshot } from \"../../../../../api/structures/IPageBbsArticleCommentSnapshot\";\nimport { IBbsArticleCommentSnapshot } from \"../../../../../api/structures/IBbsArticleCommentSnapshot\";\n\n@Controller(\"/bbs/articles/:articleId/comments/:commentId/snapshots\")\nexport class BbsArticlesCommentsSnapshotsController {\n  /**\n   * List all snapshots (bbs_article_comment_snapshots) for a comment on an\n   * article, with search/pagination.\n   *\n   * This PATCH operation retrieves all snapshots (revision history) for a\n   * given comment attached to an article. Returns paginated and/or filtered\n   * results, including metadata such as format, timestamp, author IP, and\n   * relevant attachments (linkage only). This allows evidence presentation\n   * and rollback investigation for all comment changes.\n   *\n   * Access is restricted depending on logical deletion status and permissions\n   * (admins vs. general users). Snapshots provide information for audit,\n   * dispute resolution, or version comparison in the UI.\n   *\n   * Handles errors for invalid parameters, not-found comment/article\n   * ancestors, and respects maximum page size/policy limits.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param commentId Comment ID in bbs_article_comments to which the\n   *   snapshots belong\n   * @param body Parameters for searching, pagination, and filtering of\n   *   comment snapshots.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByArticleidAndCommentid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleCommentSnapshot.IRequest,\n  ): Promise<IPageBbsArticleCommentSnapshot> {\n    articleId;\n    commentId;\n    body;\n    return typia.random<IPageBbsArticleCommentSnapshot>();\n  }\n\n  /**\n   * Retrieve a specific comment snapshot (bbs_article_comment_snapshots) for\n   * a given comment on an article.\n   *\n   * This GET operation retrieves a single revision snapshot for a comment\n   * (bbs_article_comment_snapshots). The snapshot is uniquely identified by\n   * its attachment to a specific article, comment, and snapshot UUID.\n   *\n   * Returns detailed information about the snapshot content, including\n   * format, body, creation metadata, author IP, and file attachments (linkage\n   * only — actual files accessed through separate API calls).\n   *\n   * Fails with not-found errors if any identified entity does not exist or is\n   * not accessible, and enforces necessary permissions and logical deletion\n   * rules.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param commentId Comment ID in bbs_article_comments to which the snapshot\n   *   belongs\n   * @param id Comment snapshot ID (UUID) in bbs_article_comment_snapshots\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByArticleidAndCommentidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleCommentSnapshot> {\n    articleId;\n    commentId;\n    id;\n    return typia.random<IBbsArticleCommentSnapshot>();\n  }\n\n  /**\n   * Update content or metadata for a specific comment snapshot\n   * (bbs_article_comment_snapshots) by ID.\n   *\n   * This PUT operation updates metadata or content for a particular comment\n   * snapshot in the evidence system. While general edits typically create new\n   * snapshots, this can allow corrections under special administrative\n   * circumstances, for evidence correction or dispute resolution.\n   *\n   * Accepts content (body), format, and possibly file association\n   * adjustments. Must strictly validate parent article and comment, existing\n   * snapshot, and business rules for evidentiary control — typical users may\n   * not be allowed unless it's for error correction or privileged access.\n   *\n   * Side-effects are limited to only the indicated snapshot;\n   * evidence/integrity must be preserved.\n   *\n   * @param articleId Target article ID (UUID) in bbs_articles\n   * @param commentId Comment ID in bbs_article_comments to which the snapshot\n   *   belongs\n   * @param id Comment snapshot ID (UUID) in bbs_article_comment_snapshots\n   * @param body The content, format, or attachment linkage updates for this\n   *   comment snapshot.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putByArticleidAndCommentidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleCommentSnapshot.IUpdate,\n  ): Promise<IBbsArticleCommentSnapshot> {\n    articleId;\n    commentId;\n    id;\n    body;\n    return typia.random<IBbsArticleCommentSnapshot>();\n  }\n\n  /**\n   * Logically deletes a comment snapshot (bbs_article_comment_snapshots) by\n   * ID, nested under specific article and comment, as per\n   * evidence-preservation policy.\n   *\n   * This operation enables the logical deletion (soft delete) of a comment\n   * snapshot record in the bbs_article_comment_snapshots table, nested under\n   * a specific comment within a specific article. According to the system's\n   * requirements for evidence preservation, this operation sets a deleted\n   * flag or timestamp field (rather than actually removing any history data)\n   * to make the snapshot invisible to regular end users but still retained in\n   * the system for administrative/audit purposes.\n   *\n   * The operation involves several security considerations: only users with\n   * the correct password or administrators can perform deletions; IP\n   * addresses and audit trail information remain intact for compliance. The\n   * operation will fail if provided IDs do not correspond to existing\n   * entities.\n   *\n   * This endpoint should be used only when absolutely necessary, such as in\n   * compliance with legal requirements or gross abuse. Otherwise, all history\n   * should remain permanently retained.\n   *\n   * @param articleId Target article's ID\n   * @param commentId Target comment's ID\n   * @param id Target comment snapshot's ID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseByArticleidAndCommentidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    articleId;\n    commentId;\n    id;\n    return typia.random<void>();\n  }\n}\n",
    "src/controllers/bbs/articles/comments/snapshots/files/BbsArticlesCommentsSnapshotsFilesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { ICommentSnapshotFile } from \"../../../../../../api/structures/ICommentSnapshotFile\";\n\n@Controller(\n  \"/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files\",\n)\nexport class BbsArticlesCommentsSnapshotsFilesController {\n  /**\n   * Associates new file(s) with a comment snapshot\n   * (bbs_article_comment_snapshot_files), specifying attachment and order.\n   *\n   * This endpoint enables the creation/association of one or several\n   * attachment files to a given comment snapshot (reference\n   * bbs_article_comment_snapshot_files in schema). File IDs must be valid and\n   * refer to pre-uploaded resources defined in attachment_files. The request\n   * body (ICommentSnapshotFile.ICreate) allows specification of the file(s)\n   * to attach and their display sequence/order, in accordance with UX/UI\n   * requirements.\n   *\n   * Upon success, the endpoint returns the new relationship(s) and order in\n   * the response type. All additions occur in a database transaction. Proper\n   * authentication, permission, and validation against duplicate/illegal\n   * operations are required. Usage of this endpoint is fundamental to\n   * supporting evidence‐preserving file associations in comment histories.\n   *\n   * @param articleId Target article's ID\n   * @param commentId Target comment's ID\n   * @param snapshotId Target comment snapshot's ID\n   * @param body Association info (file IDs and any sequence/order) for new\n   *   attachments to the comment snapshot.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByArticleidAndCommentidAndSnapshotid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ICommentSnapshotFile.ICreate,\n  ): Promise<ICommentSnapshotFile> {\n    articleId;\n    commentId;\n    snapshotId;\n    body;\n    return typia.random<ICommentSnapshotFile>();\n  }\n\n  /**\n   * Partially updates attachment files (bbs_article_comment_snapshot_files)\n   * for a specific comment snapshot, with support for sequence/order\n   * changes.\n   *\n   * This endpoint provides partial update capability for attachment files on\n   * a specific comment snapshot, using a request body referencing\n   * ICommentSnapshotFile.IRequest or a similar input type. The underlying\n   * table is the bbs_article_comment_snapshot_files, which is responsible for\n   * maintaining the association and sequence of each file for each snapshot.\n   *\n   * Request validation ensures atomicity and transactional integrity: all\n   * add/remove/order changes are applied in a single transaction. Each update\n   * respects the unique sequence field to preserve file display order, a\n   * feature critical for end-user UX. Security checks must ensure that users\n   * have permission to alter the snapshot (password check/admin rights), and\n   * operations must be logged for audit. Related endpoints for\n   * attachment_files management should be referenced for holistic file\n   * lifecycle control.\n   *\n   * @param articleId Target article's ID\n   * @param commentId Target comment's ID\n   * @param snapshotId Target comment snapshot's ID\n   * @param body Partial update info with the new and/or reordered list of\n   *   attachment files for the comment snapshot.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByArticleidAndCommentidAndSnapshotid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ICommentSnapshotFile.IRequest,\n  ): Promise<ICommentSnapshotFile.ISummary> {\n    articleId;\n    commentId;\n    snapshotId;\n    body;\n    return typia.random<ICommentSnapshotFile.ISummary>();\n  }\n\n  /**\n   * Retrieves a specific attached file (bbs_article_comment_snapshot_files)\n   * for a comment snapshot, with file metadata and order.\n   *\n   * Fetch comprehensive metadata and relational info for a specific\n   * attachment file linked to a given comment snapshot. This involves joining\n   * bbs_article_comment_snapshot_files to bbs_article_comment_snapshots and\n   * attachment_files entities. The response provides display order\n   * (sequence), file name, extension, and URL for download/display purposes.\n   * Logical deletion/visibility rules apply as per system evidence-retaining\n   * policy, and audit trails/documentation should describe how to acquire\n   * both current and historical attachment file relationships.\n   *\n   * @param articleId Target article's ID\n   * @param commentId Target comment's ID\n   * @param snapshotId Target comment snapshot's ID\n   * @param id Target attachment relation\n   *   (bbs_article_comment_snapshot_files.id)\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByArticleidAndCommentidAndSnapshotidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<ICommentSnapshotFile> {\n    articleId;\n    commentId;\n    snapshotId;\n    id;\n    return typia.random<ICommentSnapshotFile>();\n  }\n\n  /**\n   * Updates order/association data for an attached file\n   * (bbs_article_comment_snapshot_files) for a comment snapshot.\n   *\n   * This operation enables updating the relationship data between a comment\n   * snapshot and an attached file by modifying the join table record\n   * (bbs_article_comment_snapshot_files). It's primarily for changing the\n   * file's display order (sequence) or other association-specific metadata.\n   * The request body conforms to ICommentSnapshotFile.IUpdate. This operation\n   * does not affect the physical file resource stored in attachment_files;\n   * use the dedicated API for file asset updates.\n   *\n   * Permission and integrity checks are necessary; only authorized users can\n   * update attachment associations. Related endpoints for partial update and\n   * file creation/deletion should be referenced for a complete file\n   * management lifecycle.\n   *\n   * @param articleId Target article's ID\n   * @param commentId Target comment's ID\n   * @param snapshotId Target comment snapshot's ID\n   * @param id Target attachment relation\n   *   (bbs_article_comment_snapshot_files.id)\n   * @param body Update information, typically just the sequence/order, for\n   *   the attached file association.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putByArticleidAndCommentidAndSnapshotidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: ICommentSnapshotFile.IUpdate,\n  ): Promise<ICommentSnapshotFile> {\n    articleId;\n    commentId;\n    snapshotId;\n    id;\n    body;\n    return typia.random<ICommentSnapshotFile>();\n  }\n\n  /**\n   * Deletes a comment snapshot's file association\n   * (bbs_article_comment_snapshot_files) by record ID, keeping asset file\n   * intact.\n   *\n   * This endpoint removes the association between a specific attachment file\n   * and a comment snapshot by deleting the join table record\n   * (bbs_article_comment_snapshot_files). The file asset remains in the\n   * system unless explicitly deleted elsewhere. All deletions must be\n   * authorized by permissions consistent with the evidence retention policy.\n   * Cascade rules in Prisma model keep referential integrity; access is\n   * restricted to users with modification/review rights.\n   *\n   * This operation supports the requirement that, although all evidence must\n   * be preserved, attachment relationships may sometimes be retracted per\n   * user request or content update, but full delete of history is by\n   * exception only.\n   *\n   * @param articleId Target article's ID\n   * @param commentId Target comment's ID\n   * @param snapshotId Target comment snapshot's ID\n   * @param id Target attachment relation\n   *   (bbs_article_comment_snapshot_files.id)\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseByArticleidAndCommentidAndSnapshotidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"commentId\")\n    commentId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"snapshotId\")\n    snapshotId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    articleId;\n    commentId;\n    snapshotId;\n    id;\n    return typia.random<void>();\n  }\n}\n",
    "src/controllers/attachmentFiles/AttachmentfilesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"../../api/structures/IAttachmentFile\";\nimport { IPageIAttachmentFile } from \"../../api/structures/IPageIAttachmentFile\";\n\n@Controller(\"/attachmentFiles\")\nexport class AttachmentfilesController {\n  /**\n   * Creates a new attachment file resource (attachment_files) with required\n   * metadata and file URL.\n   *\n   * This endpoint provisions a new file record in the attachment_files table,\n   * referencing metadata for an already-uploaded asset. The request body\n   * conforms to IAttachmentFile.ICreate, containing the file name, extension\n   * (nullable), and file URL. On success, it returns the created file\n   * resource with full metadata and unique assigned UUID. Cascade\n   * relationships in the schema guarantee that any later association to\n   * articles or comments snapshots is transactional and consistent.\n   *\n   * The file must be accessible by given URL and reserved for evidence\n   * retention purposes. Multiple objects can reference the same file asset as\n   * attachments, enabled by the join tables. Security and validation ensure\n   * the integrity and uniqueness of file records.\n   *\n   * @param body File resource metadata including name, extension, and file\n   *   URL.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IAttachmentFile.ICreate,\n  ): Promise<IAttachmentFile> {\n    body;\n    return typia.random<IAttachmentFile>();\n  }\n\n  /**\n   * Retrieves a paginated, searchable, sortable list of file resources\n   * (attachment_files).\n   *\n   * This operation retrieves a list of file resources managed in the system\n   * (attachment_files table), supporting flexible searching and filtering\n   * capabilities according to user, admin, or system automation needs.\n   * Supports pagination, sorting by date/filename, and querying by file type\n   * or other metadata, improving file list usability in UI grids and admin\n   * panels.\n   *\n   * Search requests reference the IAttachmentFile.IRequest schema,\n   * encapsulating search and filter parameters, and responses return\n   * IPageIAttachmentFile, containing pagination metadata plus file entries.\n   * Deletion/creation is handled via separate endpoints, and logical deletion\n   * policies must be respected if implemented in the table.\n   *\n   * @param body File search and filter parameters (filename, extension,\n   *   createdAt, etc.)\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IAttachmentFile.IRequest,\n  ): Promise<IPageIAttachmentFile> {\n    body;\n    return typia.random<IPageIAttachmentFile>();\n  }\n\n  /**\n   * Gets a specific attachment file resource (attachment_files) by its UUID\n   * ID.\n   *\n   * Fetch details for a single file resource from attachment_files by its\n   * system ID (UUID). Results include filename, extension, download URL, and\n   * other metadata for correct rendering and download in UI or for API-based\n   * consumption. Soft/hard delete status must be respected by this endpoint\n   * if supported in the schema, showing only valid, non-deleted resources as\n   * appropriate. Error handling required for missing IDs.\n   *\n   * @param id Target file resource's ID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IAttachmentFile> {\n    id;\n    return typia.random<IAttachmentFile>();\n  }\n\n  /**\n   * Updates metadata for an attachment file (attachment_files), e.g.,\n   * filename, extension, or URL.\n   *\n   * This endpoint enables authorized changes to metadata for an attachment\n   * file in the attachment_files table, such as filename, extension, or URL.\n   * The request body IAttachmentFile.IUpdate allows for one or more of these\n   * fields to be edited. Cascade relationships maintain referential integrity\n   * with join tables; updating file resources is critical for correcting\n   * errors or unifying data.\n   *\n   * Audit/compliance logging recommended for all changes; proper permission\n   * checks are required. Actual file content is not altered by this DB\n   * operation, only system-associated metadata.\n   *\n   * @param id Target file resource's ID\n   * @param body Updated metadata values for the attachment file (name,\n   *   extension, url).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IAttachmentFile.IUpdate,\n  ): Promise<IAttachmentFile> {\n    id;\n    body;\n    return typia.random<IAttachmentFile>();\n  }\n\n  /**\n   * Physically deletes (fully removes) a file resource (attachment_files) by\n   * its system ID.\n   *\n   * This endpoint allows full (hard) deletion of a file resource from the\n   * attachment_files table. It is restricted to situations where evidence\n   * retention policy and all association constraints are addressed. All\n   * children join records (bbs_article_snapshot_files,\n   * bbs_article_comment_snapshot_files) must be evaluated for foreign key\n   * safety—usually via ON DELETE CASCADE.\n   *\n   * Logical deletion may be preferable in auditing scenarios; however, this\n   * endpoint completely removes the file record, thus any download or\n   * reference links will become defunct. Only highly privileged actions and\n   * system clean-up tasks should invoke this.\n   *\n   * @param id Target file resource's ID\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<void> {\n    id;\n    return typia.random<void>();\n  }\n}\n",
    "src/api/structures/IBbsArticle.ts": "import { tags } from \"typia\";\n\nimport { IBbsArticleSnapshot } from \"./IBbsArticleSnapshot\";\nimport { IBbsArticleSnapshotFile } from \"./IBbsArticleSnapshotFile\";\nimport { IBbsArticleComment } from \"./IBbsArticleComment\";\n\n/**\n * Main entity type for BBS articles.\n *\n * Represents the core article record, corresponding to bbs_articles in Prisma\n * and ERD, but including related entities such as the latest snapshot, comment\n * count, and attachments list as described in the requirements. Used for\n * article detail, creation, and mutation result.\n *\n * Includes all mandatory and optional fields required for full persistence and\n * evidence, as described in requirements and schema. Each property is fully\n * documented for clarity and legal traceability.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticle = {\n  /**\n   * Unique identifier of article (UUID), primary key of bbs_articles.\n   *\n   * Generated at creation, used for all subsequent operations.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Original author's name, as entered on creation.\n   *\n   * Read-only after creation, except for admin/system update.\n   */\n  writer: string;\n\n  /**\n   * Encrypted password for proof of authorship and modification/deletion\n   * verification.\n   *\n   * Never returned in detail or list APIs, write-only (masked in UI).\n   */\n  password?: string & tags.Format<\"password\">;\n\n  /**\n   * Timestamp of original article creation.\n   *\n   * Mapped to bbs_articles.created_at.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Timestamp when logically deleted (soft delete).\n   *\n   * Indicates deletion in soft-delete model. Null if not deleted, else\n   * deleted. Mapped to bbs_articles.deleted_at.\n   */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n\n  /**\n   * Latest content snapshot for this article, showing title, body (current),\n   * format, ip, and related metadata. Used for basic detail and list views.\n   */\n  latestSnapshot: IBbsArticleSnapshot.ISummary;\n\n  /**\n   * Total number of comments directly associated with this article\n   * (non-deleted only). For UI performance and sorting.\n   */\n  commentCount?: number &\n    tags.Type<\"int32\"> &\n    tags.JsonSchemaPlugin<{\n      format: \"int32\";\n    }>;\n\n  /**\n   * List of attachments of the current (latest) snapshot, ordered by\n   * sequence.\n   */\n  attachments?: IBbsArticleSnapshotFile.ISummary[];\n\n  /**\n   * Complete snapshot revision history (usually only for admin or dedicated\n   * history endpoint).\n   */\n  snapshots?: IBbsArticleSnapshot[];\n\n  /**\n   * All associated comments (hierarchical structure not encoded here, only\n   * flat by default).\n   */\n  comments?: IBbsArticleComment[];\n};\nexport namespace IBbsArticle {\n  /**\n   * Query data type for bulletin board article search or pagination.\n   *\n   * This type corresponds to search, filter, sort, and pagination input for\n   * the BBS article listing endpoint. Each property enables selection or\n   * limitation by various fields and is mapped to the business context\n   * described in the requirements (efficient retrieval, search by\n   * writer/title/date, etc).\n   */\n  export type IRequest = {\n    /**\n     * Title search keyword.\n     *\n     * If provided, filters to articles whose latest snapshot's title\n     * matches or contains the value.\n     *\n     * Ref: bbs_article_snapshots.title\n     */\n    title?: string;\n\n    /**\n     * Exact or partial writer name for search.\n     *\n     * Used to filter articles by the 'writer' value in bbs_articles.writer.\n     */\n    writer?: string;\n\n    /**\n     * Lower bound (inclusive) for article creation time.\n     *\n     * Filters articles newer than or equal to the specified date/time.\n     *\n     * Ref: bbs_articles.created_at\n     */\n    createdAtFrom?: string & tags.Format<\"date-time\">;\n\n    /**\n     * Upper bound (inclusive) for article creation time (latest).\n     *\n     * Show articles created before or at the specified date/time.\n     */\n    createdAtTo?: string & tags.Format<\"date-time\">;\n\n    /**\n     * Show logically deleted articles also.\n     *\n     * If true, include soft-deleted articles (bbs_articles.deleted_at is\n     * non-null). Only allowed for admins.\n     */\n    deleted?: boolean;\n\n    /**\n     * Sort field for article listing.\n     *\n     * Maps to BBS UI sort options. Ex: 'createdAtDesc' for newest first.\n     */\n    orderBy?: \"createdAtDesc\" | \"createdAtAsc\" | \"titleAsc\" | \"titleDesc\";\n\n    /** Page number for pagination (1-based). Defaults to 1. */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.Minimum<1> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /** Number of articles per page. Enforced max 100 to prevent overload. */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.Default<20> &\n      tags.Minimum<1> &\n      tags.Maximum<100> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n  };\n\n  /**\n   * Request body type for creating a new BBS article.\n   *\n   * Corresponds to the requirements for BBS post creation (including author,\n   * password, content, and initial attachments). On creation, both\n   * bbs_articles and the initial bbs_article_snapshots record are created in\n   * a transaction. All properties are mapped to the data fields and business\n   * constraints described for posting in the requirements and the DB schema.\n   */\n  export type ICreate = {\n    /**\n     * Author's name for the new article (required).\n     *\n     * Maps to bbs_articles.writer. Required on creation, displayable in\n     * list/detail.\n     */\n    writer: string;\n\n    /**\n     * Author password for edit/delete. Set on create and used for future\n     * auth/verification.\n     *\n     * Mapped to bbs_articles.password (stored encrypted). Required on\n     * creation, write-only, not retrievable via detail endpoints.\n     */\n    password: string & tags.Format<\"password\">;\n\n    /**\n     * Title text for the new article's first version/snapshot.\n     *\n     * Mapped to bbs_article_snapshots.title. Required for creation.\n     */\n    title: string;\n\n    /**\n     * Body/content for the initial snapshot of the article.\n     *\n     * Mapped to bbs_article_snapshots.body. Required on creation.\n     */\n    body: string;\n\n    /**\n     * Format of the body (e.g., 'html', 'md', 'txt').\n     *\n     * Mapped to bbs_article_snapshots.format (content format for body\n     * storage).\n     */\n    format: string;\n\n    /** IP address for evidence. Recorded at creation and snapshot. */\n    ip: string;\n\n    /**\n     * Initial attachment files for the article's first snapshot (optional).\n     *\n     * Links to attachment_files via bbs_article_snapshot_files. Specify as\n     * list of IDs and sequence/order.\n     */\n    attachments?: IBbsArticleSnapshotFile.ICreate[];\n  };\n\n  /**\n   * Request body type for updating/editing a BBS article.\n   *\n   * Corresponds to the business process of verifying password, establishing a\n   * new snapshot with changed contents (title/body/format), and adjusting\n   * attachments. All changes create new evidence records. Mapped to the 'edit\n   * post' requirement and Prisma/ERD structure.\n   */\n  export type IUpdate = {\n    /**\n     * Author password to verify permission for update. Required for editing\n     * or deleting articles for evidence.\n     */\n    password: string & tags.Format<\"password\">;\n\n    /**\n     * New title text for update. Used for the new snapshot. Optional if not\n     * changed.\n     */\n    title?: string;\n\n    /**\n     * New body/content for update. Used for the new snapshot. Optional if\n     * not changed.\n     */\n    body?: string;\n\n    /** New format string (html/md/txt/etc.). Optional. */\n    format?: string;\n\n    /**\n     * Updated list of attachment files (add/delete/reorder) for this\n     * snapshot (optional).\n     */\n    attachments?: IBbsArticleSnapshotFile.ICreate[];\n\n    /** IP address for evidence. Must be included for auditing. */\n    ip: string;\n  };\n\n  /**\n   * Request body for logical deletion (soft-delete) of a BBS article by ID.\n   *\n   * As per specifications, the password verifies authorship for the deletion.\n   * Deletion sets deleted_at only. Evidence/history is retained. Admins may\n   * have alternate logic for forced deletion.\n   */\n  export type IDelete = {\n    /**\n     * Password for logical deletion verification. Required to authorize\n     * soft-delete.\n     */\n    password: string & tags.Format<\"password\">;\n  };\n\n  /**\n   * Summary data for a BBS article, for list display.\n   *\n   * Synced to list view requirements (title, writer, comment count,\n   * created_at, etc.). Does not include full snapshot/attachments/comments.\n   */\n  export type ISummary = {\n    /** ID of the article. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Author's name. */\n    writer: string;\n\n    /** Title from the latest snapshot. */\n    title: string;\n\n    /** Number of comments attached (non-deleted only). */\n    commentCount: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /** Creation time for article. */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /** Soft delete timestamp, if present. */\n    deleted_at?: (string & tags.Format<\"date-time\">) | null;\n  };\n}\n",
    "src/api/structures/IPageIBbsArticle.ts": "import { IPage } from \"./IPage\";\nimport { IBbsArticle } from \"./IBbsArticle\";\n\nexport namespace IPageIBbsArticle {\n  /**\n   * Paginated response type for BBS article summaries.\n   *\n   * Contains both pagination metadata and actual list of article summary\n   * objects as required for efficient list display in UI, referencing the\n   * standard IPage<T> approach.\n   */\n  export type ISummary = {\n    pagination?: IPage.IPagination;\n\n    /** Array of summarized articles for the list page. */\n    data?: IBbsArticle.ISummary[];\n  };\n}\n",
    "src/api/structures/IBbsArticleSnapshot.ts": "import { tags } from \"typia\";\n\nimport { IBbsArticleSnapshotFile } from \"./IBbsArticleSnapshotFile\";\n\n/**\n * Represents a single revision snapshot of an article (bbs_article_snapshots\n * table).\n *\n * Includes all fields for audit/evidence (body, title, format, ip, attachments\n * list, creation time, etc.). Used for both detail views and snapshot\n * histories.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticleSnapshot = {\n  /**\n   * Unique identifier for this snapshot (UUID).\n   *\n   * Primary key of bbs_article_snapshots.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Reference article ID for this snapshot.\n   *\n   * Foreign key to bbs_articles.id.\n   */\n  bbs_article_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Title of the post at this revision.\n   *\n   * Snapshots record the state as of this revision; may differ from current.\n   */\n  title: string;\n\n  /** Body/content of article at this specific revision. */\n  body: string;\n\n  /** Format for body—one of html/md/txt/etc. */\n  format: string;\n\n  /** Writer's IP address at time of modification. */\n  ip?: string;\n\n  /**\n   * Timestamp of when this revision was created. Used for precise evidence\n   * chain.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Attachment files list at this revision (may differ per snapshot, follows\n   * sequence/order property).\n   */\n  attachments?: IBbsArticleSnapshotFile.ISummary[];\n};\nexport namespace IBbsArticleSnapshot {\n  /**\n   * Pagination/filter/search type for listing all revision snapshots of a\n   * given article.\n   *\n   * Maps to the need to efficiently retrieve long modification histories.\n   * Used for PATCH /bbs/articles/{articleId}/snapshots.\n   */\n  export type IRequest = {\n    /** Filter by snapshot body format (e.g., md/html/txt). */\n    format?: string;\n\n    /** Lower date/time filter for snapshot creation. */\n    createdAtFrom?: string & tags.Format<\"date-time\">;\n\n    /** Upper date/time filter for snapshot creation. */\n    createdAtTo?: string & tags.Format<\"date-time\">;\n\n    /** Sort by creation date (default to latest first). */\n    orderBy?: \"createdAtDesc\" | \"createdAtAsc\";\n\n    /** Pagination; page number, starting from 1. */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    /** Per-page record limit, default 20. */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n  };\n\n  /**\n   * Request schema for updating an article snapshot (admin/system only).\n   *\n   * Allows updating title/body/format or file association for special cases.\n   * For general users, only new snapshots are created instead.\n   */\n  export type IUpdate = {\n    /** Updated title for this snapshot (optional). */\n    title?: string;\n\n    /** Updated body/content for this snapshot (optional). */\n    body?: string;\n\n    /** Updated format (e.g., html/md/txt) for this snapshot (optional). */\n    format?: string;\n\n    /** Adjusted list of attached files for this snapshot. */\n    attachments?: IBbsArticleSnapshotFile.IUpdate[];\n  };\n\n  /**\n   * Request body for logical deletion of an article snapshot (admin/system\n   * only).\n   *\n   * As evidence, snapshots are generally not deleted, but this API allows\n   * logical deletion for policy/compliance needs. Fields for metadata or\n   * reason may be added.\n   */\n  export type IDelete = {\n    /** Reason for deletion (optional, for audit/compliance logging). */\n    reason?: string;\n  };\n\n  /**\n   * Summary view of an article snapshot.\n   *\n   * For embedding only the essential info about the content body/version for\n   * displays or relationships. Contains fields such as title, body, format,\n   * and creation time.\n   */\n  export type ISummary = {\n    /** Snapshot UUID. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Title (as of this snapshot). */\n    title: string;\n\n    /** Content/body of this snapshot. */\n    body: string;\n\n    /** Body format at the time (html/md/txt). */\n    format: string;\n\n    /** IP address for evidence (stored at snapshot creation). */\n    ip?: string;\n\n    /** Snapshot creation date/time. */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n}\n",
    "src/api/structures/IPageIBbsArticleSnapshot.ts": "import { IPage } from \"./IPage\";\nimport { IBbsArticleSnapshot } from \"./IBbsArticleSnapshot\";\n\n/**\n * Paging container for lists of article snapshot revision records.\n *\n * Conforms to standard paging shape, with IPage.IPagination and data\n * (IBbsArticleSnapshot[]). For use when listing all revisions of an article.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIBbsArticleSnapshot = {\n  pagination?: IPage.IPagination;\n\n  /** Array of all revision snapshot records for given article. */\n  data?: IBbsArticleSnapshot[];\n};\n",
    "src/api/structures/IBbsArticleSnapshotFile.ts": "import { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Represents the file attachment relationship for a specific article snapshot\n * in the evidence-preserving bulletin board system.\n *\n * Based on bbs_article_snapshot_files, includes file reference, sequence order,\n * and resolved file metadata for full download and auditability.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticleSnapshotFile = {\n  /**\n   * Primary Key for this attachment relation (bbs_article_snapshot_files.id).\n   *\n   * Uniquely identifies the relationship, not the physical file.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * ID of the snapshot to which this file is attached.\n   *\n   * References bbs_article_snapshots.id. Connects relationship and enables\n   * evidence-based traceability.\n   */\n  bbs_article_snapshot_id: string & tags.Format<\"uuid\">;\n\n  /** ID of the attached file (attachment_files.id). */\n  attachment_file_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Display sequence within the list of this snapshot's attachments.\n   *\n   * Used for end-user UX (order of preview/download) and for forensics.\n   */\n  sequence: number & tags.Type<\"int32\">;\n\n  /**\n   * Metadata about the attached file resource. See AttachmentFile for\n   * detailed member info.\n   */\n  file: IAttachmentFile;\n};\nexport namespace IBbsArticleSnapshotFile {\n  /**\n   * Request schema for paginated listing/partial update/complex query of\n   * files attached to an article snapshot.\n   *\n   * Used to filter, search, or modify attachment order for snapshot files.\n   * Maps sequences and handles per-snapshot association maintenance.\n   */\n  export type IRequest = {\n    /** Filter for specific attachment file UUID. */\n    attachment_file_id?: string & tags.Format<\"uuid\">;\n\n    /** Sort order for files attached to a snapshot. */\n    orderBy?: \"createdAtDesc\" | \"createdAtAsc\" | \"sequenceAsc\" | \"sequenceDesc\";\n\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"int32\";\n      }>;\n  };\n\n  /**\n   * Request body for attaching a file to a specific article snapshot in the\n   * BBS system.\n   *\n   * Fields provide file reference (attachment_file_id) and ordering\n   * (sequence) per business needs and evidentiary requirements.\n   */\n  export type ICreate = {\n    /**\n     * ID of the attachment file to link (attachment_files.id).\n     *\n     * Must reference an existing uploaded file resource.\n     */\n    attachment_file_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Display order (sequence) for the file in this snapshot's file list.\n     *\n     * Mandatory in UI/UX so that download or preview order can be explicit.\n     */\n    sequence: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * Request body for updating the attachment sequence/order in a given\n   * article snapshot's attachment file list.\n   *\n   * Only reordering field (sequence) allowed for normal operations; for\n   * evidence preservation, other fields are not modifiable by typical users.\n   */\n  export type IUpdate = {\n    /**\n     * Updated display order (sequence) for this file in the snapshot.\n     *\n     * Utilized for user-driven attachment reordering or administrative\n     * correction.\n     */\n    sequence: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * Summary object for an individual file attached to an article snapshot\n   * (bbs_article_snapshot_files), for display in list/detail views.\n   *\n   * Includes both the relationship (sequence, etc.) and the core file\n   * metadata (name, extension, url, created_at) from attachment_files.\n   */\n  export type ISummary = {\n    /**\n     * UUID relation key for the file in this snapshot\n     * (bbs_article_snapshot_files.id)\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Display order of the file in the snapshot. */\n    sequence: number & tags.Type<\"int32\">;\n\n    /**\n     * Basic metadata for the file asset (name, extension, url, created_at,\n     * etc.)\n     */\n    file: IAttachmentFile.ISummary;\n  };\n}\n",
    "src/api/structures/IPage.ts": "import { tags } from \"typia\";\n\nexport namespace IPage {\n  /**\n   * Pagination metadata for paged OpenAPI results.\n   *\n   * Standardizes page navigation and client-side page controls per IPage<T>.\n   */\n  export type IPagination = {\n    /**\n     * Current page number.\n     *\n     * Helps the client understand which subset of total records is being\n     * viewed.\n     */\n    current: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Number of records per page (default 100).\n     *\n     * Assists performance tuning for UI grids and API result limits.\n     */\n    limit: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Total available records in the database matching current query.\n     *\n     * Allows accurate pagination and total count calculations.\n     */\n    records: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Total number of pages available for the data set.\n     *\n     * Computed as records/limit with ceiling, helps navigation controls.\n     */\n    pages: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n  };\n}\n",
    "src/api/structures/IAttachmentFile.ts": "import { tags } from \"typia\";\n\n/**\n * Attachment file resource object for all file entities (attachment_files).\n *\n * Represents a managed asset for evidence, with metadata used throughout the\n * BBS UI and evidence system.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IAttachmentFile = {\n  /**\n   * Primary key of the attachment file resource (attachment_files.id).\n   *\n   * Guarantees unique identification for download, display, and management.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * File name (without extension).\n   *\n   * Directly from attachment_files.name; guides human-readable file listings.\n   */\n  name: string;\n\n  /**\n   * File extension if present (nullable).\n   *\n   * Taken from attachment_files.extension, may be null for files like README\n   * or LICENSE.\n   */\n  extension?: string;\n\n  /**\n   * File URL for download/storage reference.\n   *\n   * Provided by attachment_files.url in the Prisma schema.\n   */\n  url: string;\n\n  /**\n   * Timestamp of file creation (ISO 8601).\n   *\n   * From attachment_files.created_at; ensures evidence and lifecycle audit\n   * for this resource.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IAttachmentFile {\n  /**\n   * Summary view of attachment file info (attachment_files), for use in\n   * detail/list views.\n   *\n   * Contains only identifying and most-accessed metadata properties for files\n   * attached to snapshots or comments.\n   */\n  export type ISummary = {\n    /** File's unique ID (attachment_files.id) */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Filename, excluding extension. */\n    name: string;\n\n    /** File extension (can be null, e.g., README) */\n    extension?: string | null;\n\n    /** URL link to actual file storage. */\n    url: string;\n\n    /** Time at which the file was added/registered. */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * Request body for searching/filtering attachment files (attachment_files).\n   *\n   * Provides a variety of fields for querying files for BBS management UI,\n   * per requirements.\n   */\n  export type IRequest = {\n    /**\n     * File name (without extension) to search/filter.\n     *\n     * Corresponds to the 'name' attribute in attachment_files; supports\n     * partial-matching, case-insensitive filters.\n     */\n    name?: string;\n\n    /**\n     * File extension to search/filter (optional).\n     *\n     * Checks the 'extension' column in attachment_files; can be null or\n     * empty for extensionless files.\n     */\n    extension?: string;\n\n    /**\n     * Minimum file creation time for filter (ISO 8601 format).\n     *\n     * Matches attachment_files.created_at greater or equal for time-based\n     * queries.\n     */\n    created_at_min?: string & tags.Format<\"date-time\">;\n\n    /**\n     * Maximum file creation time for filter (ISO 8601 format).\n     *\n     * Matches attachment_files.created_at less or equal for time-based\n     * queries.\n     */\n    created_at_max?: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * Request body to create a new file record in the attachment_files table.\n   *\n   * All fields necessary for building file metadata and supporting system\n   * evidence requirements.\n   */\n  export type ICreate = {\n    /**\n     * File name, without extension.\n     *\n     * As per attachment_files.name; provides semantic name used for\n     * identifying files by users and clients.\n     */\n    name: string;\n\n    /**\n     * File extension (nullable).\n     *\n     * Corresponds to attachment_files.extension, allows for both normal and\n     * extensionless files (e.g., README). May be null or omitted.\n     */\n    extension?: string;\n\n    /**\n     * URL of the physical file resource.\n     *\n     * Matches attachment_files.url; must be a valid, accessible path or\n     * download location for this resource.\n     */\n    url: string;\n  };\n\n  /**\n   * Update model for editing attributes of an attachment file record\n   * (attachment_files).\n   *\n   * Supports correction and data hygiene activities by admins or automation\n   * systems.\n   */\n  export type IUpdate = {\n    /**\n     * New file name without extension.\n     *\n     * Updates the attachment_files.name field for renamed assets.\n     */\n    name?: string;\n\n    /**\n     * New or updated extension (nullable).\n     *\n     * Modifies attachment_files.extension; supports cases like file format\n     * correction or metadata update.\n     */\n    extension?: string;\n\n    /**\n     * New or corrected file URL.\n     *\n     * May be used if the file has been re-uploaded or migrated to new\n     * storage.\n     */\n    url?: string;\n  };\n}\n",
    "src/api/structures/IBbsArticleComment.ts": "import { tags } from \"typia\";\n\nimport { IBbsArticleCommentSnapshot } from \"./IBbsArticleCommentSnapshot\";\nimport { IBbsArticleCommentSnapshotFile } from \"./IBbsArticleCommentSnapshotFile\";\n\n/**\n * Main comment entity for the evidence-preserving BBS system.\n *\n * Maps to bbs_article_comments, holds hierarchical relationships, attached\n * snapshots, and logical deletion flags.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticleComment = {\n  /** Unique identifier for the comment (bbs_article_comments.id). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** UUID for the parent article (bbs_articles.id) this comment belongs to. */\n  bbs_article_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Parent comment UUID (for replies/subcomments).\n   *\n   * Null for top-level comments.\n   */\n  parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /** Display name of the comment's author (bbs_article_comments.writer). */\n  writer: string;\n\n  /** When the comment was first created (bbs_article_comments.created_at). */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /** Logical deletion timestamp for evidence compliance. Null if active. */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n\n  /**\n   * Revision history snapshots for this comment.\n   *\n   * Each represents a modification state (title, body, files, IP, time,\n   * etc.).\n   */\n  snapshots: IBbsArticleCommentSnapshot[];\n\n  /** Immediate child/nested replies. Recursive for unlimited hierarchy depth. */\n  children?: IBbsArticleComment[];\n};\nexport namespace IBbsArticleComment {\n  /**\n   * Request parameters for listing, searching, and paging comments for an\n   * article.\n   *\n   * Supports flexible filtering by author, date, parent comment (for\n   * hierarchy), and standard pagination.\n   */\n  export type IRequest = {\n    /**\n     * Optional page number for pagination.\n     *\n     * Defines which page of the comment list to fetch.\n     */\n    page?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n\n    /**\n     * How many comment entries should be returned per page (default 100).\n     *\n     * Supports UI efficiency and server protection.\n     */\n    limit?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n\n    /**\n     * Optional comment writer to filter results\n     * (bbs_article_comments.writer).\n     *\n     * Enables search by author display name.\n     */\n    writer?: string | null;\n\n    /**\n     * Optional lower bound for comment creation datetime.\n     *\n     * Used for filtering searches by time window.\n     */\n    created_at_from?: (string & tags.Format<\"date-time\">) | null;\n\n    /** Optional upper bound for comment creation datetime. */\n    created_at_to?: (string & tags.Format<\"date-time\">) | null;\n\n    /**\n     * Parent comment's ID. Used for hierarchy filtering.\n     *\n     * Set for displaying top-level comments (null) or replies (non-null).\n     */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n  };\n\n  /**\n   * Request body to create a new comment on a BBS article.\n   *\n   * Initial content/format and files are included for atomic evidence\n   * creation and ease of use.\n   */\n  export type ICreate = {\n    /**\n     * UUID of the parent article (bbs_articles.id) to which this comment is\n     * posted.\n     */\n    bbs_article_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * UUID of the parent comment if this is a reply.\n     *\n     * For flat comments, null. Enables unlimited depth hierarchies.\n     */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * Display name used for this comment's author. Stored in\n     * bbs_article_comments.writer.\n     */\n    writer: string;\n\n    /**\n     * Password for comment modification/deletion.\n     *\n     * Encrypted in storage per evidence/compliance requirements.\n     */\n    password: string;\n\n    /**\n     * The text body for the initial comment content (used in first snapshot\n     * record creation).\n     */\n    initial_body: string;\n\n    /**\n     * Format type of the comment body: 'md', 'html', 'txt', etc.\n     *\n     * Aligns with the body format field in bbs_article_comment_snapshots.\n     */\n    initial_format: string;\n\n    /**\n     * Initial list of files attached to this comment when first posted.\n     *\n     * Relates to evidence/attachment mapping. Optional—may be empty.\n     */\n    initial_files?: IBbsArticleCommentSnapshotFile.ICreate[];\n  };\n\n  /**\n   * Editable fields for updating a comment's metadata/relationships in\n   * bbs_article_comments.\n   *\n   * Comment body/content is not updated here (managed via snapshot creation).\n   */\n  export type IUpdate = {\n    /** If updated, replaces current display name for comment's author. */\n    writer?: string | null;\n\n    /** If changed, will update nesting/parent of the comment. */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * New password value, if changed.\n     *\n     * Stored securely (hash/encrypt) per evidence/audit policy.\n     */\n    password?: string;\n  };\n}\n",
    "src/api/structures/IPageIBbsArticleSnapshotFile.ts": "import { IPage } from \"./IPage\";\nimport { IBbsArticleSnapshotFile } from \"./IBbsArticleSnapshotFile\";\n\n/**\n * Paginated list of files attached to an article snapshot, for the\n * evidence-preserving bulletin board system.\n *\n * Based on the 'bbs_article_snapshot_files' and related attachment_files tables\n * from the Prisma schema. Designed for performance in UI file listing and audit\n * views. Includes detailed pagination and attachment sequence information.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIBbsArticleSnapshotFile = {\n  /**\n   * Pagination information.\n   *\n   * Indicates the current page, page size, total record count, and number of\n   * pages. See IPage.IPagination for field-level details.\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * Array of files attached to the article snapshot on this page.\n   *\n   * Each entry represents a file relationship, including sequence/order and\n   * file metadata.\n   */\n  data: IBbsArticleSnapshotFile[];\n};\n",
    "src/api/structures/IPageBbsArticleComment.ts": "import { IPage } from \"./IPage\";\nimport { IBbsArticleComment } from \"./IBbsArticleComment\";\n\n/**\n * Paginated response for a list of comments attached to an article in the\n * evidence-preserving bulletin board system.\n *\n * Built upon bbs_article_comments.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageBbsArticleComment = {\n  /** Paging metadata for the comment list. */\n  pagination: IPage.IPagination;\n\n  /**\n   * Array of comments in this response page. Each contains BBS article\n   * comment metadata and references to parent/hierarchy info.\n   */\n  data: IBbsArticleComment[];\n};\n",
    "src/api/structures/IBbsArticleCommentSnapshot.ts": "import { tags } from \"typia\";\n\nimport { IBbsArticleCommentSnapshotFile } from \"./IBbsArticleCommentSnapshotFile\";\nimport { ICommentSnapshotFile } from \"./ICommentSnapshotFile\";\n\n/**\n * Snapshot version record for a BBS article comment in the evidence-preserving\n * system.\n *\n * Allows auditability of all edits, preserving prior versions and attached\n * files.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticleCommentSnapshot = {\n  /** Primary key of the comment snapshot (bbs_article_comment_snapshots.id). */\n  id: string & tags.Format<\"uuid\">;\n\n  /** ID of the parent comment this snapshot is for. */\n  bbs_article_comment_id: string & tags.Format<\"uuid\">;\n\n  /** Format of the snapshot's text body (md/html/txt/...). */\n  format: string;\n\n  /** Body/content text of the comment at this revision. */\n  body: string;\n\n  /** Writer's IP at this revision for evidence purposes. */\n  ip: string;\n\n  /** Revision/snapshot creation timestamp. */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /** Array of files attached to this specific snapshot version. */\n  files?: IBbsArticleCommentSnapshotFile[];\n};\nexport namespace IBbsArticleCommentSnapshot {\n  /**\n   * Request body for paginated retrieval of a comment's revision snapshot\n   * history.\n   *\n   * Used in PATCH /bbs/articles/{articleId}/comments/{commentId}/snapshots.\n   */\n  export type IRequest = {\n    /** Page number for snapshot history pagination. */\n    page?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n\n    /** Number of snapshots per page; default is 100. */\n    limit?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n  };\n\n  /**\n   * Update request body for a comment snapshot\n   * (bbs_article_comment_snapshots).\n   *\n   * Allows admin/system-level correction of snapshot details: format, body,\n   * and updated file attachments. Fulfills evidentiary correction by\n   * privileged actors as described in BBS requirements and Prisma schema.\n   */\n  export type IUpdate = {\n    /**\n     * Format of the comment content body (e.g., 'html', 'md', 'txt').\n     *\n     * Corresponds to the 'format' column in bbs_article_comment_snapshots,\n     * denoting the format of the comment body for the specific snapshot.\n     */\n    format?: string;\n\n    /**\n     * Content body of the comment.\n     *\n     * Reflects the 'body' in bbs_article_comment_snapshots, holding the\n     * modified text of this specific revision.\n     */\n    body?: string;\n\n    /**\n     * List of file associations to be attached with this snapshot update.\n     *\n     * References new or changed file linkage when updating the snapshot.\n     * Each file entry conforms to ICommentSnapshotFile.ICreate.\n     */\n    to_files?: ICommentSnapshotFile.ICreate[];\n  };\n}\n",
    "src/api/structures/IPageBbsArticleCommentSnapshot.ts": "import { IPage } from \"./IPage\";\nimport { IBbsArticleCommentSnapshot } from \"./IBbsArticleCommentSnapshot\";\n\n/**\n * Paginated response for a comment's snapshot history in the\n * evidence-preserving BBS.\n *\n * Maps from bbs_article_comment_snapshots and associated relationships.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageBbsArticleCommentSnapshot = {\n  /** Pagination information for comment snapshot history. */\n  pagination: IPage.IPagination;\n\n  /** Snapshots found for this comment and page. */\n  data: IBbsArticleCommentSnapshot[];\n};\n",
    "src/api/structures/IBbsArticleCommentSnapshotFile.ts": "import { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Models relationship between a comment snapshot and an attached file in the\n * evidence system.\n *\n * Mirrors bbs_article_comment_snapshot_files in Prisma with metadata for\n * retrieval/rendering/audit.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticleCommentSnapshotFile = {\n  /** Primary key (join record) for comment snapshot to file attachment. */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Comment snapshot this file is associated with. */\n  bbs_article_comment_snapshot_id: string & tags.Format<\"uuid\">;\n\n  /** The linked file's unique system id. */\n  attachment_file_id: string & tags.Format<\"uuid\">;\n\n  /** File ordering for user-facing presentation and audit. */\n  sequence: number & tags.Type<\"int32\">;\n\n  /** File resource metadata—name, extension, URL, upload info, etc. */\n  file: IAttachmentFile;\n};\nexport namespace IBbsArticleCommentSnapshotFile {\n  /** Used for initial file attachment when creating a new comment snapshot. */\n  export type ICreate = {\n    /** The file's system UUID to link. */\n    attachment_file_id: string & tags.Format<\"uuid\">;\n\n    /** Order/position for file display. */\n    sequence: number & tags.Type<\"int32\">;\n  };\n}\n",
    "src/api/structures/ICommentSnapshotFile.ts": "import { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Attachment file association for comment snapshots\n * (bbs_article_comment_snapshot_files).\n *\n * Represents the evidentiary link between a snapshot version and an attachment\n * file, with rich details and order management, referencing Prisma schema join\n * structure.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type ICommentSnapshotFile = {\n  /**\n   * Primary key (ID) for the file association\n   * (bbs_article_comment_snapshot_files.id).\n   *\n   * Uniquely identifies this mapping between comment snapshot and attachment\n   * file.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * UUID indicating the snapshot this file is attached to\n   * (bbs_article_comment_snapshots.id).\n   *\n   * Establishes relationship context for this attachment mapping.\n   */\n  bbs_article_comment_snapshot_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * UUID of the attached file record (attachment_files.id).\n   *\n   * Connects association to the actual file record for download/display.\n   */\n  attachment_file_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * The display order (sequence) in the snapshot list\n   * (bbs_article_comment_snapshot_files.sequence).\n   *\n   * Used for rendering attached files in the correct order.\n   */\n  sequence: number & tags.Type<\"int32\">;\n\n  /**\n   * File metadata for the associated file resource (attachment_files).\n   *\n   * Enables in-context display, download, and audit in UI clients.\n   */\n  file?: IAttachmentFile;\n};\nexport namespace ICommentSnapshotFile {\n  /**\n   * Request body for partial update of attachment files for a comment\n   * snapshot (bbs_article_comment_snapshot_files).\n   *\n   * Used to reorder, add, or remove associations, maintaining the correct\n   * sequence field per UI and evidence requirements.\n   */\n  export type IRequest = {\n    /**\n     * Array of attachment file UUIDs to associate with the comment\n     * snapshot.\n     *\n     * Reflects intended linkage/reordering/removal during partial update of\n     * the snapshot's file attachments. Must correspond to valid\n     * attachment_files records.\n     */\n    file_ids: (string & tags.Format<\"uuid\">)[];\n\n    /**\n     * Optional mapping for the display order (sequence) of the files.\n     *\n     * Allows explicit reordering of file attachments for UI/UX accuracy;\n     * order must match file_ids array if included.\n     */\n    sequences?: (number & tags.Type<\"int32\">)[];\n  };\n\n  /**\n   * Summary type for a file association in a comment snapshot\n   * (bbs_article_comment_snapshot_files), including file metadata and order.\n   *\n   * Provides ordering and audit fields for client-side rendering and review\n   * in revision history UIs.\n   */\n  export type ISummary = {\n    /**\n     * Primary key of the attachment file relationship\n     * (bbs_article_comment_snapshot_files.id).\n     *\n     * Unique identifier for the attachment mapping for audit and\n     * management.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Metadata of the attached file at this sequence/relationship.\n     *\n     * Links to the actual file resource in attachment_files, enabling\n     * metadata retrieval such as filename, extension, and URL.\n     */\n    file: IAttachmentFile;\n\n    /**\n     * Display order (sequence) for the file in the comment snapshot.\n     *\n     * Ensures the intended order of files for the given revision. Sourced\n     * from the 'sequence' column of bbs_article_comment_snapshot_files.\n     */\n    sequence: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * Request body for creating a new attached file record in a comment\n   * snapshot (bbs_article_comment_snapshot_files).\n   *\n   * Supplies file and sequence information to establish a new file\n   * association under the BBS comment revision evidence framework.\n   */\n  export type ICreate = {\n    /**\n     * UUID of the file to be attached (attachment_files.id).\n     *\n     * References a pre-uploaded file for association with the comment\n     * snapshot mapping.\n     */\n    attachment_file_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Display order (sequence) for this file in the snapshot.\n     *\n     * Represents the association's intended display order as seen by users.\n     */\n    sequence: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * Update model for an attachment file mapping\n   * (bbs_article_comment_snapshot_files) for a comment snapshot.\n   *\n   * Primarily used for resequencing file attachments as per UI/UX needs; only\n   * sequence can be changed in evidence context.\n   */\n  export type IUpdate = {\n    /**\n     * Update the file's display order (sequence value) in the association\n     * record.\n     *\n     * Directly alters the sequence column to reorder attachments.\n     */\n    sequence: number & tags.Type<\"int32\">;\n  };\n}\n",
    "src/api/structures/IPageIAttachmentFile.ts": "import { IPage } from \"./IPage\";\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Paged result container for attachment file search results (attachment_files).\n *\n * Follows IPage<T> interface for consistency, referencing Prisma indexing and\n * UI performance requirements.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIAttachmentFile = {\n  /**\n   * Pagination metadata for file list results.\n   *\n   * Includes page number, limit, total records, and pages for UI and API\n   * usability.\n   */\n  pagination: IPage.IPagination;\n\n  /**\n   * Attachment file data entries for this page of results.\n   *\n   * Each entry corresponds to a file metadata record defined in\n   * attachment_files.\n   */\n  data: IAttachmentFile[];\n};\n",
    "src/api/functional/bbs/articles/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticle } from \"../../../structures/IBbsArticle\";\nimport { IPageIBbsArticle } from \"../../../structures/IPageIBbsArticle\";\nexport * as snapshots from \"./snapshots\";\nexport * as comments from \"./comments\";\n\n/**\n * Create a new BBS article with initial snapshot and attachments (related to\n * 'bbs_articles' table).\n *\n * This API creates a new article in the 'bbs_articles' table with all required\n * fields, such as writer name, password (secure/encrypted), and creation time.\n * The body and title are stored in the initial record in\n * 'bbs_article_snapshots', while attached files are related via\n * 'bbs_article_snapshot_files'.\n *\n * Upon success, a new article is created with its first snapshot and\n * attachments, and all references are established. Security: password will be\n * encrypted in storage. Ensure all fields follow validations in the DB schema,\n * such as non-empty strings for essential fields, proper format for UUIDs, and\n * file URL validation. The operation is atomic—all-or-nothing if\n * file/attachment data is invalid.\n *\n * Related: PATCH /bbs/articles for article listing and GET /bbs/articles/{id}\n * for detail view.\n *\n * @param body New article's information, including writer, password,\n *   body/title, format, and attachments.\n * @path /bbs/articles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  body: post.Input,\n): Promise<post.Output> {\n  return !!connection.simulate\n    ? post.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace post {\n  export type Input = IBbsArticle.ICreate;\n  export type Output = IBbsArticle;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/articles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/articles\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsArticle =>\n    typia.random<IBbsArticle>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: post.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a list of BBS articles ('bbs_articles' table) with filtering,\n * search, and pagination.\n *\n * This API retrieves a paginated and filtered list of articles from the\n * 'bbs_articles' table. The endpoint should support standard search fields,\n * such as title, writer, or date range, reflecting the need for efficient\n * querying and performance optimization as outlined in the requirements.\n *\n * The response includes only the latest snapshot information (title, etc.) and\n * not the complete snapshot history for each article, consistent with index\n * usage and list performance needs. Security considerations include returning\n * only non-deleted articles to general users; deleted articles may be included\n * for admins based on role.\n *\n * Related operations: GET /bbs/articles/{id} for detail view, PATCH\n * /bbs/articles/{articleId}/snapshots for snapshots list, and CRUD operations\n * for creation, update, and deletion. Consider error handling for invalid\n * queries and paging boundaries.\n *\n * @param body Search criteria, filtering, sorting, and pagination for\n *   retrieving article list.\n * @path /bbs/articles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  body: patch.Input,\n): Promise<patch.Output> {\n  return !!connection.simulate\n    ? patch.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patch {\n  export type Input = IBbsArticle.IRequest;\n  export type Output = IPageIBbsArticle.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/articles\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsArticle.ISummary => typia.random<IPageIBbsArticle.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: patch.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get detail information of a specific BBS article ('bbs_articles' table),\n * including latest snapshot and attachments.\n *\n * This API provides detail for a single article from the 'bbs_articles' table,\n * identified by its UUID. Main output fields are writer, creation/deletion\n * time, the latest snapshot's title/body/format, and summary of attachments and\n * comments.\n *\n * Validation includes ensuring the article exists and is not deleted (for\n * general users), with soft-deleted articles only visible for admins/staff.\n * Response incorporates summarized comment count, facilitating user interface\n * efficiency. Error handling covers 'not found' and forbidden access on deleted\n * items.\n *\n * Related: PATCH /bbs/articles for lists, PATCH\n * /bbs/articles/{articleId}/snapshots for modification history.\n *\n * @param id UUID of the BBS article to retrieve.\n * @path /bbs/articles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getById.Output> {\n  return !!connection.simulate\n    ? getById.simulate(connection, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(id),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Output = IBbsArticle;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsArticle =>\n    typia.random<IBbsArticle>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a specific BBS article ('bbs_articles' table); creates a new snapshot\n * with attachments.\n *\n * This API modifies an existing BBS article. Upon update, password is verified\n * then a new snapshot is inserted in 'bbs_article_snapshots', containing the\n * revised title/body/format and new/updated attachments listed via\n * 'bbs_article_snapshot_files'.\n *\n * The original article's record in 'bbs_articles' is not overwritten; only new\n * snapshot/attachments are created to preserve evidence, as per requirements.\n * Security: password verification is strict, and all updates are timestamped.\n * All DB constraints and validation are applied (e.g., title, body not empty).\n *\n * Error cases include unauthorized access, not found, or validation failures.\n * The operation is atomic—either the snapshot and all attachments are created,\n * or none are.\n *\n * @param id UUID of the article to update.\n * @param body Updated article content, verified via password, with attachments\n *   list.\n * @path /bbs/articles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: putById.Input,\n): Promise<putById.Output> {\n  return !!connection.simulate\n    ? putById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putById {\n  export type Input = IBbsArticle.IUpdate;\n  export type Output = IBbsArticle;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsArticle =>\n    typia.random<IBbsArticle>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: putById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Soft-delete a specific article ('bbs_articles' table); sets 'deleted_at',\n * preserves evidence.\n *\n * This API marks an article as logically deleted (soft delete) by setting the\n * 'deleted_at' timestamp, per requirements. The request must provide password\n * verification.\n *\n * The operation does not alter existing snapshot or attachment file records,\n * preserving all evidence. Soft-deleted articles are hidden from non-admin\n * users. Security: password must match and be securely provided; deleted\n * articles remain retrievable by admins for audits if needed.\n *\n * Error scenarios: unauthorized/deletion of already deleted, or article not\n * found. Proper error is returned (e.g., forbidden, not found).\n *\n * @param id UUID of the article to delete.\n * @param body Password for verification prior to soft-deletion.\n * @path /bbs/articles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: eraseById.Input,\n): Promise<eraseById.Output> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace eraseById {\n  export type Input = IBbsArticle.IDelete;\n  export type Output = IBbsArticle;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsArticle =>\n    typia.random<IBbsArticle>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: eraseById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
    "src/api/functional/bbs/index.ts": "export * as articles from \"./articles\";\n",
    "src/api/functional//index.ts": "export * as bbs from \"./bbs\";\nexport * as attachmentFiles from \"./attachmentFiles\";\n",
    "src/api/functional/bbs/articles/snapshots/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticleSnapshot } from \"../../../../structures/IBbsArticleSnapshot\";\nimport { IPageIBbsArticleSnapshot } from \"../../../../structures/IPageIBbsArticleSnapshot\";\nexport * as files from \"./files\";\n\n/**\n * Get all revision snapshots for a given article ('bbs_article_snapshots'\n * table, by articleId), with pagination.\n *\n * This API lists all snapshots (modification revisions) for a specific article\n * from the 'bbs_article_snapshots' table using the article's ID. Each snapshot\n * includes title, body format, creation timestamp, ip address, and list of\n * attachment files for that version.\n *\n * Supports pagination, important for heavily-edited articles (for performance).\n * Access is generally open, but some security logic may be applied to deleted\n * or restricted articles.\n *\n * Related operations: PATCH /bbs/articles for lists, GET /bbs/articles/{id} for\n * details, GET /bbs/articles/{articleId}/snapshots/{id} for individual\n * revision.\n *\n * @param articleId UUID of the article whose snapshots are being listed.\n * @param body Optional pagination and filter parameters for snapshot history.\n * @path /bbs/articles/:articleId/snapshots\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByArticleid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  body: patchByArticleid.Input,\n): Promise<patchByArticleid.Output> {\n  return !!connection.simulate\n    ? patchByArticleid.simulate(connection, articleId, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByArticleid.METADATA,\n          path: patchByArticleid.path(articleId),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patchByArticleid {\n  export type Input = IBbsArticleSnapshot.IRequest;\n  export type Output = IPageIBbsArticleSnapshot;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles/:articleId/snapshots\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (articleId: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/snapshots`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsArticleSnapshot => typia.random<IPageIBbsArticleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    body: patchByArticleid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByArticleid.path(articleId),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get detail of a specific snapshot for a given article\n * ('bbs_article_snapshots' table, by articleId and snapshotId).\n *\n * This API fetches a single snapshot (revision) of a given article using both\n * IDs. The response includes the title, body, format, ip address, and the list\n * of related attachments stored at the time of this revision. Used for\n * auditing, difference viewing, or legal evidence of changes.\n *\n * Security checks ensure access to the underlying article. If the snapshot does\n * not exist or is not linked to the specified article, a 'not found' is\n * returned. No soft-delete applies to originals here; evidence is never\n * removed.\n *\n * Related: PATCH /bbs/articles/{articleId}/snapshots for revision history.\n *\n * @param articleId UUID of the article to which the snapshot belongs.\n * @param id UUID of the snapshot to fetch.\n * @path /bbs/articles/:articleId/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByArticleidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getByArticleidAndId.Output> {\n  return !!connection.simulate\n    ? getByArticleidAndId.simulate(connection, articleId, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByArticleidAndId.METADATA,\n          path: getByArticleidAndId.path(articleId, id),\n          status: null,\n        },\n      );\n}\nexport namespace getByArticleidAndId {\n  export type Output = IBbsArticleSnapshot;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/:articleId/snapshots/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleSnapshot => typia.random<IBbsArticleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByArticleidAndId.path(articleId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update content or metadata of a specific article snapshot\n * ('bbs_article_snapshots' table, by articleId and snapshotId); admin/system\n * only.\n *\n * This API updates a snapshot 'bbs_article_snapshots' record. Normally,\n * snapshot changes are forbidden for users (evidence preservation), but certain\n * admin/system roles may execute corrections (e.g., unlawful content, typo\n * fix). Updates may include modifications to title, body, format, or attachment\n * relations; logs must track all changes for auditing.\n *\n * Security: restricted to admins or evidence maintainers. Standard validations\n * apply, and revert possible for audit reasons. Related to PATCH\n * /bbs/articles/{articleId}/snapshots.\n *\n * @param articleId UUID of the article containing the snapshot.\n * @param id UUID of the snapshot to update.\n * @param body Snapshot fields to update (title/body/attachments/format).\n *   Usually only by admin/system.\n * @path /bbs/articles/:articleId/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByArticleidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n  body: putByArticleidAndId.Input,\n): Promise<putByArticleidAndId.Output> {\n  return !!connection.simulate\n    ? putByArticleidAndId.simulate(connection, articleId, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByArticleidAndId.METADATA,\n          path: putByArticleidAndId.path(articleId, id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putByArticleidAndId {\n  export type Input = IBbsArticleSnapshot.IUpdate;\n  export type Output = IBbsArticleSnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:articleId/snapshots/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleSnapshot => typia.random<IBbsArticleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n    body: putByArticleidAndId.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByArticleidAndId.path(articleId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Logically delete a snapshot of an article ('bbs_article_snapshots'),\n * admin/system only, for evidence management.\n *\n * This API marks a specific article snapshot as deleted (logically), removing\n * it from default user access. The actual snapshot record is not physically\n * deleted, preserving historical evidence and references, but a status or\n * timestamp is set as deleted.\n *\n * Security: strictly restricted to admin/system users. Normal users cannot\n * delete snapshots (only create new ones for revisions). Soft-deleted snapshots\n * may be included in audit/admin views with proper roles.\n *\n * Related: PATCH /bbs/articles/{articleId}/snapshots for revisions, GET\n * /bbs/articles/{articleId}/snapshots/{id} for detail.\n *\n * @param articleId UUID of the article containing the snapshot.\n * @param id UUID of the snapshot to delete.\n * @param body Credentials or reason for deletion (admin/system use only).\n * @path /bbs/articles/:articleId/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByArticleidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n  body: eraseByArticleidAndId.Input,\n): Promise<eraseByArticleidAndId.Output> {\n  return !!connection.simulate\n    ? eraseByArticleidAndId.simulate(connection, articleId, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByArticleidAndId.METADATA,\n          path: eraseByArticleidAndId.path(articleId, id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace eraseByArticleidAndId {\n  export type Input = IBbsArticleSnapshot.IDelete;\n  export type Output = IBbsArticleSnapshot;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/:articleId/snapshots/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleSnapshot => typia.random<IBbsArticleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n    body: eraseByArticleidAndId.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByArticleidAndId.path(articleId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
    "src/api/functional/bbs/articles/snapshots/files/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticleSnapshotFile } from \"../../../../../structures/IBbsArticleSnapshotFile\";\nimport { IPageIBbsArticleSnapshotFile } from \"../../../../../structures/IPageIBbsArticleSnapshotFile\";\n\n/**\n * Attach one or more files to a specific snapshot of an article\n * ('bbs_article_snapshot_files'), returning updated file list.\n *\n * This API attaches files to a specific article snapshot. It accepts file IDs\n * (already uploaded via separate process) or requires necessary file metadata\n * if uploading new files. For existing files, establishes the link via\n * 'bbs_article_snapshot_files'; for new uploads, creates a file record in\n * 'attachment_files' then associates it.\n *\n * Sequence/order is essential (for display order). Validation checks that files\n * exist or are newly proper. Security: normal user edits require proper\n * authentication; admin/system roles may bypass restrictions for\n * evidence.</br>\n *\n * Returns updated list of attachments, with all associated metadata for the\n * snapshot. Related: PATCH for updating the order, DELETE for deleting\n * attachments.\n *\n * @param articleId UUID of the article of the snapshot being modified.\n * @param snapshotId UUID of the snapshot to attach files to.\n * @param body Attachment file information to link/upload for this snapshot,\n *   plus order.\n * @path /bbs/articles/:articleId/snapshots/:snapshotId/files\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByArticleidAndSnapshotid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  body: postByArticleidAndSnapshotid.Input,\n): Promise<postByArticleidAndSnapshotid.Output> {\n  return !!connection.simulate\n    ? postByArticleidAndSnapshotid.simulate(\n        connection,\n        articleId,\n        snapshotId,\n        body,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByArticleidAndSnapshotid.METADATA,\n          path: postByArticleidAndSnapshotid.path(articleId, snapshotId),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace postByArticleidAndSnapshotid {\n  export type Input = IBbsArticleSnapshotFile.ICreate;\n  export type Output = IPageIBbsArticleSnapshotFile;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/articles/:articleId/snapshots/:snapshotId/files\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsArticleSnapshotFile =>\n    typia.random<IPageIBbsArticleSnapshotFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    body: postByArticleidAndSnapshotid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByArticleidAndSnapshotid.path(articleId, snapshotId),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List all attachment files for a specific article snapshot (by\n * articleId/snapshotId), using 'bbs_article_snapshot_files'.\n *\n * This API fetches all files attached to a specific revision (snapshot) of an\n * article. Filters on articleId and snapshotId provide the explicit context to\n * retrieve sequence/order of files, file metadata (name, extension, URL,\n * creation time, sequence). Pagination can be included for snapshots with many\n * files.\n *\n * Related operations: POST for attaching new files to a revision, DELETE for\n * removing files, PATCH for reordering/updating attachment list.\n *\n * Attachment files must be publicly accessible (with proper security tokens if\n * required).\n *\n * @param articleId UUID of the article of the snapshot.\n * @param snapshotId UUID of the article snapshot whose files are being listed.\n * @param body Options for filtering or paging attached files for this snapshot.\n * @path /bbs/articles/:articleId/snapshots/:snapshotId/files\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByArticleidAndSnapshotid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  body: patchByArticleidAndSnapshotid.Input,\n): Promise<patchByArticleidAndSnapshotid.Output> {\n  return !!connection.simulate\n    ? patchByArticleidAndSnapshotid.simulate(\n        connection,\n        articleId,\n        snapshotId,\n        body,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByArticleidAndSnapshotid.METADATA,\n          path: patchByArticleidAndSnapshotid.path(articleId, snapshotId),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patchByArticleidAndSnapshotid {\n  export type Input = IBbsArticleSnapshotFile.IRequest;\n  export type Output = IPageIBbsArticleSnapshotFile;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles/:articleId/snapshots/:snapshotId/files\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsArticleSnapshotFile =>\n    typia.random<IPageIBbsArticleSnapshotFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    body: patchByArticleidAndSnapshotid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByArticleidAndSnapshotid.path(articleId, snapshotId),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a specific attached file (bbs_article_snapshot_files) in a snapshot of an\n * article.\n *\n * This GET operation retrieves a particular file attached to a specific\n * snapshot of an article in the bulletin board system.\n *\n * The endpoint path parameters (articleId, snapshotId, id) represent the\n * article UUID, the snapshot UUID, and the file attachment relation UUID\n * (bbs_article_snapshot_files.id) respectively. This strict mapping ensures the\n * file's association is under the correct article version, upholding\n * evidentiary record accuracy as described in the requirements.\n *\n * Security considerations include verifying the logical existence of the parent\n * article and snapshot (not deleted), and checking the user's permission for\n * file access.\n *\n * Returns metadata about the attachment (order, file metadata, and URL for\n * download). Relies on the correct structure and associations as maintained\n * within the attachment_files and bbs_article_snapshot_files Prisma models.\n *\n * Handles errors such as not-found (404) if any ancestor entity does not exist\n * or is inaccessible, and forbidden (403) for unauthorized access attempts.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param snapshotId Target snapshot ID (UUID) in bbs_article_snapshots\n * @param id Attachment relation ID in bbs_article_snapshot_files\n * @path /bbs/articles/:articleId/snapshots/:snapshotId/files/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByArticleidAndSnapshotidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getByArticleidAndSnapshotidAndId.Output> {\n  return !!connection.simulate\n    ? getByArticleidAndSnapshotidAndId.simulate(\n        connection,\n        articleId,\n        snapshotId,\n        id,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByArticleidAndSnapshotidAndId.METADATA,\n          path: getByArticleidAndSnapshotidAndId.path(\n            articleId,\n            snapshotId,\n            id,\n          ),\n          status: null,\n        },\n      );\n}\nexport namespace getByArticleidAndSnapshotidAndId {\n  export type Output = IBbsArticleSnapshotFile;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/:articleId/snapshots/:snapshotId/files/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleSnapshotFile => typia.random<IBbsArticleSnapshotFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByArticleidAndSnapshotidAndId.path(articleId, snapshotId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update attachment file entry (bbs_article_snapshot_files) metadata for a\n * given article snapshot.\n *\n * This PUT operation updates the mapping information for a specific file\n * attached to an article snapshot. A typical use case includes resequencing\n * file orders or changing ancillary metadata about this attachment (the file\n * itself is immutable for evidence, but linkage/metadata can change for the\n * active revision).\n *\n * Requires verification of the parent article (not deleted), parent snapshot,\n * and correct ownership/permissions, as defined by the evidentiary and logical\n * deletion model.\n *\n * The request body structure corresponds to updates for the\n * 'bbs_article_snapshot_files' record, such as sequence reordering.\n *\n * Update is restricted to the targeted relation and does not affect historical\n * data in previous snapshots.\n *\n * Handles error states including not-found for any path element, permission\n * denial, and validation for business rules (e.g., not modifying a\n * locked/evidence snapshot).\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param snapshotId Target snapshot ID (UUID) in bbs_article_snapshots\n * @param id Attachment relation ID in bbs_article_snapshot_files\n * @param body Info to update the attached file relation (e.g., sequence order)\n *   in a snapshot.\n * @path /bbs/articles/:articleId/snapshots/:snapshotId/files/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByArticleidAndSnapshotidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n  body: putByArticleidAndSnapshotidAndId.Input,\n): Promise<putByArticleidAndSnapshotidAndId.Output> {\n  return !!connection.simulate\n    ? putByArticleidAndSnapshotidAndId.simulate(\n        connection,\n        articleId,\n        snapshotId,\n        id,\n        body,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByArticleidAndSnapshotidAndId.METADATA,\n          path: putByArticleidAndSnapshotidAndId.path(\n            articleId,\n            snapshotId,\n            id,\n          ),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putByArticleidAndSnapshotidAndId {\n  export type Input = IBbsArticleSnapshotFile.IUpdate;\n  export type Output = IBbsArticleSnapshotFile;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:articleId/snapshots/:snapshotId/files/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleSnapshotFile => typia.random<IBbsArticleSnapshotFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n    body: putByArticleidAndSnapshotidAndId.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByArticleidAndSnapshotidAndId.path(articleId, snapshotId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Delete (logically unlink) a file from a snapshot (bbs_article_snapshot_files)\n * of an article.\n *\n * This DELETE operation logically removes (unlinks) an attachment file from a\n * specific article snapshot in the system. The operation targets the entry in\n * 'bbs_article_snapshot_files', marking it as logically deleted if required by\n * implementation, while preserving evidence as per requirements.\n *\n * Deleted file entries should no longer display for the target snapshot, but\n * all historical records and actual file data are preserved for audit and\n * evidence. Parent entity existence (article, snapshot) and permissions are\n * always validated.\n *\n * This operation may trigger side-effects such as reordering remaining files or\n * revising display metadata for the snapshot, but never deletes actual file\n * content.\n *\n * Errors handled include not-found for non-existing entities or relations,\n * permission denial, and violation of audit-evidence policies.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param snapshotId Target snapshot ID (UUID) in bbs_article_snapshots\n * @param id Attachment relation ID in bbs_article_snapshot_files\n * @path /bbs/articles/:articleId/snapshots/:snapshotId/files/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByArticleidAndSnapshotidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<eraseByArticleidAndSnapshotidAndId.Output> {\n  return !!connection.simulate\n    ? eraseByArticleidAndSnapshotidAndId.simulate(\n        connection,\n        articleId,\n        snapshotId,\n        id,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByArticleidAndSnapshotidAndId.METADATA,\n          path: eraseByArticleidAndSnapshotidAndId.path(\n            articleId,\n            snapshotId,\n            id,\n          ),\n          status: null,\n        },\n      );\n}\nexport namespace eraseByArticleidAndSnapshotidAndId {\n  export type Output = IBbsArticleSnapshotFile;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/:articleId/snapshots/:snapshotId/files/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleSnapshotFile => typia.random<IBbsArticleSnapshotFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByArticleidAndSnapshotidAndId.path(articleId, snapshotId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
    "src/api/functional/bbs/articles/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticleComment } from \"../../../../structures/IBbsArticleComment\";\nimport { IPageBbsArticleComment } from \"../../../../structures/IPageBbsArticleComment\";\nexport * as snapshots from \"./snapshots\";\n\n/**\n * Create a new comment (bbs_article_comments) on an article.\n *\n * This POST operation creates a new comment on a specific article in the\n * bulletin board system. New comments must include required fields such as\n * writer, password, and initial content, referenced by a parentId if this is a\n * reply to another comment (enables hierarchical threading).\n *\n * The operation first creates an entry in 'bbs_article_comments', then creates\n * an initial bbs_article_comment_snapshots record with the comment's content.\n * If files are attached, relevant mapping records are also created in\n * bbs_article_comment_snapshot_files and attachment_files.\n *\n * Enforces password hashing, IP logging, timestamp recording, and initializes\n * all evidence features.\n *\n * Handles validation errors (missing fields), permission enforcement, and\n * ensures parent entities exist (article, parent comment if reply). Responds\n * with the created comment structure, including snapshot references and\n * attachment linkage.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param body Comment creation input for bbs_article_comments, including\n *   parentId, writer, password, and initial content.\n * @path /bbs/articles/:articleId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByArticleid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  body: postByArticleid.Input,\n): Promise<postByArticleid.Output> {\n  return !!connection.simulate\n    ? postByArticleid.simulate(connection, articleId, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByArticleid.METADATA,\n          path: postByArticleid.path(articleId),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace postByArticleid {\n  export type Input = IBbsArticleComment.ICreate;\n  export type Output = IBbsArticleComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/articles/:articleId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (articleId: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    body: postByArticleid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByArticleid.path(articleId),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List all comments (bbs_article_comments) for an article, with search/filter.\n *\n * This PATCH operation fetches a paginated and searchable list of all comments\n * related to a specific article, as defined in the requirements (nested\n * structure, logical deletion, evidence). Search criteria can include author\n * fields, timestamp range, parent/child linkage for hierarchical display, etc.\n *\n * Results present only comments not logically deleted for public users. Admins\n * may access deleted items with proper authorization.\n *\n * Handles edge cases such as no results, excessive pagination, and filter\n * security. Data comes from the 'bbs_article_comments' table, potentially\n * joined with the latest comment snapshot for list views.\n *\n * Fails with 404 if article doesn't exist, or appropriate error for permission\n * issues.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param body Parameters for searching, filtering, and pagination for comment\n *   list.\n * @path /bbs/articles/:articleId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByArticleid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  body: patchByArticleid.Input,\n): Promise<patchByArticleid.Output> {\n  return !!connection.simulate\n    ? patchByArticleid.simulate(connection, articleId, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByArticleid.METADATA,\n          path: patchByArticleid.path(articleId),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patchByArticleid {\n  export type Input = IBbsArticleComment.IRequest;\n  export type Output = IPageBbsArticleComment;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles/:articleId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (articleId: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageBbsArticleComment => typia.random<IPageBbsArticleComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    body: patchByArticleid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByArticleid.path(articleId),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a specific comment (bbs_article_comments) within an article by ID.\n *\n * This GET operation retrieves a single comment by its unique identifier,\n * attached to a specific article. It pulls data from 'bbs_article_comments',\n * confirming article and comment association, and validates that the comment is\n * not logically deleted for public views.\n *\n * Inherited relationships allow easy nesting for replies. The result returns\n * only top-level comment record info (writer, timestamps, parent,\n * etc)–attachable snapshots and files are accessed through other APIs.\n *\n * Permission and logical deletion rules are enforced: only non-deleted comments\n * are shown publicly, while admins may retrieve deleted comments for evidence\n * or audit purposes.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param id Target comment ID (UUID) in bbs_article_comments\n * @path /bbs/articles/:articleId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByArticleidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getByArticleidAndId.Output> {\n  return !!connection.simulate\n    ? getByArticleidAndId.simulate(connection, articleId, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByArticleidAndId.METADATA,\n          path: getByArticleidAndId.path(articleId, id),\n          status: null,\n        },\n      );\n}\nexport namespace getByArticleidAndId {\n  export type Output = IBbsArticleComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/:articleId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByArticleidAndId.path(articleId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update a specific comment (metadata/relationships) in bbs_article_comments\n * within an article.\n *\n * This PUT operation modifies a comment on a given article, addressing certain\n * updatable fields in 'bbs_article_comments' such as writer, password, or\n * parentId (for reply/nesting structure). The revision of contents (body) is\n * handled by subsequent snapshot creation in a nested or parallel API.\n *\n * Updates trigger standard evidence retention (audit trails, password\n * verification), and may affect hierarchical threading. Parent entity existence\n * must be verified. Logical deletion rules and permissions apply – deleted\n * comments cannot be modified by typical users.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param id Target comment ID (UUID) in bbs_article_comments\n * @param body Details for comments update, including writer, password, or\n *   parentId for nesting.\n * @path /bbs/articles/:articleId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByArticleidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n  body: putByArticleidAndId.Input,\n): Promise<putByArticleidAndId.Output> {\n  return !!connection.simulate\n    ? putByArticleidAndId.simulate(connection, articleId, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByArticleidAndId.METADATA,\n          path: putByArticleidAndId.path(articleId, id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putByArticleidAndId {\n  export type Input = IBbsArticleComment.IUpdate;\n  export type Output = IBbsArticleComment;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:articleId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n    body: putByArticleidAndId.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByArticleidAndId.path(articleId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Logically delete (soft-delete) a comment (bbs_article_comments) from an\n * article.\n *\n * This DELETE operation performs a logical (soft) deletion of a comment on a\n * given article. Instead of removing the record from 'bbs_article_comments',\n * the 'deleted_at' timestamp is set to the current time (soft delete),\n * preserving audit trails for evidence and dispute resolution as mandated by\n * system requirements.\n *\n * Checks that the targeted comment exists, is not already deleted, and that any\n * user access or password verification requirements are satisfied. Deleted\n * comments are excluded from public retrieval but available for evidence by\n * administrators.\n *\n * Handles not-found, already-deleted, and access-denial errors appropriately.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param id Target comment ID (UUID) in bbs_article_comments\n * @path /bbs/articles/:articleId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByArticleidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<eraseByArticleidAndId.Output> {\n  return !!connection.simulate\n    ? eraseByArticleidAndId.simulate(connection, articleId, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByArticleidAndId.METADATA,\n          path: eraseByArticleidAndId.path(articleId, id),\n          status: null,\n        },\n      );\n}\nexport namespace eraseByArticleidAndId {\n  export type Output = IBbsArticleComment;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/:articleId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByArticleidAndId.path(articleId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
    "src/api/functional/bbs/articles/comments/snapshots/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticleCommentSnapshot } from \"../../../../../structures/IBbsArticleCommentSnapshot\";\nimport { IPageBbsArticleCommentSnapshot } from \"../../../../../structures/IPageBbsArticleCommentSnapshot\";\nexport * as files from \"./files\";\n\n/**\n * List all snapshots (bbs_article_comment_snapshots) for a comment on an\n * article, with search/pagination.\n *\n * This PATCH operation retrieves all snapshots (revision history) for a given\n * comment attached to an article. Returns paginated and/or filtered results,\n * including metadata such as format, timestamp, author IP, and relevant\n * attachments (linkage only). This allows evidence presentation and rollback\n * investigation for all comment changes.\n *\n * Access is restricted depending on logical deletion status and permissions\n * (admins vs. general users). Snapshots provide information for audit, dispute\n * resolution, or version comparison in the UI.\n *\n * Handles errors for invalid parameters, not-found comment/article ancestors,\n * and respects maximum page size/policy limits.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param commentId Comment ID in bbs_article_comments to which the snapshots\n *   belong\n * @param body Parameters for searching, pagination, and filtering of comment\n *   snapshots.\n * @path /bbs/articles/:articleId/comments/:commentId/snapshots\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByArticleidAndCommentid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  commentId: string & tags.Format<\"uuid\">,\n  body: patchByArticleidAndCommentid.Input,\n): Promise<patchByArticleidAndCommentid.Output> {\n  return !!connection.simulate\n    ? patchByArticleidAndCommentid.simulate(\n        connection,\n        articleId,\n        commentId,\n        body,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByArticleidAndCommentid.METADATA,\n          path: patchByArticleidAndCommentid.path(articleId, commentId),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patchByArticleidAndCommentid {\n  export type Input = IBbsArticleCommentSnapshot.IRequest;\n  export type Output = IPageBbsArticleCommentSnapshot;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles/:articleId/comments/:commentId/snapshots\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(commentId ?? \"null\")}/snapshots`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageBbsArticleCommentSnapshot =>\n    typia.random<IPageBbsArticleCommentSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    body: patchByArticleidAndCommentid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByArticleidAndCommentid.path(articleId, commentId),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"commentId\")(() => typia.assert(commentId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieve a specific comment snapshot (bbs_article_comment_snapshots) for a\n * given comment on an article.\n *\n * This GET operation retrieves a single revision snapshot for a comment\n * (bbs_article_comment_snapshots). The snapshot is uniquely identified by its\n * attachment to a specific article, comment, and snapshot UUID.\n *\n * Returns detailed information about the snapshot content, including format,\n * body, creation metadata, author IP, and file attachments (linkage only —\n * actual files accessed through separate API calls).\n *\n * Fails with not-found errors if any identified entity does not exist or is not\n * accessible, and enforces necessary permissions and logical deletion rules.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param commentId Comment ID in bbs_article_comments to which the snapshot\n *   belongs\n * @param id Comment snapshot ID (UUID) in bbs_article_comment_snapshots\n * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByArticleidAndCommentidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  commentId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getByArticleidAndCommentidAndId.Output> {\n  return !!connection.simulate\n    ? getByArticleidAndCommentidAndId.simulate(\n        connection,\n        articleId,\n        commentId,\n        id,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByArticleidAndCommentidAndId.METADATA,\n          path: getByArticleidAndCommentidAndId.path(articleId, commentId, id),\n          status: null,\n        },\n      );\n}\nexport namespace getByArticleidAndCommentidAndId {\n  export type Output = IBbsArticleCommentSnapshot;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/:articleId/comments/:commentId/snapshots/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(commentId ?? \"null\")}/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleCommentSnapshot => typia.random<IBbsArticleCommentSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByArticleidAndCommentidAndId.path(articleId, commentId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"commentId\")(() => typia.assert(commentId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update content or metadata for a specific comment snapshot\n * (bbs_article_comment_snapshots) by ID.\n *\n * This PUT operation updates metadata or content for a particular comment\n * snapshot in the evidence system. While general edits typically create new\n * snapshots, this can allow corrections under special administrative\n * circumstances, for evidence correction or dispute resolution.\n *\n * Accepts content (body), format, and possibly file association adjustments.\n * Must strictly validate parent article and comment, existing snapshot, and\n * business rules for evidentiary control — typical users may not be allowed\n * unless it's for error correction or privileged access.\n *\n * Side-effects are limited to only the indicated snapshot; evidence/integrity\n * must be preserved.\n *\n * @param articleId Target article ID (UUID) in bbs_articles\n * @param commentId Comment ID in bbs_article_comments to which the snapshot\n *   belongs\n * @param id Comment snapshot ID (UUID) in bbs_article_comment_snapshots\n * @param body The content, format, or attachment linkage updates for this\n *   comment snapshot.\n * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByArticleidAndCommentidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  commentId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n  body: putByArticleidAndCommentidAndId.Input,\n): Promise<putByArticleidAndCommentidAndId.Output> {\n  return !!connection.simulate\n    ? putByArticleidAndCommentidAndId.simulate(\n        connection,\n        articleId,\n        commentId,\n        id,\n        body,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByArticleidAndCommentidAndId.METADATA,\n          path: putByArticleidAndCommentidAndId.path(articleId, commentId, id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putByArticleidAndCommentidAndId {\n  export type Input = IBbsArticleCommentSnapshot.IUpdate;\n  export type Output = IBbsArticleCommentSnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:articleId/comments/:commentId/snapshots/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(commentId ?? \"null\")}/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleCommentSnapshot => typia.random<IBbsArticleCommentSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n    body: putByArticleidAndCommentidAndId.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByArticleidAndCommentidAndId.path(articleId, commentId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"commentId\")(() => typia.assert(commentId));\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Logically deletes a comment snapshot (bbs_article_comment_snapshots) by ID,\n * nested under specific article and comment, as per evidence-preservation\n * policy.\n *\n * This operation enables the logical deletion (soft delete) of a comment\n * snapshot record in the bbs_article_comment_snapshots table, nested under a\n * specific comment within a specific article. According to the system's\n * requirements for evidence preservation, this operation sets a deleted flag or\n * timestamp field (rather than actually removing any history data) to make the\n * snapshot invisible to regular end users but still retained in the system for\n * administrative/audit purposes.\n *\n * The operation involves several security considerations: only users with the\n * correct password or administrators can perform deletions; IP addresses and\n * audit trail information remain intact for compliance. The operation will fail\n * if provided IDs do not correspond to existing entities.\n *\n * This endpoint should be used only when absolutely necessary, such as in\n * compliance with legal requirements or gross abuse. Otherwise, all history\n * should remain permanently retained.\n *\n * @param articleId Target article's ID\n * @param commentId Target comment's ID\n * @param id Target comment snapshot's ID\n * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByArticleidAndCommentidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  commentId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseByArticleidAndCommentidAndId.simulate(\n        connection,\n        articleId,\n        commentId,\n        id,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByArticleidAndCommentidAndId.METADATA,\n          path: eraseByArticleidAndCommentidAndId.path(\n            articleId,\n            commentId,\n            id,\n          ),\n          status: null,\n        },\n      );\n}\nexport namespace eraseByArticleidAndCommentidAndId {\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/:articleId/comments/:commentId/snapshots/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(commentId ?? \"null\")}/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByArticleidAndCommentidAndId.path(articleId, commentId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"commentId\")(() => typia.assert(commentId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
    "src/api/functional/bbs/articles/comments/snapshots/files/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { ICommentSnapshotFile } from \"../../../../../../structures/ICommentSnapshotFile\";\n\n/**\n * Associates new file(s) with a comment snapshot\n * (bbs_article_comment_snapshot_files), specifying attachment and order.\n *\n * This endpoint enables the creation/association of one or several attachment\n * files to a given comment snapshot (reference\n * bbs_article_comment_snapshot_files in schema). File IDs must be valid and\n * refer to pre-uploaded resources defined in attachment_files. The request body\n * (ICommentSnapshotFile.ICreate) allows specification of the file(s) to attach\n * and their display sequence/order, in accordance with UX/UI requirements.\n *\n * Upon success, the endpoint returns the new relationship(s) and order in the\n * response type. All additions occur in a database transaction. Proper\n * authentication, permission, and validation against duplicate/illegal\n * operations are required. Usage of this endpoint is fundamental to supporting\n * evidence‐preserving file associations in comment histories.\n *\n * @param articleId Target article's ID\n * @param commentId Target comment's ID\n * @param snapshotId Target comment snapshot's ID\n * @param body Association info (file IDs and any sequence/order) for new\n *   attachments to the comment snapshot.\n * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByArticleidAndCommentidAndSnapshotid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  commentId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  body: postByArticleidAndCommentidAndSnapshotid.Input,\n): Promise<postByArticleidAndCommentidAndSnapshotid.Output> {\n  return !!connection.simulate\n    ? postByArticleidAndCommentidAndSnapshotid.simulate(\n        connection,\n        articleId,\n        commentId,\n        snapshotId,\n        body,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByArticleidAndCommentidAndSnapshotid.METADATA,\n          path: postByArticleidAndCommentidAndSnapshotid.path(\n            articleId,\n            commentId,\n            snapshotId,\n          ),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace postByArticleidAndCommentidAndSnapshotid {\n  export type Input = ICommentSnapshotFile.ICreate;\n  export type Output = ICommentSnapshotFile;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(commentId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): ICommentSnapshotFile => typia.random<ICommentSnapshotFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    body: postByArticleidAndCommentidAndSnapshotid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByArticleidAndCommentidAndSnapshotid.path(\n        articleId,\n        commentId,\n        snapshotId,\n      ),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"commentId\")(() => typia.assert(commentId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Partially updates attachment files (bbs_article_comment_snapshot_files) for a\n * specific comment snapshot, with support for sequence/order changes.\n *\n * This endpoint provides partial update capability for attachment files on a\n * specific comment snapshot, using a request body referencing\n * ICommentSnapshotFile.IRequest or a similar input type. The underlying table\n * is the bbs_article_comment_snapshot_files, which is responsible for\n * maintaining the association and sequence of each file for each snapshot.\n *\n * Request validation ensures atomicity and transactional integrity: all\n * add/remove/order changes are applied in a single transaction. Each update\n * respects the unique sequence field to preserve file display order, a feature\n * critical for end-user UX. Security checks must ensure that users have\n * permission to alter the snapshot (password check/admin rights), and\n * operations must be logged for audit. Related endpoints for attachment_files\n * management should be referenced for holistic file lifecycle control.\n *\n * @param articleId Target article's ID\n * @param commentId Target comment's ID\n * @param snapshotId Target comment snapshot's ID\n * @param body Partial update info with the new and/or reordered list of\n *   attachment files for the comment snapshot.\n * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByArticleidAndCommentidAndSnapshotid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  commentId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  body: patchByArticleidAndCommentidAndSnapshotid.Input,\n): Promise<patchByArticleidAndCommentidAndSnapshotid.Output> {\n  return !!connection.simulate\n    ? patchByArticleidAndCommentidAndSnapshotid.simulate(\n        connection,\n        articleId,\n        commentId,\n        snapshotId,\n        body,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByArticleidAndCommentidAndSnapshotid.METADATA,\n          path: patchByArticleidAndCommentidAndSnapshotid.path(\n            articleId,\n            commentId,\n            snapshotId,\n          ),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patchByArticleidAndCommentidAndSnapshotid {\n  export type Input = ICommentSnapshotFile.IRequest;\n  export type Output = ICommentSnapshotFile.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(commentId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): ICommentSnapshotFile.ISummary =>\n    typia.random<ICommentSnapshotFile.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    body: patchByArticleidAndCommentidAndSnapshotid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByArticleidAndCommentidAndSnapshotid.path(\n        articleId,\n        commentId,\n        snapshotId,\n      ),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"commentId\")(() => typia.assert(commentId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieves a specific attached file (bbs_article_comment_snapshot_files) for a\n * comment snapshot, with file metadata and order.\n *\n * Fetch comprehensive metadata and relational info for a specific attachment\n * file linked to a given comment snapshot. This involves joining\n * bbs_article_comment_snapshot_files to bbs_article_comment_snapshots and\n * attachment_files entities. The response provides display order (sequence),\n * file name, extension, and URL for download/display purposes. Logical\n * deletion/visibility rules apply as per system evidence-retaining policy, and\n * audit trails/documentation should describe how to acquire both current and\n * historical attachment file relationships.\n *\n * @param articleId Target article's ID\n * @param commentId Target comment's ID\n * @param snapshotId Target comment snapshot's ID\n * @param id Target attachment relation (bbs_article_comment_snapshot_files.id)\n * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByArticleidAndCommentidAndSnapshotidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  commentId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getByArticleidAndCommentidAndSnapshotidAndId.Output> {\n  return !!connection.simulate\n    ? getByArticleidAndCommentidAndSnapshotidAndId.simulate(\n        connection,\n        articleId,\n        commentId,\n        snapshotId,\n        id,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByArticleidAndCommentidAndSnapshotidAndId.METADATA,\n          path: getByArticleidAndCommentidAndSnapshotidAndId.path(\n            articleId,\n            commentId,\n            snapshotId,\n            id,\n          ),\n          status: null,\n        },\n      );\n}\nexport namespace getByArticleidAndCommentidAndSnapshotidAndId {\n  export type Output = ICommentSnapshotFile;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(commentId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): ICommentSnapshotFile => typia.random<ICommentSnapshotFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByArticleidAndCommentidAndSnapshotidAndId.path(\n        articleId,\n        commentId,\n        snapshotId,\n        id,\n      ),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"commentId\")(() => typia.assert(commentId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Updates order/association data for an attached file\n * (bbs_article_comment_snapshot_files) for a comment snapshot.\n *\n * This operation enables updating the relationship data between a comment\n * snapshot and an attached file by modifying the join table record\n * (bbs_article_comment_snapshot_files). It's primarily for changing the file's\n * display order (sequence) or other association-specific metadata. The request\n * body conforms to ICommentSnapshotFile.IUpdate. This operation does not affect\n * the physical file resource stored in attachment_files; use the dedicated API\n * for file asset updates.\n *\n * Permission and integrity checks are necessary; only authorized users can\n * update attachment associations. Related endpoints for partial update and file\n * creation/deletion should be referenced for a complete file management\n * lifecycle.\n *\n * @param articleId Target article's ID\n * @param commentId Target comment's ID\n * @param snapshotId Target comment snapshot's ID\n * @param id Target attachment relation (bbs_article_comment_snapshot_files.id)\n * @param body Update information, typically just the sequence/order, for the\n *   attached file association.\n * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByArticleidAndCommentidAndSnapshotidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  commentId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n  body: putByArticleidAndCommentidAndSnapshotidAndId.Input,\n): Promise<putByArticleidAndCommentidAndSnapshotidAndId.Output> {\n  return !!connection.simulate\n    ? putByArticleidAndCommentidAndSnapshotidAndId.simulate(\n        connection,\n        articleId,\n        commentId,\n        snapshotId,\n        id,\n        body,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByArticleidAndCommentidAndSnapshotidAndId.METADATA,\n          path: putByArticleidAndCommentidAndSnapshotidAndId.path(\n            articleId,\n            commentId,\n            snapshotId,\n            id,\n          ),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putByArticleidAndCommentidAndSnapshotidAndId {\n  export type Input = ICommentSnapshotFile.IUpdate;\n  export type Output = ICommentSnapshotFile;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(commentId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): ICommentSnapshotFile => typia.random<ICommentSnapshotFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n    body: putByArticleidAndCommentidAndSnapshotidAndId.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByArticleidAndCommentidAndSnapshotidAndId.path(\n        articleId,\n        commentId,\n        snapshotId,\n        id,\n      ),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"commentId\")(() => typia.assert(commentId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Deletes a comment snapshot's file association\n * (bbs_article_comment_snapshot_files) by record ID, keeping asset file\n * intact.\n *\n * This endpoint removes the association between a specific attachment file and\n * a comment snapshot by deleting the join table record\n * (bbs_article_comment_snapshot_files). The file asset remains in the system\n * unless explicitly deleted elsewhere. All deletions must be authorized by\n * permissions consistent with the evidence retention policy. Cascade rules in\n * Prisma model keep referential integrity; access is restricted to users with\n * modification/review rights.\n *\n * This operation supports the requirement that, although all evidence must be\n * preserved, attachment relationships may sometimes be retracted per user\n * request or content update, but full delete of history is by exception only.\n *\n * @param articleId Target article's ID\n * @param commentId Target comment's ID\n * @param snapshotId Target comment snapshot's ID\n * @param id Target attachment relation (bbs_article_comment_snapshot_files.id)\n * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByArticleidAndCommentidAndSnapshotidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  commentId: string & tags.Format<\"uuid\">,\n  snapshotId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseByArticleidAndCommentidAndSnapshotidAndId.simulate(\n        connection,\n        articleId,\n        commentId,\n        snapshotId,\n        id,\n      )\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByArticleidAndCommentidAndSnapshotidAndId.METADATA,\n          path: eraseByArticleidAndCommentidAndSnapshotidAndId.path(\n            articleId,\n            commentId,\n            snapshotId,\n            id,\n          ),\n          status: null,\n        },\n      );\n}\nexport namespace eraseByArticleidAndCommentidAndSnapshotidAndId {\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(commentId ?? \"null\")}/snapshots/${encodeURIComponent(snapshotId ?? \"null\")}/files/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    commentId: string & tags.Format<\"uuid\">,\n    snapshotId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByArticleidAndCommentidAndSnapshotidAndId.path(\n        articleId,\n        commentId,\n        snapshotId,\n        id,\n      ),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"commentId\")(() => typia.assert(commentId));\n      assert.param(\"snapshotId\")(() => typia.assert(snapshotId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
    "src/api/functional/attachmentFiles/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IAttachmentFile } from \"../../structures/IAttachmentFile\";\nimport { IPageIAttachmentFile } from \"../../structures/IPageIAttachmentFile\";\n\n/**\n * Creates a new attachment file resource (attachment_files) with required\n * metadata and file URL.\n *\n * This endpoint provisions a new file record in the attachment_files table,\n * referencing metadata for an already-uploaded asset. The request body conforms\n * to IAttachmentFile.ICreate, containing the file name, extension (nullable),\n * and file URL. On success, it returns the created file resource with full\n * metadata and unique assigned UUID. Cascade relationships in the schema\n * guarantee that any later association to articles or comments snapshots is\n * transactional and consistent.\n *\n * The file must be accessible by given URL and reserved for evidence retention\n * purposes. Multiple objects can reference the same file asset as attachments,\n * enabled by the join tables. Security and validation ensure the integrity and\n * uniqueness of file records.\n *\n * @param body File resource metadata including name, extension, and file URL.\n * @path /attachmentFiles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  body: post.Input,\n): Promise<post.Output> {\n  return !!connection.simulate\n    ? post.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace post {\n  export type Input = IAttachmentFile.ICreate;\n  export type Output = IAttachmentFile;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/attachmentFiles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/attachmentFiles\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IAttachmentFile => typia.random<IAttachmentFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: post.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Retrieves a paginated, searchable, sortable list of file resources\n * (attachment_files).\n *\n * This operation retrieves a list of file resources managed in the system\n * (attachment_files table), supporting flexible searching and filtering\n * capabilities according to user, admin, or system automation needs. Supports\n * pagination, sorting by date/filename, and querying by file type or other\n * metadata, improving file list usability in UI grids and admin panels.\n *\n * Search requests reference the IAttachmentFile.IRequest schema, encapsulating\n * search and filter parameters, and responses return IPageIAttachmentFile,\n * containing pagination metadata plus file entries. Deletion/creation is\n * handled via separate endpoints, and logical deletion policies must be\n * respected if implemented in the table.\n *\n * @param body File search and filter parameters (filename, extension,\n *   createdAt, etc.)\n * @path /attachmentFiles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  body: patch.Input,\n): Promise<patch.Output> {\n  return !!connection.simulate\n    ? patch.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patch {\n  export type Input = IAttachmentFile.IRequest;\n  export type Output = IPageIAttachmentFile;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/attachmentFiles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/attachmentFiles\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIAttachmentFile => typia.random<IPageIAttachmentFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: patch.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Gets a specific attachment file resource (attachment_files) by its UUID ID.\n *\n * Fetch details for a single file resource from attachment_files by its system\n * ID (UUID). Results include filename, extension, download URL, and other\n * metadata for correct rendering and download in UI or for API-based\n * consumption. Soft/hard delete status must be respected by this endpoint if\n * supported in the schema, showing only valid, non-deleted resources as\n * appropriate. Error handling required for missing IDs.\n *\n * @param id Target file resource's ID\n * @path /attachmentFiles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getById.Output> {\n  return !!connection.simulate\n    ? getById.simulate(connection, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(id),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Output = IAttachmentFile;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/attachmentFiles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/attachmentFiles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IAttachmentFile => typia.random<IAttachmentFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Updates metadata for an attachment file (attachment_files), e.g., filename,\n * extension, or URL.\n *\n * This endpoint enables authorized changes to metadata for an attachment file\n * in the attachment_files table, such as filename, extension, or URL. The\n * request body IAttachmentFile.IUpdate allows for one or more of these fields\n * to be edited. Cascade relationships maintain referential integrity with join\n * tables; updating file resources is critical for correcting errors or unifying\n * data.\n *\n * Audit/compliance logging recommended for all changes; proper permission\n * checks are required. Actual file content is not altered by this DB operation,\n * only system-associated metadata.\n *\n * @param id Target file resource's ID\n * @param body Updated metadata values for the attachment file (name, extension,\n *   url).\n * @path /attachmentFiles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: putById.Input,\n): Promise<putById.Output> {\n  return !!connection.simulate\n    ? putById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putById {\n  export type Input = IAttachmentFile.IUpdate;\n  export type Output = IAttachmentFile;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/attachmentFiles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/attachmentFiles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IAttachmentFile => typia.random<IAttachmentFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: putById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Physically deletes (fully removes) a file resource (attachment_files) by its\n * system ID.\n *\n * This endpoint allows full (hard) deletion of a file resource from the\n * attachment_files table. It is restricted to situations where evidence\n * retention policy and all association constraints are addressed. All children\n * join records (bbs_article_snapshot_files, bbs_article_comment_snapshot_files)\n * must be evaluated for foreign key safety—usually via ON DELETE CASCADE.\n *\n * Logical deletion may be preferable in auditing scenarios; however, this\n * endpoint completely removes the file record, thus any download or reference\n * links will become defunct. Only highly privileged actions and system clean-up\n * tasks should invoke this.\n *\n * @param id Target file resource's ID\n * @path /attachmentFiles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n): Promise<void> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(id),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/attachmentFiles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/attachmentFiles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): void =>\n    typia.random<void>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n  ): void => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
    "test/features/api/test_api_bbs_articles_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_post(connection: api.IConnection) {\n  const output: IBbsArticle = await api.functional.bbs.articles.post(\n    connection,\n    typia.random<IBbsArticle.ICreate>(),\n  );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsArticle\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_patch(connection: api.IConnection) {\n  const output: IPageIBbsArticle.ISummary =\n    await api.functional.bbs.articles.patch(\n      connection,\n      typia.random<IBbsArticle.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_getById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticle = await api.functional.bbs.articles.getById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n  );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_putById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticle = await api.functional.bbs.articles.putById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n    typia.random<IBbsArticle.IUpdate>(),\n  );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticle = await api.functional.bbs.articles.eraseById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n    typia.random<IBbsArticle.IDelete>(),\n  );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_snapshots_patchByArticleid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsArticleSnapshot\";\nimport { IBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshot\";\n\nexport async function test_api_bbs_articles_snapshots_patchByArticleid(\n  connection: api.IConnection,\n) {\n  const output: IPageIBbsArticleSnapshot =\n    await api.functional.bbs.articles.snapshots.patchByArticleid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleSnapshot.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_snapshots_getByArticleidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshot\";\n\nexport async function test_api_bbs_articles_snapshots_getByArticleidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleSnapshot =\n    await api.functional.bbs.articles.snapshots.getByArticleidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_snapshots_putByArticleidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshot\";\n\nexport async function test_api_bbs_articles_snapshots_putByArticleidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleSnapshot =\n    await api.functional.bbs.articles.snapshots.putByArticleidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleSnapshot.IUpdate>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_snapshots_eraseByArticleidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshot\";\n\nexport async function test_api_bbs_articles_snapshots_eraseByArticleidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleSnapshot =\n    await api.functional.bbs.articles.snapshots.eraseByArticleidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleSnapshot.IDelete>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_snapshots_files_postByArticleidAndSnapshotid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIBbsArticleSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsArticleSnapshotFile\";\nimport { IBbsArticleSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshotFile\";\n\nexport async function test_api_bbs_articles_snapshots_files_postByArticleidAndSnapshotid(\n  connection: api.IConnection,\n) {\n  const output: IPageIBbsArticleSnapshotFile =\n    await api.functional.bbs.articles.snapshots.files.postByArticleidAndSnapshotid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleSnapshotFile.ICreate>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_snapshots_files_patchByArticleidAndSnapshotid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIBbsArticleSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsArticleSnapshotFile\";\nimport { IBbsArticleSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshotFile\";\n\nexport async function test_api_bbs_articles_snapshots_files_patchByArticleidAndSnapshotid(\n  connection: api.IConnection,\n) {\n  const output: IPageIBbsArticleSnapshotFile =\n    await api.functional.bbs.articles.snapshots.files.patchByArticleidAndSnapshotid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleSnapshotFile.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_snapshots_files_getByArticleidAndSnapshotidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshotFile\";\n\nexport async function test_api_bbs_articles_snapshots_files_getByArticleidAndSnapshotidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleSnapshotFile =\n    await api.functional.bbs.articles.snapshots.files.getByArticleidAndSnapshotidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_snapshots_files_putByArticleidAndSnapshotidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshotFile\";\n\nexport async function test_api_bbs_articles_snapshots_files_putByArticleidAndSnapshotidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleSnapshotFile =\n    await api.functional.bbs.articles.snapshots.files.putByArticleidAndSnapshotidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleSnapshotFile.IUpdate>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_snapshots_files_eraseByArticleidAndSnapshotidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshotFile\";\n\nexport async function test_api_bbs_articles_snapshots_files_eraseByArticleidAndSnapshotidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleSnapshotFile =\n    await api.functional.bbs.articles.snapshots.files.eraseByArticleidAndSnapshotidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_postByArticleid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_postByArticleid(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleComment =\n    await api.functional.bbs.articles.comments.postByArticleid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleComment.ICreate>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_patchByArticleid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageBbsArticleComment\";\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_patchByArticleid(\n  connection: api.IConnection,\n) {\n  const output: IPageBbsArticleComment =\n    await api.functional.bbs.articles.comments.patchByArticleid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleComment.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_getByArticleidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_getByArticleidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleComment =\n    await api.functional.bbs.articles.comments.getByArticleidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_putByArticleidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_putByArticleidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleComment =\n    await api.functional.bbs.articles.comments.putByArticleidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleComment.IUpdate>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_eraseByArticleidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_eraseByArticleidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleComment =\n    await api.functional.bbs.articles.comments.eraseByArticleidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_snapshots_patchByArticleidAndCommentid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageBbsArticleCommentSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageBbsArticleCommentSnapshot\";\nimport { IBbsArticleCommentSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleCommentSnapshot\";\n\nexport async function test_api_bbs_articles_comments_snapshots_patchByArticleidAndCommentid(\n  connection: api.IConnection,\n) {\n  const output: IPageBbsArticleCommentSnapshot =\n    await api.functional.bbs.articles.comments.snapshots.patchByArticleidAndCommentid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleCommentSnapshot.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_snapshots_getByArticleidAndCommentidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleCommentSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleCommentSnapshot\";\n\nexport async function test_api_bbs_articles_comments_snapshots_getByArticleidAndCommentidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleCommentSnapshot =\n    await api.functional.bbs.articles.comments.snapshots.getByArticleidAndCommentidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_snapshots_putByArticleidAndCommentidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleCommentSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleCommentSnapshot\";\n\nexport async function test_api_bbs_articles_comments_snapshots_putByArticleidAndCommentidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleCommentSnapshot =\n    await api.functional.bbs.articles.comments.snapshots.putByArticleidAndCommentidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleCommentSnapshot.IUpdate>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_snapshots_eraseByArticleidAndCommentidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_api_bbs_articles_comments_snapshots_eraseByArticleidAndCommentidAndId(\n  connection: api.IConnection,\n) {\n  const output =\n    await api.functional.bbs.articles.comments.snapshots.eraseByArticleidAndCommentidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_snapshots_files_postByArticleidAndCommentidAndSnapshotid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICommentSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICommentSnapshotFile\";\n\nexport async function test_api_bbs_articles_comments_snapshots_files_postByArticleidAndCommentidAndSnapshotid(\n  connection: api.IConnection,\n) {\n  const output: ICommentSnapshotFile =\n    await api.functional.bbs.articles.comments.snapshots.files.postByArticleidAndCommentidAndSnapshotid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<ICommentSnapshotFile.ICreate>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_snapshots_files_patchByArticleidAndCommentidAndSnapshotid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICommentSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICommentSnapshotFile\";\n\nexport async function test_api_bbs_articles_comments_snapshots_files_patchByArticleidAndCommentidAndSnapshotid(\n  connection: api.IConnection,\n) {\n  const output: ICommentSnapshotFile.ISummary =\n    await api.functional.bbs.articles.comments.snapshots.files.patchByArticleidAndCommentidAndSnapshotid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<ICommentSnapshotFile.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_snapshots_files_getByArticleidAndCommentidAndSnapshotidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICommentSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICommentSnapshotFile\";\n\nexport async function test_api_bbs_articles_comments_snapshots_files_getByArticleidAndCommentidAndSnapshotidAndId(\n  connection: api.IConnection,\n) {\n  const output: ICommentSnapshotFile =\n    await api.functional.bbs.articles.comments.snapshots.files.getByArticleidAndCommentidAndSnapshotidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_snapshots_files_putByArticleidAndCommentidAndSnapshotidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { ICommentSnapshotFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/ICommentSnapshotFile\";\n\nexport async function test_api_bbs_articles_comments_snapshots_files_putByArticleidAndCommentidAndSnapshotidAndId(\n  connection: api.IConnection,\n) {\n  const output: ICommentSnapshotFile =\n    await api.functional.bbs.articles.comments.snapshots.files.putByArticleidAndCommentidAndSnapshotidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<ICommentSnapshotFile.IUpdate>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_bbs_articles_comments_snapshots_files_eraseByArticleidAndCommentidAndSnapshotidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_api_bbs_articles_comments_snapshots_files_eraseByArticleidAndCommentidAndSnapshotidAndId(\n  connection: api.IConnection,\n) {\n  const output =\n    await api.functional.bbs.articles.comments.snapshots.files.eraseByArticleidAndCommentidAndSnapshotidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_attachmentFiles_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\n\nexport async function test_api_attachmentFiles_post(\n  connection: api.IConnection,\n) {\n  const output: IAttachmentFile = await api.functional.attachmentFiles.post(\n    connection,\n    typia.random<IAttachmentFile.ICreate>(),\n  );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_attachmentFiles_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIAttachmentFile\";\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\n\nexport async function test_api_attachmentFiles_patch(\n  connection: api.IConnection,\n) {\n  const output: IPageIAttachmentFile =\n    await api.functional.attachmentFiles.patch(\n      connection,\n      typia.random<IAttachmentFile.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_attachmentFiles_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\n\nexport async function test_api_attachmentFiles_getById(\n  connection: api.IConnection,\n) {\n  const output: IAttachmentFile = await api.functional.attachmentFiles.getById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n  );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_attachmentFiles_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\n\nexport async function test_api_attachmentFiles_putById(\n  connection: api.IConnection,\n) {\n  const output: IAttachmentFile = await api.functional.attachmentFiles.putById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n    typia.random<IAttachmentFile.IUpdate>(),\n  );\n  typia.assert(output);\n}\n",
    "test/features/api/test_api_attachmentFiles_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nexport async function test_api_attachmentFiles_eraseById(\n  connection: api.IConnection,\n) {\n  const output = await api.functional.attachmentFiles.eraseById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n  );\n  typia.assert(output);\n}\n",
    "packages/api/swagger.json": "{\n  \"openapi\": \"3.1.0\",\n  \"paths\": {\n    \"/bbs/articles\": {\n      \"patch\": {\n        \"summary\": \"Retrieve a list of BBS articles ('bbs_articles' table) with filtering, search, and pagination.\",\n        \"description\": \"This API retrieves a paginated and filtered list of articles from the 'bbs_articles' table. The endpoint should support standard search fields, such as title, writer, or date range, reflecting the need for efficient querying and performance optimization as outlined in the requirements.\\n\\nThe response includes only the latest snapshot information (title, etc.) and not the complete snapshot history for each article, consistent with index usage and list performance needs. Security considerations include returning only non-deleted articles to general users; deleted articles may be included for admins based on role.\\n\\nRelated operations: GET /bbs/articles/{id} for detail view, PATCH /bbs/articles/{articleId}/snapshots for snapshots list, and CRUD operations for creation, update, and deletion. Consider error handling for invalid queries and paging boundaries.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Search criteria, filtering, sorting, and pagination for retrieving article list.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsArticle.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paginated list of summarized article information, showing title (latest snapshot), author, comment count, and timestamps.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new BBS article with initial snapshot and attachments (related to 'bbs_articles' table).\",\n        \"description\": \"This API creates a new article in the 'bbs_articles' table with all required fields, such as writer name, password (secure/encrypted), and creation time. The body and title are stored in the initial record in 'bbs_article_snapshots', while attached files are related via 'bbs_article_snapshot_files'.\\n\\nUpon success, a new article is created with its first snapshot and attachments, and all references are established. Security: password will be encrypted in storage. Ensure all fields follow validations in the DB schema, such as non-empty strings for essential fields, proper format for UUIDs, and file URL validation. The operation is atomic—all-or-nothing if file/attachment data is invalid.\\n\\nRelated: PATCH /bbs/articles for article listing and GET /bbs/articles/{id} for detail view.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.ICreate\"\n              }\n            }\n          },\n          \"description\": \"New article's information, including writer, password, body/title, format, and attachments.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            },\n            \"description\": \"The created article with its first snapshot and uploaded attachments.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{id}\": {\n      \"get\": {\n        \"summary\": \"Get detail information of a specific BBS article ('bbs_articles' table), including latest snapshot and attachments.\",\n        \"description\": \"This API provides detail for a single article from the 'bbs_articles' table, identified by its UUID. Main output fields are writer, creation/deletion time, the latest snapshot's title/body/format, and summary of attachments and comments.\\n\\nValidation includes ensuring the article exists and is not deleted (for general users), with soft-deleted articles only visible for admins/staff. Response incorporates summarized comment count, facilitating user interface efficiency. Error handling covers 'not found' and forbidden access on deleted items.\\n\\nRelated: PATCH /bbs/articles for lists, PATCH /bbs/articles/{articleId}/snapshots for modification history.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the BBS article to retrieve.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            },\n            \"description\": \"Detailed article with latest snapshot, summary of attachments, and comment count.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a specific BBS article ('bbs_articles' table); creates a new snapshot with attachments.\",\n        \"description\": \"This API modifies an existing BBS article. Upon update, password is verified then a new snapshot is inserted in 'bbs_article_snapshots', containing the revised title/body/format and new/updated attachments listed via 'bbs_article_snapshot_files'.\\n\\nThe original article's record in 'bbs_articles' is not overwritten; only new snapshot/attachments are created to preserve evidence, as per requirements. Security: password verification is strict, and all updates are timestamped. All DB constraints and validation are applied (e.g., title, body not empty).\\n\\nError cases include unauthorized access, not found, or validation failures. The operation is atomic—either the snapshot and all attachments are created, or none are.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article to update.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Updated article content, verified via password, with attachments list.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            },\n            \"description\": \"Updated article model including the new snapshot and latest attachment state.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Soft-delete a specific article ('bbs_articles' table); sets 'deleted_at', preserves evidence.\",\n        \"description\": \"This API marks an article as logically deleted (soft delete) by setting the 'deleted_at' timestamp, per requirements. The request must provide password verification.\\n\\nThe operation does not alter existing snapshot or attachment file records, preserving all evidence. Soft-deleted articles are hidden from non-admin users. Security: password must match and be securely provided; deleted articles remain retrievable by admins for audits if needed.\\n\\nError scenarios: unauthorized/deletion of already deleted, or article not found. Proper error is returned (e.g., forbidden, not found).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article to delete.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.IDelete\"\n              }\n            }\n          },\n          \"description\": \"Password for verification prior to soft-deletion.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            },\n            \"description\": \"Updated article record with 'deleted_at' set; all historical data preserved.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/snapshots\": {\n      \"patch\": {\n        \"summary\": \"Get all revision snapshots for a given article ('bbs_article_snapshots' table, by articleId), with pagination.\",\n        \"description\": \"This API lists all snapshots (modification revisions) for a specific article from the 'bbs_article_snapshots' table using the article's ID. Each snapshot includes title, body format, creation timestamp, ip address, and list of attachment files for that version.\\n\\nSupports pagination, important for heavily-edited articles (for performance). Access is generally open, but some security logic may be applied to deleted or restricted articles.\\n\\nRelated operations: PATCH /bbs/articles for lists, GET /bbs/articles/{id} for details, GET /bbs/articles/{articleId}/snapshots/{id} for individual revision.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article whose snapshots are being listed.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleSnapshot.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Optional pagination and filter parameters for snapshot history.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsArticleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Paginated list of article snapshot histories, with metadata and attachment summaries for each.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/snapshots/{id}\": {\n      \"get\": {\n        \"summary\": \"Get detail of a specific snapshot for a given article ('bbs_article_snapshots' table, by articleId and snapshotId).\",\n        \"description\": \"This API fetches a single snapshot (revision) of a given article using both IDs. The response includes the title, body, format, ip address, and the list of related attachments stored at the time of this revision. Used for auditing, difference viewing, or legal evidence of changes.\\n\\nSecurity checks ensure access to the underlying article. If the snapshot does not exist or is not linked to the specified article, a 'not found' is returned. No soft-delete applies to originals here; evidence is never removed.\\n\\nRelated: PATCH /bbs/articles/{articleId}/snapshots for revision history.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article to which the snapshot belongs.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the snapshot to fetch.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Snapshot detail for given article and snapshotId, including attachments of that version.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update content or metadata of a specific article snapshot ('bbs_article_snapshots' table, by articleId and snapshotId); admin/system only.\",\n        \"description\": \"This API updates a snapshot 'bbs_article_snapshots' record. Normally, snapshot changes are forbidden for users (evidence preservation), but certain admin/system roles may execute corrections (e.g., unlawful content, typo fix). Updates may include modifications to title, body, format, or attachment relations; logs must track all changes for auditing.\\n\\nSecurity: restricted to admins or evidence maintainers. Standard validations apply, and revert possible for audit reasons. Related to PATCH /bbs/articles/{articleId}/snapshots.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article containing the snapshot.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the snapshot to update.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleSnapshot.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Snapshot fields to update (title/body/attachments/format). Usually only by admin/system.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Updated snapshot details after admin/system correction.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Logically delete a snapshot of an article ('bbs_article_snapshots'), admin/system only, for evidence management.\",\n        \"description\": \"This API marks a specific article snapshot as deleted (logically), removing it from default user access. The actual snapshot record is not physically deleted, preserving historical evidence and references, but a status or timestamp is set as deleted.\\n\\nSecurity: strictly restricted to admin/system users. Normal users cannot delete snapshots (only create new ones for revisions). Soft-deleted snapshots may be included in audit/admin views with proper roles.\\n\\nRelated: PATCH /bbs/articles/{articleId}/snapshots for revisions, GET /bbs/articles/{articleId}/snapshots/{id} for detail.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article containing the snapshot.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the snapshot to delete.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleSnapshot.IDelete\"\n              }\n            }\n          },\n          \"description\": \"Credentials or reason for deletion (admin/system use only).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Snapshot record marked as deleted (logically); record preserved for evidence.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/snapshots/{snapshotId}/files\": {\n      \"patch\": {\n        \"summary\": \"List all attachment files for a specific article snapshot (by articleId/snapshotId), using 'bbs_article_snapshot_files'.\",\n        \"description\": \"This API fetches all files attached to a specific revision (snapshot) of an article. Filters on articleId and snapshotId provide the explicit context to retrieve sequence/order of files, file metadata (name, extension, URL, creation time, sequence). Pagination can be included for snapshots with many files.\\n\\nRelated operations: POST for attaching new files to a revision, DELETE for removing files, PATCH for reordering/updating attachment list.\\n\\nAttachment files must be publicly accessible (with proper security tokens if required).\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article of the snapshot.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article snapshot whose files are being listed.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Options for filtering or paging attached files for this snapshot.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsArticleSnapshotFile\"\n                }\n              }\n            },\n            \"description\": \"Paginated list of snapshot attachment file records with metadata.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Attach one or more files to a specific snapshot of an article ('bbs_article_snapshot_files'), returning updated file list.\",\n        \"description\": \"This API attaches files to a specific article snapshot. It accepts file IDs (already uploaded via separate process) or requires necessary file metadata if uploading new files. For existing files, establishes the link via 'bbs_article_snapshot_files'; for new uploads, creates a file record in 'attachment_files' then associates it.\\n\\nSequence/order is essential (for display order). Validation checks that files exist or are newly proper. Security: normal user edits require proper authentication; admin/system roles may bypass restrictions for evidence.</br>\\n\\nReturns updated list of attachments, with all associated metadata for the snapshot. Related: PATCH for updating the order, DELETE for deleting attachments.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article of the snapshot being modified.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the snapshot to attach files to.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Attachment file information to link/upload for this snapshot, plus order.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsArticleSnapshotFile\"\n                }\n              }\n            },\n            \"description\": \"Updated attachment list for the specified snapshot, with file metadata.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/snapshots/{snapshotId}/files/{id}\": {\n      \"get\": {\n        \"summary\": \"Get a specific attached file (bbs_article_snapshot_files) in a snapshot of an article.\",\n        \"description\": \"This GET operation retrieves a particular file attached to a specific snapshot of an article in the bulletin board system.\\n\\nThe endpoint path parameters (articleId, snapshotId, id) represent the article UUID, the snapshot UUID, and the file attachment relation UUID (bbs_article_snapshot_files.id) respectively. This strict mapping ensures the file's association is under the correct article version, upholding evidentiary record accuracy as described in the requirements.\\n\\nSecurity considerations include verifying the logical existence of the parent article and snapshot (not deleted), and checking the user's permission for file access.\\n\\nReturns metadata about the attachment (order, file metadata, and URL for download). Relies on the correct structure and associations as maintained within the attachment_files and bbs_article_snapshot_files Prisma models.\\n\\nHandles errors such as not-found (404) if any ancestor entity does not exist or is inaccessible, and forbidden (403) for unauthorized access attempts.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target snapshot ID (UUID) in bbs_article_snapshots\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Attachment relation ID in bbs_article_snapshot_files\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile\"\n                }\n              }\n            },\n            \"description\": \"Attachment file metadata and relation info for a given snapshot of article.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update attachment file entry (bbs_article_snapshot_files) metadata for a given article snapshot.\",\n        \"description\": \"This PUT operation updates the mapping information for a specific file attached to an article snapshot. A typical use case includes resequencing file orders or changing ancillary metadata about this attachment (the file itself is immutable for evidence, but linkage/metadata can change for the active revision).\\n\\nRequires verification of the parent article (not deleted), parent snapshot, and correct ownership/permissions, as defined by the evidentiary and logical deletion model.\\n\\nThe request body structure corresponds to updates for the 'bbs_article_snapshot_files' record, such as sequence reordering.\\n\\nUpdate is restricted to the targeted relation and does not affect historical data in previous snapshots.\\n\\nHandles error states including not-found for any path element, permission denial, and validation for business rules (e.g., not modifying a locked/evidence snapshot).\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target snapshot ID (UUID) in bbs_article_snapshots\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Attachment relation ID in bbs_article_snapshot_files\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Info to update the attached file relation (e.g., sequence order) in a snapshot.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile\"\n                }\n              }\n            },\n            \"description\": \"Updated attachment file relation data for the snapshot.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Delete (logically unlink) a file from a snapshot (bbs_article_snapshot_files) of an article.\",\n        \"description\": \"This DELETE operation logically removes (unlinks) an attachment file from a specific article snapshot in the system. The operation targets the entry in 'bbs_article_snapshot_files', marking it as logically deleted if required by implementation, while preserving evidence as per requirements.\\n\\nDeleted file entries should no longer display for the target snapshot, but all historical records and actual file data are preserved for audit and evidence. Parent entity existence (article, snapshot) and permissions are always validated.\\n\\nThis operation may trigger side-effects such as reordering remaining files or revising display metadata for the snapshot, but never deletes actual file content.\\n\\nErrors handled include not-found for non-existing entities or relations, permission denial, and violation of audit-evidence policies.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target snapshot ID (UUID) in bbs_article_snapshots\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Attachment relation ID in bbs_article_snapshot_files\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile\"\n                }\n              }\n            },\n            \"description\": \"Result of detach/logical deletion of the attachment file from the snapshot.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/comments\": {\n      \"patch\": {\n        \"summary\": \"List all comments (bbs_article_comments) for an article, with search/filter.\",\n        \"description\": \"This PATCH operation fetches a paginated and searchable list of all comments related to a specific article, as defined in the requirements (nested structure, logical deletion, evidence). Search criteria can include author fields, timestamp range, parent/child linkage for hierarchical display, etc.\\n\\nResults present only comments not logically deleted for public users. Admins may access deleted items with proper authorization.\\n\\nHandles edge cases such as no results, excessive pagination, and filter security. Data comes from the 'bbs_article_comments' table, potentially joined with the latest comment snapshot for list views.\\n\\nFails with 404 if article doesn't exist, or appropriate error for permission issues.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Parameters for searching, filtering, and pagination for comment list.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageBbsArticleComment\"\n                }\n              }\n            },\n            \"description\": \"Paginated comment list objects for the article.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new comment (bbs_article_comments) on an article.\",\n        \"description\": \"This POST operation creates a new comment on a specific article in the bulletin board system. New comments must include required fields such as writer, password, and initial content, referenced by a parentId if this is a reply to another comment (enables hierarchical threading).\\n\\nThe operation first creates an entry in 'bbs_article_comments', then creates an initial bbs_article_comment_snapshots record with the comment's content. If files are attached, relevant mapping records are also created in bbs_article_comment_snapshot_files and attachment_files.\\n\\nEnforces password hashing, IP logging, timestamp recording, and initializes all evidence features.\\n\\nHandles validation errors (missing fields), permission enforcement, and ensures parent entities exist (article, parent comment if reply). Responds with the created comment structure, including snapshot references and attachment linkage.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Comment creation input for bbs_article_comments, including parentId, writer, password, and initial content.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n                }\n              }\n            },\n            \"description\": \"The created comment information, including snapshots and attachments.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve a specific comment (bbs_article_comments) within an article by ID.\",\n        \"description\": \"This GET operation retrieves a single comment by its unique identifier, attached to a specific article. It pulls data from 'bbs_article_comments', confirming article and comment association, and validates that the comment is not logically deleted for public views.\\n\\nInherited relationships allow easy nesting for replies. The result returns only top-level comment record info (writer, timestamps, parent, etc)–attachable snapshots and files are accessed through other APIs.\\n\\nPermission and logical deletion rules are enforced: only non-deleted comments are shown publicly, while admins may retrieve deleted comments for evidence or audit purposes.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment ID (UUID) in bbs_article_comments\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n                }\n              }\n            },\n            \"description\": \"The comment object matching the given article and ID, or error if not found.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update a specific comment (metadata/relationships) in bbs_article_comments within an article.\",\n        \"description\": \"This PUT operation modifies a comment on a given article, addressing certain updatable fields in 'bbs_article_comments' such as writer, password, or parentId (for reply/nesting structure). The revision of contents (body) is handled by subsequent snapshot creation in a nested or parallel API.\\n\\nUpdates trigger standard evidence retention (audit trails, password verification), and may affect hierarchical threading. Parent entity existence must be verified. Logical deletion rules and permissions apply – deleted comments cannot be modified by typical users.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment ID (UUID) in bbs_article_comments\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleComment.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Details for comments update, including writer, password, or parentId for nesting.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n                }\n              }\n            },\n            \"description\": \"The updated comment information, excluding historical snapshots.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Logically delete (soft-delete) a comment (bbs_article_comments) from an article.\",\n        \"description\": \"This DELETE operation performs a logical (soft) deletion of a comment on a given article. Instead of removing the record from 'bbs_article_comments', the 'deleted_at' timestamp is set to the current time (soft delete), preserving audit trails for evidence and dispute resolution as mandated by system requirements.\\n\\nChecks that the targeted comment exists, is not already deleted, and that any user access or password verification requirements are satisfied. Deleted comments are excluded from public retrieval but available for evidence by administrators.\\n\\nHandles not-found, already-deleted, and access-denial errors appropriately.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment ID (UUID) in bbs_article_comments\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n                }\n              }\n            },\n            \"description\": \"The updated information of the now-deleted comment, including timestamp.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/comments/{commentId}/snapshots\": {\n      \"patch\": {\n        \"summary\": \"List all snapshots (bbs_article_comment_snapshots) for a comment on an article, with search/pagination.\",\n        \"description\": \"This PATCH operation retrieves all snapshots (revision history) for a given comment attached to an article. Returns paginated and/or filtered results, including metadata such as format, timestamp, author IP, and relevant attachments (linkage only). This allows evidence presentation and rollback investigation for all comment changes.\\n\\nAccess is restricted depending on logical deletion status and permissions (admins vs. general users). Snapshots provide information for audit, dispute resolution, or version comparison in the UI.\\n\\nHandles errors for invalid parameters, not-found comment/article ancestors, and respects maximum page size/policy limits.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          },\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Comment ID in bbs_article_comments to which the snapshots belong\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Parameters for searching, pagination, and filtering of comment snapshots.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageBbsArticleCommentSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Paginated and filtered list of all snapshots for the given comment.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/comments/{commentId}/snapshots/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieve a specific comment snapshot (bbs_article_comment_snapshots) for a given comment on an article.\",\n        \"description\": \"This GET operation retrieves a single revision snapshot for a comment (bbs_article_comment_snapshots). The snapshot is uniquely identified by its attachment to a specific article, comment, and snapshot UUID.\\n\\nReturns detailed information about the snapshot content, including format, body, creation metadata, author IP, and file attachments (linkage only — actual files accessed through separate API calls).\\n\\nFails with not-found errors if any identified entity does not exist or is not accessible, and enforces necessary permissions and logical deletion rules.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          },\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Comment ID in bbs_article_comments to which the snapshot belongs\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Comment snapshot ID (UUID) in bbs_article_comment_snapshots\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Snapshot details of the identified comment's revision, including format, content, IP, and attachments.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update content or metadata for a specific comment snapshot (bbs_article_comment_snapshots) by ID.\",\n        \"description\": \"This PUT operation updates metadata or content for a particular comment snapshot in the evidence system. While general edits typically create new snapshots, this can allow corrections under special administrative circumstances, for evidence correction or dispute resolution.\\n\\nAccepts content (body), format, and possibly file association adjustments. Must strictly validate parent article and comment, existing snapshot, and business rules for evidentiary control — typical users may not be allowed unless it's for error correction or privileged access.\\n\\nSide-effects are limited to only the indicated snapshot; evidence/integrity must be preserved.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article ID (UUID) in bbs_articles\",\n            \"required\": true\n          },\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Comment ID in bbs_article_comments to which the snapshot belongs\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Comment snapshot ID (UUID) in bbs_article_comment_snapshots\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"The content, format, or attachment linkage updates for this comment snapshot.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot\"\n                }\n              }\n            },\n            \"description\": \"The updated comment snapshot details after editing.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Logically deletes a comment snapshot (bbs_article_comment_snapshots) by ID, nested under specific article and comment, as per evidence-preservation policy.\",\n        \"description\": \"This operation enables the logical deletion (soft delete) of a comment snapshot record in the bbs_article_comment_snapshots table, nested under a specific comment within a specific article. According to the system's requirements for evidence preservation, this operation sets a deleted flag or timestamp field (rather than actually removing any history data) to make the snapshot invisible to regular end users but still retained in the system for administrative/audit purposes.\\n\\nThe operation involves several security considerations: only users with the correct password or administrators can perform deletions; IP addresses and audit trail information remain intact for compliance. The operation will fail if provided IDs do not correspond to existing entities.\\n\\nThis endpoint should be used only when absolutely necessary, such as in compliance with legal requirements or gross abuse. Otherwise, all history should remain permanently retained.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment snapshot's ID\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/bbs/articles/{articleId}/comments/{commentId}/snapshots/{snapshotId}/files\": {\n      \"patch\": {\n        \"summary\": \"Partially updates attachment files (bbs_article_comment_snapshot_files) for a specific comment snapshot, with support for sequence/order changes.\",\n        \"description\": \"This endpoint provides partial update capability for attachment files on a specific comment snapshot, using a request body referencing ICommentSnapshotFile.IRequest or a similar input type. The underlying table is the bbs_article_comment_snapshot_files, which is responsible for maintaining the association and sequence of each file for each snapshot.\\n\\nRequest validation ensures atomicity and transactional integrity: all add/remove/order changes are applied in a single transaction. Each update respects the unique sequence field to preserve file display order, a feature critical for end-user UX. Security checks must ensure that users have permission to alter the snapshot (password check/admin rights), and operations must be logged for audit. Related endpoints for attachment_files management should be referenced for holistic file lifecycle control.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment snapshot's ID\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ICommentSnapshotFile.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Partial update info with the new and/or reordered list of attachment files for the comment snapshot.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICommentSnapshotFile.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Updated list/summary of the files now attached to the snapshot, including order.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Associates new file(s) with a comment snapshot (bbs_article_comment_snapshot_files), specifying attachment and order.\",\n        \"description\": \"This endpoint enables the creation/association of one or several attachment files to a given comment snapshot (reference bbs_article_comment_snapshot_files in schema). File IDs must be valid and refer to pre-uploaded resources defined in attachment_files. The request body (ICommentSnapshotFile.ICreate) allows specification of the file(s) to attach and their display sequence/order, in accordance with UX/UI requirements.\\n\\nUpon success, the endpoint returns the new relationship(s) and order in the response type. All additions occur in a database transaction. Proper authentication, permission, and validation against duplicate/illegal operations are required. Usage of this endpoint is fundamental to supporting evidence‐preserving file associations in comment histories.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment snapshot's ID\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ICommentSnapshotFile.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Association info (file IDs and any sequence/order) for new attachments to the comment snapshot.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICommentSnapshotFile\"\n                }\n              }\n            },\n            \"description\": \"Details/summary of the newly attached file(s) and their association to the snapshot.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/comments/{commentId}/snapshots/{snapshotId}/files/{id}\": {\n      \"get\": {\n        \"summary\": \"Retrieves a specific attached file (bbs_article_comment_snapshot_files) for a comment snapshot, with file metadata and order.\",\n        \"description\": \"Fetch comprehensive metadata and relational info for a specific attachment file linked to a given comment snapshot. This involves joining bbs_article_comment_snapshot_files to bbs_article_comment_snapshots and attachment_files entities. The response provides display order (sequence), file name, extension, and URL for download/display purposes. Logical deletion/visibility rules apply as per system evidence-retaining policy, and audit trails/documentation should describe how to acquire both current and historical attachment file relationships.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment snapshot's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target attachment relation (bbs_article_comment_snapshot_files.id)\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICommentSnapshotFile\"\n                }\n              }\n            },\n            \"description\": \"Metadata and relationship details for specified attached file, including order and file resource info.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Updates order/association data for an attached file (bbs_article_comment_snapshot_files) for a comment snapshot.\",\n        \"description\": \"This operation enables updating the relationship data between a comment snapshot and an attached file by modifying the join table record (bbs_article_comment_snapshot_files). It's primarily for changing the file's display order (sequence) or other association-specific metadata. The request body conforms to ICommentSnapshotFile.IUpdate. This operation does not affect the physical file resource stored in attachment_files; use the dedicated API for file asset updates.\\n\\nPermission and integrity checks are necessary; only authorized users can update attachment associations. Related endpoints for partial update and file creation/deletion should be referenced for a complete file management lifecycle.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment snapshot's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target attachment relation (bbs_article_comment_snapshot_files.id)\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/ICommentSnapshotFile.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Update information, typically just the sequence/order, for the attached file association.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/ICommentSnapshotFile\"\n                }\n              }\n            },\n            \"description\": \"Updated relationship/association record with new metadata.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Deletes a comment snapshot's file association (bbs_article_comment_snapshot_files) by record ID, keeping asset file intact.\",\n        \"description\": \"This endpoint removes the association between a specific attachment file and a comment snapshot by deleting the join table record (bbs_article_comment_snapshot_files). The file asset remains in the system unless explicitly deleted elsewhere. All deletions must be authorized by permissions consistent with the evidence retention policy. Cascade rules in Prisma model keep referential integrity; access is restricted to users with modification/review rights.\\n\\nThis operation supports the requirement that, although all evidence must be preserved, attachment relationships may sometimes be retracted per user request or content update, but full delete of history is by exception only.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"commentId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"snapshotId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment snapshot's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target attachment relation (bbs_article_comment_snapshot_files.id)\",\n            \"required\": true\n          }\n        ]\n      }\n    },\n    \"/attachmentFiles\": {\n      \"patch\": {\n        \"summary\": \"Retrieves a paginated, searchable, sortable list of file resources (attachment_files).\",\n        \"description\": \"This operation retrieves a list of file resources managed in the system (attachment_files table), supporting flexible searching and filtering capabilities according to user, admin, or system automation needs. Supports pagination, sorting by date/filename, and querying by file type or other metadata, improving file list usability in UI grids and admin panels.\\n\\nSearch requests reference the IAttachmentFile.IRequest schema, encapsulating search and filter parameters, and responses return IPageIAttachmentFile, containing pagination metadata plus file entries. Deletion/creation is handled via separate endpoints, and logical deletion policies must be respected if implemented in the table.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IAttachmentFile.IRequest\"\n              }\n            }\n          },\n          \"description\": \"File search and filter parameters (filename, extension, createdAt, etc.)\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIAttachmentFile\"\n                }\n              }\n            },\n            \"description\": \"Paginated result of file resources matching query/filter, with pagination info.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Creates a new attachment file resource (attachment_files) with required metadata and file URL.\",\n        \"description\": \"This endpoint provisions a new file record in the attachment_files table, referencing metadata for an already-uploaded asset. The request body conforms to IAttachmentFile.ICreate, containing the file name, extension (nullable), and file URL. On success, it returns the created file resource with full metadata and unique assigned UUID. Cascade relationships in the schema guarantee that any later association to articles or comments snapshots is transactional and consistent.\\n\\nThe file must be accessible by given URL and reserved for evidence retention purposes. Multiple objects can reference the same file asset as attachments, enabled by the join tables. Security and validation ensure the integrity and uniqueness of file records.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n              }\n            }\n          },\n          \"description\": \"File resource metadata including name, extension, and file URL.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile\"\n                }\n              }\n            },\n            \"description\": \"The newly created file resource metadata and unique system ID.\"\n          }\n        }\n      }\n    },\n    \"/attachmentFiles/{id}\": {\n      \"get\": {\n        \"summary\": \"Gets a specific attachment file resource (attachment_files) by its UUID ID.\",\n        \"description\": \"Fetch details for a single file resource from attachment_files by its system ID (UUID). Results include filename, extension, download URL, and other metadata for correct rendering and download in UI or for API-based consumption. Soft/hard delete status must be respected by this endpoint if supported in the schema, showing only valid, non-deleted resources as appropriate. Error handling required for missing IDs.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target file resource's ID\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile\"\n                }\n              }\n            },\n            \"description\": \"All metadata for the specified file resource, including download/render info.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Updates metadata for an attachment file (attachment_files), e.g., filename, extension, or URL.\",\n        \"description\": \"This endpoint enables authorized changes to metadata for an attachment file in the attachment_files table, such as filename, extension, or URL. The request body IAttachmentFile.IUpdate allows for one or more of these fields to be edited. Cascade relationships maintain referential integrity with join tables; updating file resources is critical for correcting errors or unifying data.\\n\\nAudit/compliance logging recommended for all changes; proper permission checks are required. Actual file content is not altered by this DB operation, only system-associated metadata.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target file resource's ID\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IAttachmentFile.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Updated metadata values for the attachment file (name, extension, url).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile\"\n                }\n              }\n            },\n            \"description\": \"The updated file resource data after modification.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Physically deletes (fully removes) a file resource (attachment_files) by its system ID.\",\n        \"description\": \"This endpoint allows full (hard) deletion of a file resource from the attachment_files table. It is restricted to situations where evidence retention policy and all association constraints are addressed. All children join records (bbs_article_snapshot_files, bbs_article_comment_snapshot_files) must be evaluated for foreign key safety—usually via ON DELETE CASCADE.\\n\\nLogical deletion may be preferable in auditing scenarios; however, this endpoint completely removes the file record, thus any download or reference links will become defunct. Only highly privileged actions and system clean-up tasks should invoke this.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target file resource's ID\",\n            \"required\": true\n          }\n        ]\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IBbsArticle.IRequest\": {\n        \"type\": \"object\",\n        \"description\": \"Query data type for bulletin board article search or pagination.\\n\\nThis type corresponds to search, filter, sort, and pagination input for the BBS article listing endpoint. Each property enables selection or limitation by various fields and is mapped to the business context described in the requirements (efficient retrieval, search by writer/title/date, etc).\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Title search keyword.\\n\\nIf provided, filters to articles whose latest snapshot's title matches or contains the value.\\n\\nRef: bbs_article_snapshots.title\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Exact or partial writer name for search.\\n\\nUsed to filter articles by the 'writer' value in bbs_articles.writer.\"\n          },\n          \"createdAtFrom\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Lower bound (inclusive) for article creation time.\\n\\nFilters articles newer than or equal to the specified date/time.\\n\\nRef: bbs_articles.created_at\"\n          },\n          \"createdAtTo\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Upper bound (inclusive) for article creation time (latest).\\n\\nShow articles created before or at the specified date/time.\"\n          },\n          \"deleted\": {\n            \"type\": \"boolean\",\n            \"description\": \"Show logically deleted articles also.\\n\\nIf true, include soft-deleted articles (bbs_articles.deleted_at is non-null). Only allowed for admins.\"\n          },\n          \"orderBy\": {\n            \"oneOf\": [\n              {\n                \"const\": \"createdAtDesc\",\n                \"description\": \"Sort field for article listing.\\n\\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first.\"\n              },\n              {\n                \"const\": \"createdAtAsc\",\n                \"description\": \"Sort field for article listing.\\n\\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first.\"\n              },\n              {\n                \"const\": \"titleAsc\",\n                \"description\": \"Sort field for article listing.\\n\\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first.\"\n              },\n              {\n                \"const\": \"titleDesc\",\n                \"description\": \"Sort field for article listing.\\n\\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first.\"\n              }\n            ],\n            \"description\": \"Sort field for article listing.\\n\\nMaps to BBS UI sort options. Ex: 'createdAtDesc' for newest first.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"minimum\": 1,\n            \"description\": \"Page number for pagination (1-based).\\nDefaults to 1.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"minimum\": 1,\n            \"maximum\": 100,\n            \"default\": 20,\n            \"description\": \"Number of articles per page. Enforced max 100 to prevent overload.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IPageIBbsArticle.ISummary\": {\n        \"type\": \"object\",\n        \"description\": \"Paginated response type for BBS article summaries.\\n\\nContains both pagination metadata and actual list of article summary objects as required for efficient list display in UI, referencing the standard IPage<T> approach.\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticle.ISummary\"\n            },\n            \"description\": \"Array of summarized articles for the list page.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IBbsArticle.ICreate\": {\n        \"type\": \"object\",\n        \"description\": \"Request body type for creating a new BBS article.\\n\\nCorresponds to the requirements for BBS post creation (including author, password, content, and initial attachments). On creation, both bbs_articles and the initial bbs_article_snapshots record are created in a transaction. All properties are mapped to the data fields and business constraints described for posting in the requirements and the DB schema.\",\n        \"properties\": {\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Author's name for the new article (required).\\n\\nMaps to bbs_articles.writer. Required on creation, displayable in list/detail.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"format\": \"password\",\n            \"description\": \"Author password for edit/delete. Set on create and used for future auth/verification.\\n\\nMapped to bbs_articles.password (stored encrypted). Required on creation, write-only, not retrievable via detail endpoints.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Title text for the new article's first version/snapshot.\\n\\nMapped to bbs_article_snapshots.title. Required for creation.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Body/content for the initial snapshot of the article.\\n\\nMapped to bbs_article_snapshots.body. Required on creation.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Format of the body (e.g., 'html', 'md', 'txt').\\n\\nMapped to bbs_article_snapshots.format (content format for body storage).\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"IP address for evidence. Recorded at creation and snapshot.\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"description\": \"Initial attachment files for the article's first snapshot (optional).\\n\\nLinks to attachment_files via bbs_article_snapshot_files. Specify as list of IDs and sequence/order.\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile.ICreate\"\n            }\n          }\n        },\n        \"required\": [\n          \"writer\",\n          \"password\",\n          \"title\",\n          \"body\",\n          \"format\",\n          \"ip\"\n        ]\n      },\n      \"IBbsArticle\": {\n        \"type\": \"object\",\n        \"description\": \"Main entity type for BBS articles.\\n\\nRepresents the core article record, corresponding to bbs_articles in Prisma and ERD, but including related entities such as the latest snapshot, comment count, and attachments list as described in the requirements. Used for article detail, creation, and mutation result.\\n\\nIncludes all mandatory and optional fields required for full persistence and evidence, as described in requirements and schema. Each property is fully documented for clarity and legal traceability.\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier of article (UUID), primary key of bbs_articles.\\n\\nGenerated at creation, used for all subsequent operations.\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Original author's name, as entered on creation.\\n\\nRead-only after creation, except for admin/system update.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"format\": \"password\",\n            \"description\": \"Encrypted password for proof of authorship and modification/deletion verification.\\n\\nNever returned in detail or list APIs, write-only (masked in UI).\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of original article creation.\\n\\nMapped to bbs_articles.created_at.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Timestamp when logically deleted (soft delete).\\n\\nIndicates deletion in soft-delete model. Null if not deleted, else deleted. Mapped to bbs_articles.deleted_at.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Timestamp when logically deleted (soft delete).\\n\\nIndicates deletion in soft-delete model. Null if not deleted, else deleted. Mapped to bbs_articles.deleted_at.\"\n          },\n          \"latestSnapshot\": {\n            \"$ref\": \"#/components/schemas/IBbsArticleSnapshot.ISummary\",\n            \"description\": \"Latest content snapshot for this article, showing title, body (current), format, ip, and related metadata. Used for basic detail and list views.\"\n          },\n          \"commentCount\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"description\": \"Total number of comments directly associated with this article (non-deleted only). For UI performance and sorting.\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile.ISummary\"\n            },\n            \"description\": \"List of attachments of the current (latest) snapshot, ordered by sequence.\"\n          },\n          \"snapshots\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleSnapshot\"\n            },\n            \"description\": \"Complete snapshot revision history (usually only for admin or dedicated history endpoint).\"\n          },\n          \"comments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n            },\n            \"description\": \"All associated comments (hierarchical structure not encoded here, only flat by default).\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"writer\",\n          \"created_at\",\n          \"latestSnapshot\"\n        ]\n      },\n      \"IBbsArticle.IUpdate\": {\n        \"type\": \"object\",\n        \"description\": \"Request body type for updating/editing a BBS article.\\n\\nCorresponds to the business process of verifying password, establishing a new snapshot with changed contents (title/body/format), and adjusting attachments. All changes create new evidence records. Mapped to the 'edit post' requirement and Prisma/ERD structure.\",\n        \"properties\": {\n          \"password\": {\n            \"type\": \"string\",\n            \"format\": \"password\",\n            \"description\": \"Author password to verify permission for update. Required for editing or deleting articles for evidence.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"New title text for update. Used for the new snapshot. Optional if not changed.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"New body/content for update. Used for the new snapshot. Optional if not changed.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"New format string (html/md/txt/etc.). Optional.\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile.ICreate\"\n            },\n            \"description\": \"Updated list of attachment files (add/delete/reorder) for this snapshot (optional).\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"IP address for evidence. Must be included for auditing.\"\n          }\n        },\n        \"required\": [\n          \"password\",\n          \"ip\"\n        ]\n      },\n      \"IBbsArticle.IDelete\": {\n        \"type\": \"object\",\n        \"description\": \"Request body for logical deletion (soft-delete) of a BBS article by ID.\\n\\nAs per specifications, the password verifies authorship for the deletion. Deletion sets deleted_at only. Evidence/history is retained. Admins may have alternate logic for forced deletion.\",\n        \"properties\": {\n          \"password\": {\n            \"type\": \"string\",\n            \"format\": \"password\",\n            \"description\": \"Password for logical deletion verification. Required to authorize soft-delete.\"\n          }\n        },\n        \"required\": [\n          \"password\"\n        ]\n      },\n      \"IBbsArticleSnapshot.IRequest\": {\n        \"type\": \"object\",\n        \"description\": \"Pagination/filter/search type for listing all revision snapshots of a given article.\\n\\nMaps to the need to efficiently retrieve long modification histories. Used for PATCH /bbs/articles/{articleId}/snapshots.\",\n        \"properties\": {\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Filter by snapshot body format (e.g., md/html/txt).\"\n          },\n          \"createdAtFrom\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Lower date/time filter for snapshot creation.\"\n          },\n          \"createdAtTo\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Upper date/time filter for snapshot creation.\"\n          },\n          \"orderBy\": {\n            \"oneOf\": [\n              {\n                \"const\": \"createdAtDesc\",\n                \"description\": \"Sort by creation date (default to latest first).\"\n              },\n              {\n                \"const\": \"createdAtAsc\",\n                \"description\": \"Sort by creation date (default to latest first).\"\n              }\n            ],\n            \"description\": \"Sort by creation date (default to latest first).\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"description\": \"Pagination; page number, starting from 1.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"description\": \"Per-page record limit, default 20.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IPageIBbsArticleSnapshot\": {\n        \"type\": \"object\",\n        \"description\": \"Paging container for lists of article snapshot revision records.\\n\\nConforms to standard paging shape, with IPage.IPagination and data (IBbsArticleSnapshot[]). For use when listing all revisions of an article.\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleSnapshot\"\n            },\n            \"description\": \"Array of all revision snapshot records for given article.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IBbsArticleSnapshot\": {\n        \"type\": \"object\",\n        \"description\": \"Represents a single revision snapshot of an article (bbs_article_snapshots table).\\n\\nIncludes all fields for audit/evidence (body, title, format, ip, attachments list, creation time, etc.). Used for both detail views and snapshot histories.\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for this snapshot (UUID).\\n\\nPrimary key of bbs_article_snapshots.\"\n          },\n          \"bbs_article_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Reference article ID for this snapshot.\\n\\nForeign key to bbs_articles.id.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Title of the post at this revision.\\n\\nSnapshots record the state as of this revision; may differ from current.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Body/content of article at this specific revision.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Format for body—one of html/md/txt/etc.\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"Writer's IP address at time of modification.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of when this revision was created. Used for precise evidence chain.\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile.ISummary\"\n            },\n            \"description\": \"Attachment files list at this revision (may differ per snapshot, follows sequence/order property).\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_id\",\n          \"title\",\n          \"body\",\n          \"format\",\n          \"created_at\"\n        ]\n      },\n      \"IBbsArticleSnapshot.IUpdate\": {\n        \"type\": \"object\",\n        \"description\": \"Request schema for updating an article snapshot (admin/system only).\\n\\nAllows updating title/body/format or file association for special cases. For general users, only new snapshots are created instead.\",\n        \"properties\": {\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Updated title for this snapshot (optional).\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Updated body/content for this snapshot (optional).\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Updated format (e.g., html/md/txt) for this snapshot (optional).\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile.IUpdate\"\n            },\n            \"description\": \"Adjusted list of attached files for this snapshot.\"\n          }\n        },\n        \"required\": []\n      },\n      \"IBbsArticleSnapshot.IDelete\": {\n        \"type\": \"object\",\n        \"description\": \"Request body for logical deletion of an article snapshot (admin/system only).\\n\\nAs evidence, snapshots are generally not deleted, but this API allows logical deletion for policy/compliance needs. Fields for metadata or reason may be added.\",\n        \"properties\": {\n          \"reason\": {\n            \"type\": \"string\",\n            \"description\": \"Reason for deletion (optional, for audit/compliance logging).\"\n          }\n        },\n        \"required\": []\n      },\n      \"IBbsArticleSnapshotFile.IRequest\": {\n        \"type\": \"object\",\n        \"description\": \"Request schema for paginated listing/partial update/complex query of files attached to an article snapshot.\\n\\nUsed to filter, search, or modify attachment order for snapshot files. Maps sequences and handles per-snapshot association maintenance.\",\n        \"properties\": {\n          \"attachment_file_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Filter for specific attachment file UUID.\"\n          },\n          \"orderBy\": {\n            \"oneOf\": [\n              {\n                \"const\": \"createdAtDesc\",\n                \"description\": \"Sort order for files attached to a snapshot.\"\n              },\n              {\n                \"const\": \"createdAtAsc\",\n                \"description\": \"Sort order for files attached to a snapshot.\"\n              },\n              {\n                \"const\": \"sequenceAsc\",\n                \"description\": \"Sort order for files attached to a snapshot.\"\n              },\n              {\n                \"const\": \"sequenceDesc\",\n                \"description\": \"Sort order for files attached to a snapshot.\"\n              }\n            ],\n            \"description\": \"Sort order for files attached to a snapshot.\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\"\n          }\n        },\n        \"required\": []\n      },\n      \"IPage.IPagination\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"current\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Current page number.\\n\\nHelps the client understand which subset of total records is being viewed.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Number of records per page (default 100).\\n\\nAssists performance tuning for UI grids and API result limits.\"\n          },\n          \"records\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Total available records in the database matching current query.\\n\\nAllows accurate pagination and total count calculations.\"\n          },\n          \"pages\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Total number of pages available for the data set.\\n\\nComputed as records/limit with ceiling, helps navigation controls.\"\n          }\n        },\n        \"required\": [\n          \"current\",\n          \"limit\",\n          \"records\",\n          \"pages\"\n        ],\n        \"description\": \"Pagination metadata for paged OpenAPI results.\\n\\nStandardizes page navigation and client-side page controls per IPage<T>.\"\n      },\n      \"IBbsArticle.ISummary\": {\n        \"type\": \"object\",\n        \"description\": \"Summary data for a BBS article, for list display.\\n\\nSynced to list view requirements (title, writer, comment count, created_at, etc.). Does not include full snapshot/attachments/comments.\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the article.\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Author's name.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Title from the latest snapshot.\"\n          },\n          \"commentCount\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"description\": \"Number of comments attached (non-deleted only).\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Creation time for article.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Soft delete timestamp, if present.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Soft delete timestamp, if present.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"writer\",\n          \"title\",\n          \"commentCount\",\n          \"created_at\"\n        ]\n      },\n      \"IBbsArticleSnapshot.ISummary\": {\n        \"type\": \"object\",\n        \"description\": \"Summary view of an article snapshot.\\n\\nFor embedding only the essential info about the content body/version for displays or relationships. Contains fields such as title, body, format, and creation time.\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Snapshot UUID.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Title (as of this snapshot).\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Content/body of this snapshot.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Body format at the time (html/md/txt).\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"IP address for evidence (stored at snapshot creation).\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Snapshot creation date/time.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"title\",\n          \"body\",\n          \"format\",\n          \"created_at\"\n        ]\n      },\n      \"IBbsArticleSnapshotFile.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"attachment_file_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the attachment file to link (attachment_files.id).\\n\\nMust reference an existing uploaded file resource.\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Display order (sequence) for the file in this snapshot's file list.\\n\\nMandatory in UI/UX so that download or preview order can be explicit.\"\n          }\n        },\n        \"required\": [\n          \"attachment_file_id\",\n          \"sequence\"\n        ],\n        \"description\": \"Request body for attaching a file to a specific article snapshot in the BBS system.\\n\\nFields provide file reference (attachment_file_id) and ordering (sequence) per business needs and evidentiary requirements.\"\n      },\n      \"IBbsArticleSnapshotFile.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Updated display order (sequence) for this file in the snapshot.\\n\\nUtilized for user-driven attachment reordering or administrative correction.\"\n          }\n        },\n        \"required\": [\n          \"sequence\"\n        ],\n        \"description\": \"Request body for updating the attachment sequence/order in a given article snapshot's attachment file list.\\n\\nOnly reordering field (sequence) allowed for normal operations; for evidence preservation, other fields are not modifiable by typical users.\"\n      },\n      \"IBbsArticleSnapshotFile.ISummary\": {\n        \"type\": \"object\",\n        \"description\": \"Summary object for an individual file attached to an article snapshot (bbs_article_snapshot_files), for display in list/detail views.\\n\\nIncludes both the relationship (sequence, etc.) and the core file metadata (name, extension, url, created_at) from attachment_files.\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID relation key for the file in this snapshot (bbs_article_snapshot_files.id)\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Display order of the file in the snapshot.\"\n          },\n          \"file\": {\n            \"$ref\": \"#/components/schemas/IAttachmentFile.ISummary\",\n            \"description\": \"Basic metadata for the file asset (name, extension, url, created_at, etc.)\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"sequence\",\n          \"file\"\n        ]\n      },\n      \"IAttachmentFile.ISummary\": {\n        \"type\": \"object\",\n        \"description\": \"Summary view of attachment file info (attachment_files), for use in detail/list views.\\n\\nContains only identifying and most-accessed metadata properties for files attached to snapshots or comments.\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"File's unique ID (attachment_files.id)\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Filename, excluding extension.\"\n          },\n          \"extension\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"File extension (can be null, e.g., README)\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"File extension (can be null, e.g., README)\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"description\": \"URL link to actual file storage.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Time at which the file was added/registered.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"url\",\n          \"created_at\"\n        ]\n      },\n      \"IBbsArticleComment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the comment (bbs_article_comments.id).\"\n          },\n          \"bbs_article_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID for the parent article (bbs_articles.id) this comment belongs to.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Parent comment UUID (for replies/subcomments).\\n\\nNull for top-level comments.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Parent comment UUID (for replies/subcomments).\\n\\nNull for top-level comments.\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Display name of the comment's author (bbs_article_comments.writer).\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"When the comment was first created (bbs_article_comments.created_at).\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Logical deletion timestamp for evidence compliance. Null if active.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Logical deletion timestamp for evidence compliance. Null if active.\"\n          },\n          \"snapshots\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot\"\n            },\n            \"description\": \"Revision history snapshots for this comment.\\n\\nEach represents a modification state (title, body, files, IP, time, etc.).\"\n          },\n          \"children\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n            },\n            \"description\": \"Immediate child/nested replies. Recursive for unlimited hierarchy depth.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_id\",\n          \"writer\",\n          \"created_at\",\n          \"snapshots\"\n        ],\n        \"description\": \"Main comment entity for the evidence-preserving BBS system.\\n\\nMaps to bbs_article_comments, holds hierarchical relationships, attached snapshots, and logical deletion flags.\"\n      },\n      \"IPageIBbsArticleSnapshotFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"description\": \"Pagination information.\\n\\nIndicates the current page, page size, total record count, and number of pages. See IPage.IPagination for field-level details.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleSnapshotFile\"\n            },\n            \"description\": \"Array of files attached to the article snapshot on this page.\\n\\nEach entry represents a file relationship, including sequence/order and file metadata.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated list of files attached to an article snapshot, for the evidence-preserving bulletin board system.\\n\\nBased on the 'bbs_article_snapshot_files' and related attachment_files tables from the Prisma schema. Designed for performance in UI file listing and audit views. Includes detailed pagination and attachment sequence information.\"\n      },\n      \"IBbsArticleSnapshotFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary Key for this attachment relation (bbs_article_snapshot_files.id).\\n\\nUniquely identifies the relationship, not the physical file.\"\n          },\n          \"bbs_article_snapshot_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the snapshot to which this file is attached.\\n\\nReferences bbs_article_snapshots.id. Connects relationship and enables evidence-based traceability.\"\n          },\n          \"attachment_file_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the attached file (attachment_files.id).\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Display sequence within the list of this snapshot's attachments.\\n\\nUsed for end-user UX (order of preview/download) and for forensics.\"\n          },\n          \"file\": {\n            \"$ref\": \"#/components/schemas/IAttachmentFile\",\n            \"description\": \"Metadata about the attached file resource. See AttachmentFile for detailed member info.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_snapshot_id\",\n          \"attachment_file_id\",\n          \"sequence\",\n          \"file\"\n        ],\n        \"description\": \"Represents the file attachment relationship for a specific article snapshot in the evidence-preserving bulletin board system.\\n\\nBased on bbs_article_snapshot_files, includes file reference, sequence order, and resolved file metadata for full download and auditability.\"\n      },\n      \"IBbsArticleComment.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Optional page number for pagination.\\n\\nDefines which page of the comment list to fetch.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional page number for pagination.\\n\\nDefines which page of the comment list to fetch.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"How many comment entries should be returned per page (default 100).\\n\\nSupports UI efficiency and server protection.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"How many comment entries should be returned per page (default 100).\\n\\nSupports UI efficiency and server protection.\"\n          },\n          \"writer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Optional comment writer to filter results (bbs_article_comments.writer).\\n\\nEnables search by author display name.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional comment writer to filter results (bbs_article_comments.writer).\\n\\nEnables search by author display name.\"\n          },\n          \"created_at_from\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Optional lower bound for comment creation datetime.\\n\\nUsed for filtering searches by time window.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional lower bound for comment creation datetime.\\n\\nUsed for filtering searches by time window.\"\n          },\n          \"created_at_to\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Optional upper bound for comment creation datetime.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional upper bound for comment creation datetime.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Parent comment's ID. Used for hierarchy filtering.\\n\\nSet for displaying top-level comments (null) or replies (non-null).\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Parent comment's ID. Used for hierarchy filtering.\\n\\nSet for displaying top-level comments (null) or replies (non-null).\"\n          }\n        },\n        \"description\": \"Request parameters for listing, searching, and paging comments for an article.\\n\\nSupports flexible filtering by author, date, parent comment (for hierarchy), and standard pagination.\",\n        \"required\": []\n      },\n      \"IPageBbsArticleComment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"description\": \"Paging metadata for the comment list.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n            },\n            \"description\": \"Array of comments in this response page. Each contains BBS article comment metadata and references to parent/hierarchy info.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated response for a list of comments attached to an article in the evidence-preserving bulletin board system.\\n\\nBuilt upon bbs_article_comments.\"\n      },\n      \"IBbsArticleComment.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"bbs_article_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID of the parent article (bbs_articles.id) to which this comment is posted.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"UUID of the parent comment if this is a reply.\\n\\nFor flat comments, null. Enables unlimited depth hierarchies.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"UUID of the parent comment if this is a reply.\\n\\nFor flat comments, null. Enables unlimited depth hierarchies.\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Display name used for this comment's author. Stored in bbs_article_comments.writer.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"Password for comment modification/deletion.\\n\\nEncrypted in storage per evidence/compliance requirements.\"\n          },\n          \"initial_body\": {\n            \"type\": \"string\",\n            \"description\": \"The text body for the initial comment content (used in first snapshot record creation).\"\n          },\n          \"initial_format\": {\n            \"type\": \"string\",\n            \"description\": \"Format type of the comment body: 'md', 'html', 'txt', etc.\\n\\nAligns with the body format field in bbs_article_comment_snapshots.\"\n          },\n          \"initial_files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshotFile.ICreate\"\n            },\n            \"description\": \"Initial list of files attached to this comment when first posted.\\n\\nRelates to evidence/attachment mapping. Optional—may be empty.\"\n          }\n        },\n        \"required\": [\n          \"bbs_article_id\",\n          \"writer\",\n          \"password\",\n          \"initial_body\",\n          \"initial_format\"\n        ],\n        \"description\": \"Request body to create a new comment on a BBS article.\\n\\nInitial content/format and files are included for atomic evidence creation and ease of use.\"\n      },\n      \"IBbsArticleComment.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"writer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"If updated, replaces current display name for comment's author.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"If updated, replaces current display name for comment's author.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"If changed, will update nesting/parent of the comment.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"If changed, will update nesting/parent of the comment.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"New password value, if changed.\\n\\nStored securely (hash/encrypt) per evidence/audit policy.\"\n          }\n        },\n        \"description\": \"Editable fields for updating a comment's metadata/relationships in bbs_article_comments.\\n\\nComment body/content is not updated here (managed via snapshot creation).\",\n        \"required\": []\n      },\n      \"IBbsArticleCommentSnapshot.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Page number for snapshot history pagination.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Page number for snapshot history pagination.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Number of snapshots per page; default is 100.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Number of snapshots per page; default is 100.\"\n          }\n        },\n        \"description\": \"Request body for paginated retrieval of a comment's revision snapshot history.\\n\\nUsed in PATCH /bbs/articles/{articleId}/comments/{commentId}/snapshots.\",\n        \"required\": []\n      },\n      \"IPageBbsArticleCommentSnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"description\": \"Pagination information for comment snapshot history.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot\"\n            },\n            \"description\": \"Snapshots found for this comment and page.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated response for a comment's snapshot history in the evidence-preserving BBS.\\n\\nMaps from bbs_article_comment_snapshots and associated relationships.\"\n      },\n      \"IBbsArticleCommentSnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary key of the comment snapshot (bbs_article_comment_snapshots.id).\"\n          },\n          \"bbs_article_comment_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID of the parent comment this snapshot is for.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Format of the snapshot's text body (md/html/txt/...).\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Body/content text of the comment at this revision.\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"Writer's IP at this revision for evidence purposes.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Revision/snapshot creation timestamp.\"\n          },\n          \"files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshotFile\"\n            },\n            \"description\": \"Array of files attached to this specific snapshot version.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_comment_id\",\n          \"format\",\n          \"body\",\n          \"ip\",\n          \"created_at\"\n        ],\n        \"description\": \"Snapshot version record for a BBS article comment in the evidence-preserving system.\\n\\nAllows auditability of all edits, preserving prior versions and attached files.\"\n      },\n      \"IBbsArticleCommentSnapshotFile.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"attachment_file_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The file's system UUID to link.\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Order/position for file display.\"\n          }\n        },\n        \"required\": [\n          \"attachment_file_id\",\n          \"sequence\"\n        ],\n        \"description\": \"Used for initial file attachment when creating a new comment snapshot.\"\n      },\n      \"IBbsArticleCommentSnapshotFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary key (join record) for comment snapshot to file attachment.\"\n          },\n          \"bbs_article_comment_snapshot_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Comment snapshot this file is associated with.\"\n          },\n          \"attachment_file_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The linked file's unique system id.\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"File ordering for user-facing presentation and audit.\"\n          },\n          \"file\": {\n            \"$ref\": \"#/components/schemas/IAttachmentFile\",\n            \"description\": \"File resource metadata—name, extension, URL, upload info, etc.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_comment_snapshot_id\",\n          \"attachment_file_id\",\n          \"sequence\",\n          \"file\"\n        ],\n        \"description\": \"Models relationship between a comment snapshot and an attached file in the evidence system.\\n\\nMirrors bbs_article_comment_snapshot_files in Prisma with metadata for retrieval/rendering/audit.\"\n      },\n      \"IAttachmentFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary key of the attachment file resource (attachment_files.id).\\n\\nGuarantees unique identification for download, display, and management.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"File name (without extension).\\n\\nDirectly from attachment_files.name; guides human-readable file listings.\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"description\": \"File extension if present (nullable).\\n\\nTaken from attachment_files.extension, may be null for files like README or LICENSE.\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"description\": \"File URL for download/storage reference.\\n\\nProvided by attachment_files.url in the Prisma schema.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp of file creation (ISO 8601).\\n\\nFrom attachment_files.created_at; ensures evidence and lifecycle audit for this resource.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"url\",\n          \"created_at\"\n        ],\n        \"description\": \"Attachment file resource object for all file entities (attachment_files).\\n\\nRepresents a managed asset for evidence, with metadata used throughout the BBS UI and evidence system.\"\n      },\n      \"IBbsArticleCommentSnapshot.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Format of the comment content body (e.g., 'html', 'md', 'txt').\\n\\nCorresponds to the 'format' column in bbs_article_comment_snapshots, denoting the format of the comment body for the specific snapshot.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Content body of the comment.\\n\\nReflects the 'body' in bbs_article_comment_snapshots, holding the modified text of this specific revision.\"\n          },\n          \"to_files\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/ICommentSnapshotFile.ICreate\"\n            },\n            \"description\": \"List of file associations to be attached with this snapshot update.\\n\\nReferences new or changed file linkage when updating the snapshot. Each file entry conforms to ICommentSnapshotFile.ICreate.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Update request body for a comment snapshot (bbs_article_comment_snapshots).\\n\\nAllows admin/system-level correction of snapshot details: format, body, and updated file attachments. Fulfills evidentiary correction by privileged actors as described in BBS requirements and Prisma schema.\"\n      },\n      \"ICommentSnapshotFile.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"file_ids\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Array of attachment file UUIDs to associate with the comment snapshot.\\n\\nReflects intended linkage/reordering/removal during partial update of the snapshot's file attachments. Must correspond to valid attachment_files records.\"\n          },\n          \"sequences\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"integer\"\n            },\n            \"description\": \"Optional mapping for the display order (sequence) of the files.\\n\\nAllows explicit reordering of file attachments for UI/UX accuracy; order must match file_ids array if included.\"\n          }\n        },\n        \"required\": [\n          \"file_ids\"\n        ],\n        \"description\": \"Request body for partial update of attachment files for a comment snapshot (bbs_article_comment_snapshot_files).\\n\\nUsed to reorder, add, or remove associations, maintaining the correct sequence field per UI and evidence requirements.\"\n      },\n      \"ICommentSnapshotFile.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary key of the attachment file relationship (bbs_article_comment_snapshot_files.id).\\n\\nUnique identifier for the attachment mapping for audit and management.\"\n          },\n          \"file\": {\n            \"$ref\": \"#/components/schemas/IAttachmentFile\",\n            \"description\": \"Metadata of the attached file at this sequence/relationship.\\n\\nLinks to the actual file resource in attachment_files, enabling metadata retrieval such as filename, extension, and URL.\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Display order (sequence) for the file in the comment snapshot.\\n\\nEnsures the intended order of files for the given revision. Sourced from the 'sequence' column of bbs_article_comment_snapshot_files.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"file\",\n          \"sequence\"\n        ],\n        \"description\": \"Summary type for a file association in a comment snapshot (bbs_article_comment_snapshot_files), including file metadata and order.\\n\\nProvides ordering and audit fields for client-side rendering and review in revision history UIs.\"\n      },\n      \"ICommentSnapshotFile.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"attachment_file_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID of the file to be attached (attachment_files.id).\\n\\nReferences a pre-uploaded file for association with the comment snapshot mapping.\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Display order (sequence) for this file in the snapshot.\\n\\nRepresents the association's intended display order as seen by users.\"\n          }\n        },\n        \"required\": [\n          \"attachment_file_id\",\n          \"sequence\"\n        ],\n        \"description\": \"Request body for creating a new attached file record in a comment snapshot (bbs_article_comment_snapshot_files).\\n\\nSupplies file and sequence information to establish a new file association under the BBS comment revision evidence framework.\"\n      },\n      \"ICommentSnapshotFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Primary key (ID) for the file association (bbs_article_comment_snapshot_files.id).\\n\\nUniquely identifies this mapping between comment snapshot and attachment file.\"\n          },\n          \"bbs_article_comment_snapshot_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID indicating the snapshot this file is attached to (bbs_article_comment_snapshots.id).\\n\\nEstablishes relationship context for this attachment mapping.\"\n          },\n          \"attachment_file_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID of the attached file record (attachment_files.id).\\n\\nConnects association to the actual file record for download/display.\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"The display order (sequence) in the snapshot list (bbs_article_comment_snapshot_files.sequence).\\n\\nUsed for rendering attached files in the correct order.\"\n          },\n          \"file\": {\n            \"$ref\": \"#/components/schemas/IAttachmentFile\",\n            \"description\": \"File metadata for the associated file resource (attachment_files).\\n\\nEnables in-context display, download, and audit in UI clients.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_comment_snapshot_id\",\n          \"attachment_file_id\",\n          \"sequence\"\n        ],\n        \"description\": \"Attachment file association for comment snapshots (bbs_article_comment_snapshot_files).\\n\\nRepresents the evidentiary link between a snapshot version and an attachment file, with rich details and order management, referencing Prisma schema join structure.\"\n      },\n      \"ICommentSnapshotFile.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Update the file's display order (sequence value) in the association record.\\n\\nDirectly alters the sequence column to reorder attachments.\"\n          }\n        },\n        \"required\": [\n          \"sequence\"\n        ],\n        \"description\": \"Update model for an attachment file mapping (bbs_article_comment_snapshot_files) for a comment snapshot.\\n\\nPrimarily used for resequencing file attachments as per UI/UX needs; only sequence can be changed in evidence context.\"\n      },\n      \"IAttachmentFile.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"File name (without extension) to search/filter.\\n\\nCorresponds to the 'name' attribute in attachment_files; supports partial-matching, case-insensitive filters.\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"description\": \"File extension to search/filter (optional).\\n\\nChecks the 'extension' column in attachment_files; can be null or empty for extensionless files.\"\n          },\n          \"created_at_min\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Minimum file creation time for filter (ISO 8601 format).\\n\\nMatches attachment_files.created_at greater or equal for time-based queries.\"\n          },\n          \"created_at_max\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Maximum file creation time for filter (ISO 8601 format).\\n\\nMatches attachment_files.created_at less or equal for time-based queries.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Request body for searching/filtering attachment files (attachment_files).\\n\\nProvides a variety of fields for querying files for BBS management UI, per requirements.\"\n      },\n      \"IPageIAttachmentFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"description\": \"Pagination metadata for file list results.\\n\\nIncludes page number, limit, total records, and pages for UI and API usability.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            },\n            \"description\": \"Attachment file data entries for this page of results.\\n\\nEach entry corresponds to a file metadata record defined in attachment_files.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paged result container for attachment file search results (attachment_files).\\n\\nFollows IPage<T> interface for consistency, referencing Prisma indexing and UI performance requirements.\"\n      },\n      \"IAttachmentFile.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"File name, without extension.\\n\\nAs per attachment_files.name; provides semantic name used for identifying files by users and clients.\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"description\": \"File extension (nullable).\\n\\nCorresponds to attachment_files.extension, allows for both normal and extensionless files (e.g., README).\\nMay be null or omitted.\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"description\": \"URL of the physical file resource.\\n\\nMatches attachment_files.url; must be a valid, accessible path or download location for this resource.\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"url\"\n        ],\n        \"description\": \"Request body to create a new file record in the attachment_files table.\\n\\nAll fields necessary for building file metadata and supporting system evidence requirements.\"\n      },\n      \"IAttachmentFile.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"New file name without extension.\\n\\nUpdates the attachment_files.name field for renamed assets.\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"description\": \"New or updated extension (nullable).\\n\\nModifies attachment_files.extension; supports cases like file format correction or metadata update.\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"description\": \"New or corrected file URL.\\n\\nMay be used if the file has been re-uploaded or migrated to new storage.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Update model for editing attributes of an attachment file record (attachment_files).\\n\\nSupports correction and data hygiene activities by admins or automation systems.\"\n      }\n    }\n  },\n  \"x-samchon-emended-v4\": true\n}",
    "README.md": "# AutoBE Generated Backend Server\r\n\r\n![AutoBE Logo](https://github.com/user-attachments/assets/a90d14be-fd50-4dc7-ae9d-ca66c2124f31)\r\n\r\nA backend repository generated by [`@autobe`](https://github.com/wrtnlabs/autobe).\r\n\r\nThis backend program was automatically generated using [`@autobe`](https://github.com/wrtnlabs/autobe), the AI vibe coding agent for backend servers of below stack.\r\n\r\n- TypeScript\r\n- NestJS / Nestia\r\n- Prisma\r\n- Postgres\r\n\r\n## Project Structure\r\n\r\nThis template project has categorized directories like below.\r\n\r\nAs you can see from the below, all of the Backend source files are placed into the [src](src/) directory. When you build the TypeScript source files, compiled files would be placed into the `lib` directory following the [tsconfig.json](tsconfig.json) configuration. Otherwise you build client [SDK](#32-sdk) library for npm publishing and their compiled files would be placed into the [packages](packages) directory.\r\n\r\n  - [packages/api/](packages/api): SDK module built by `npm run build:api`\r\n  - [src/](src): Backend source directory\r\n    - [src/api/](src/api/): Client SDK that would be published to the `@ORGANIZATION/PROJECT-api`\r\n      - [**src/api/functional/**](src/api/functional/): API functions generated by the [`nestia`](https://github.com/samchon/nestia)\r\n      - [**src/api/structures/**](src/api/structures/): DTO structures\r\n    - [src/controllers/](src/controllers/): Controller classes of the Main Program\r\n  - [**test/**](test): Test Automation Program\r\n    - [test/features](test/features): List of test functions\r\n  - [nestia.config.ts](nestia.config.ts): Configuration file of [`nestia`](https://github.com/samchon/nestia)\r\n  - [package.json](package.json): NPM configuration\r\n  - [tsconfig.json](tsconfig.json): TypeScript configuration for the main program\r\n\r\n## NPM Run Commands\r\n\r\nList of the run commands defined in the [package.json](package.json) are like below:\r\n\r\n  - Test\r\n    - **`test`**: Run test automation program\r\n    - `benchmark`: Run performance benchmark program\r\n  - Build\r\n    - `build`: Build everything\r\n    - `build:main`: Build main program (`src` directory)\r\n    - `build:test` Build test automation program (`test` directory)\r\n    - `build:sdk`: Build SDK into main program only\r\n    - `build:swagger`: Build Swagger Documents\r\n    - **`dev`**: Incremental build for development (test program)\r\n  - Deploy\r\n    - `package:api`: Build and deploy the SDK library to the NPM\r\n    - `start`: Start the backend server\r\n    - `start:dev`: Start the backend server with incremental build and reload\r\n  - Webpack\r\n    - `webpack`: Run webpack bundler\r\n    - `webpack:start`: Start the backend server built by webpack\r\n    - `webpack:test`: Run test program to the webpack built\r\n\r\n## Specialization\r\n\r\nTransform this template project to be yours.\r\n\r\nWhen you've created a new backend project through this template project, you can specialize it to be suitable for you by changing some words. Replace below words through IDE specific function like `Edit > Replace in Files` (*Ctrl + Shift + H*), who've been supported by the VSCode.\r\n\r\n| Before       | After\r\n|--------------|----------------------------------------\r\n| ORGANIZATION | Your account or corporation name\r\n| PROJECT      | Your own project name\r\n| AUTHOR       | Author name\r\n| https://github.com/samchon/nestia-start | Your repository URL"
  },
  "reason": "Step to the interface designing after DB schema generation",
  "step": 1,
  "created_at": "2025-05-26T15:00:13.117Z",
  "completed_at": "2025-05-26T15:03:10.818Z"
}