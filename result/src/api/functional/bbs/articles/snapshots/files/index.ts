import { IConnection, HttpError } from "@nestia/fetcher";
import typia, { tags } from "typia";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IBbsArticleSnapshotFile } from "../../../../../structures/IBbsArticleSnapshotFile";
import { IPageIBbsArticleSnapshotFile } from "../../../../../structures/IPageIBbsArticleSnapshotFile";

/**
 * Attach one or more files to a specific snapshot of an article
 * ('bbs_article_snapshot_files'), returning updated file list.
 *
 * This API attaches files to a specific article snapshot. It accepts file IDs
 * (already uploaded via separate process) or requires necessary file metadata
 * if uploading new files. For existing files, establishes the link via
 * 'bbs_article_snapshot_files'; for new uploads, creates a file record in
 * 'attachment_files' then associates it.
 *
 * Sequence/order is essential (for display order). Validation checks that files
 * exist or are newly proper. Security: normal user edits require proper
 * authentication; admin/system roles may bypass restrictions for
 * evidence.</br>
 *
 * Returns updated list of attachments, with all associated metadata for the
 * snapshot. Related: PATCH for updating the order, DELETE for deleting
 * attachments.
 *
 * @param articleId UUID of the article of the snapshot being modified.
 * @param snapshotId UUID of the snapshot to attach files to.
 * @param body Attachment file information to link/upload for this snapshot,
 *   plus order.
 * @path /bbs/articles/:articleId/snapshots/:snapshotId/files
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function postByArticleidAndSnapshotid(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  body: postByArticleidAndSnapshotid.Input,
): Promise<postByArticleidAndSnapshotid.Output> {
  return !!connection.simulate
    ? postByArticleidAndSnapshotid.simulate(
        connection,
        articleId,
        snapshotId,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...postByArticleidAndSnapshotid.METADATA,
          path: postByArticleidAndSnapshotid.path(articleId, snapshotId),
          status: null,
        },
        body,
      );
}
export namespace postByArticleidAndSnapshotid {
  export type Input = IBbsArticleSnapshotFile.ICreate;
  export type Output = IPageIBbsArticleSnapshotFile;

  export const METADATA = {
    method: "POST",
    path: "/bbs/articles/:articleId/snapshots/:snapshotId/files",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIBbsArticleSnapshotFile =>
    typia.random<IPageIBbsArticleSnapshotFile>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    body: postByArticleidAndSnapshotid.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: postByArticleidAndSnapshotid.path(articleId, snapshotId),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List all attachment files for a specific article snapshot (by
 * articleId/snapshotId), using 'bbs_article_snapshot_files'.
 *
 * This API fetches all files attached to a specific revision (snapshot) of an
 * article. Filters on articleId and snapshotId provide the explicit context to
 * retrieve sequence/order of files, file metadata (name, extension, URL,
 * creation time, sequence). Pagination can be included for snapshots with many
 * files.
 *
 * Related operations: POST for attaching new files to a revision, DELETE for
 * removing files, PATCH for reordering/updating attachment list.
 *
 * Attachment files must be publicly accessible (with proper security tokens if
 * required).
 *
 * @param articleId UUID of the article of the snapshot.
 * @param snapshotId UUID of the article snapshot whose files are being listed.
 * @param body Options for filtering or paging attached files for this snapshot.
 * @path /bbs/articles/:articleId/snapshots/:snapshotId/files
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByArticleidAndSnapshotid(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  body: patchByArticleidAndSnapshotid.Input,
): Promise<patchByArticleidAndSnapshotid.Output> {
  return !!connection.simulate
    ? patchByArticleidAndSnapshotid.simulate(
        connection,
        articleId,
        snapshotId,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByArticleidAndSnapshotid.METADATA,
          path: patchByArticleidAndSnapshotid.path(articleId, snapshotId),
          status: null,
        },
        body,
      );
}
export namespace patchByArticleidAndSnapshotid {
  export type Input = IBbsArticleSnapshotFile.IRequest;
  export type Output = IPageIBbsArticleSnapshotFile;

  export const METADATA = {
    method: "PATCH",
    path: "/bbs/articles/:articleId/snapshots/:snapshotId/files",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIBbsArticleSnapshotFile =>
    typia.random<IPageIBbsArticleSnapshotFile>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    body: patchByArticleidAndSnapshotid.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByArticleidAndSnapshotid.path(articleId, snapshotId),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get a specific attached file (bbs_article_snapshot_files) in a snapshot of an
 * article.
 *
 * This GET operation retrieves a particular file attached to a specific
 * snapshot of an article in the bulletin board system.
 *
 * The endpoint path parameters (articleId, snapshotId, id) represent the
 * article UUID, the snapshot UUID, and the file attachment relation UUID
 * (bbs_article_snapshot_files.id) respectively. This strict mapping ensures the
 * file's association is under the correct article version, upholding
 * evidentiary record accuracy as described in the requirements.
 *
 * Security considerations include verifying the logical existence of the parent
 * article and snapshot (not deleted), and checking the user's permission for
 * file access.
 *
 * Returns metadata about the attachment (order, file metadata, and URL for
 * download). Relies on the correct structure and associations as maintained
 * within the attachment_files and bbs_article_snapshot_files Prisma models.
 *
 * Handles errors such as not-found (404) if any ancestor entity does not exist
 * or is inaccessible, and forbidden (403) for unauthorized access attempts.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param snapshotId Target snapshot ID (UUID) in bbs_article_snapshots
 * @param id Attachment relation ID in bbs_article_snapshot_files
 * @path /bbs/articles/:articleId/snapshots/:snapshotId/files/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByArticleidAndSnapshotidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
): Promise<getByArticleidAndSnapshotidAndId.Output> {
  return !!connection.simulate
    ? getByArticleidAndSnapshotidAndId.simulate(
        connection,
        articleId,
        snapshotId,
        id,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByArticleidAndSnapshotidAndId.METADATA,
          path: getByArticleidAndSnapshotidAndId.path(
            articleId,
            snapshotId,
            id,
          ),
          status: null,
        },
      );
}
export namespace getByArticleidAndSnapshotidAndId {
  export type Output = IBbsArticleSnapshotFile;

  export const METADATA = {
    method: "GET",
    path: "/bbs/articles/:articleId/snapshots/:snapshotId/files/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleSnapshotFile => typia.random<IBbsArticleSnapshotFile>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByArticleidAndSnapshotidAndId.path(articleId, snapshotId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.param("id")(() => typia.assert(id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update attachment file entry (bbs_article_snapshot_files) metadata for a
 * given article snapshot.
 *
 * This PUT operation updates the mapping information for a specific file
 * attached to an article snapshot. A typical use case includes resequencing
 * file orders or changing ancillary metadata about this attachment (the file
 * itself is immutable for evidence, but linkage/metadata can change for the
 * active revision).
 *
 * Requires verification of the parent article (not deleted), parent snapshot,
 * and correct ownership/permissions, as defined by the evidentiary and logical
 * deletion model.
 *
 * The request body structure corresponds to updates for the
 * 'bbs_article_snapshot_files' record, such as sequence reordering.
 *
 * Update is restricted to the targeted relation and does not affect historical
 * data in previous snapshots.
 *
 * Handles error states including not-found for any path element, permission
 * denial, and validation for business rules (e.g., not modifying a
 * locked/evidence snapshot).
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param snapshotId Target snapshot ID (UUID) in bbs_article_snapshots
 * @param id Attachment relation ID in bbs_article_snapshot_files
 * @param body Info to update the attached file relation (e.g., sequence order)
 *   in a snapshot.
 * @path /bbs/articles/:articleId/snapshots/:snapshotId/files/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByArticleidAndSnapshotidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
  body: putByArticleidAndSnapshotidAndId.Input,
): Promise<putByArticleidAndSnapshotidAndId.Output> {
  return !!connection.simulate
    ? putByArticleidAndSnapshotidAndId.simulate(
        connection,
        articleId,
        snapshotId,
        id,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByArticleidAndSnapshotidAndId.METADATA,
          path: putByArticleidAndSnapshotidAndId.path(
            articleId,
            snapshotId,
            id,
          ),
          status: null,
        },
        body,
      );
}
export namespace putByArticleidAndSnapshotidAndId {
  export type Input = IBbsArticleSnapshotFile.IUpdate;
  export type Output = IBbsArticleSnapshotFile;

  export const METADATA = {
    method: "PUT",
    path: "/bbs/articles/:articleId/snapshots/:snapshotId/files/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleSnapshotFile => typia.random<IBbsArticleSnapshotFile>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
    body: putByArticleidAndSnapshotidAndId.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByArticleidAndSnapshotidAndId.path(articleId, snapshotId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.param("id")(() => typia.assert(id));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Delete (logically unlink) a file from a snapshot (bbs_article_snapshot_files)
 * of an article.
 *
 * This DELETE operation logically removes (unlinks) an attachment file from a
 * specific article snapshot in the system. The operation targets the entry in
 * 'bbs_article_snapshot_files', marking it as logically deleted if required by
 * implementation, while preserving evidence as per requirements.
 *
 * Deleted file entries should no longer display for the target snapshot, but
 * all historical records and actual file data are preserved for audit and
 * evidence. Parent entity existence (article, snapshot) and permissions are
 * always validated.
 *
 * This operation may trigger side-effects such as reordering remaining files or
 * revising display metadata for the snapshot, but never deletes actual file
 * content.
 *
 * Errors handled include not-found for non-existing entities or relations,
 * permission denial, and violation of audit-evidence policies.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param snapshotId Target snapshot ID (UUID) in bbs_article_snapshots
 * @param id Attachment relation ID in bbs_article_snapshot_files
 * @path /bbs/articles/:articleId/snapshots/:snapshotId/files/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseByArticleidAndSnapshotidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
): Promise<eraseByArticleidAndSnapshotidAndId.Output> {
  return !!connection.simulate
    ? eraseByArticleidAndSnapshotidAndId.simulate(
        connection,
        articleId,
        snapshotId,
        id,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByArticleidAndSnapshotidAndId.METADATA,
          path: eraseByArticleidAndSnapshotidAndId.path(
            articleId,
            snapshotId,
            id,
          ),
          status: null,
        },
      );
}
export namespace eraseByArticleidAndSnapshotidAndId {
  export type Output = IBbsArticleSnapshotFile;

  export const METADATA = {
    method: "DELETE",
    path: "/bbs/articles/:articleId/snapshots/:snapshotId/files/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleSnapshotFile => typia.random<IBbsArticleSnapshotFile>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByArticleidAndSnapshotidAndId.path(articleId, snapshotId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.param("id")(() => typia.assert(id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
