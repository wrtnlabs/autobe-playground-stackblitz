import { IConnection, HttpError } from "@nestia/fetcher";
import typia, { tags } from "typia";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IBbsArticleSnapshot } from "../../../../structures/IBbsArticleSnapshot";
import { IPageIBbsArticleSnapshot } from "../../../../structures/IPageIBbsArticleSnapshot";
export * as files from "./files";

/**
 * Get all revision snapshots for a given article ('bbs_article_snapshots'
 * table, by articleId), with pagination.
 *
 * This API lists all snapshots (modification revisions) for a specific article
 * from the 'bbs_article_snapshots' table using the article's ID. Each snapshot
 * includes title, body format, creation timestamp, ip address, and list of
 * attachment files for that version.
 *
 * Supports pagination, important for heavily-edited articles (for performance).
 * Access is generally open, but some security logic may be applied to deleted
 * or restricted articles.
 *
 * Related operations: PATCH /bbs/articles for lists, GET /bbs/articles/{id} for
 * details, GET /bbs/articles/{articleId}/snapshots/{id} for individual
 * revision.
 *
 * @param articleId UUID of the article whose snapshots are being listed.
 * @param body Optional pagination and filter parameters for snapshot history.
 * @path /bbs/articles/:articleId/snapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByArticleid(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  body: patchByArticleid.Input,
): Promise<patchByArticleid.Output> {
  return !!connection.simulate
    ? patchByArticleid.simulate(connection, articleId, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByArticleid.METADATA,
          path: patchByArticleid.path(articleId),
          status: null,
        },
        body,
      );
}
export namespace patchByArticleid {
  export type Input = IBbsArticleSnapshot.IRequest;
  export type Output = IPageIBbsArticleSnapshot;

  export const METADATA = {
    method: "PATCH",
    path: "/bbs/articles/:articleId/snapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (articleId: string & tags.Format<"uuid">) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/snapshots`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageIBbsArticleSnapshot => typia.random<IPageIBbsArticleSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    body: patchByArticleid.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByArticleid.path(articleId),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Get detail of a specific snapshot for a given article
 * ('bbs_article_snapshots' table, by articleId and snapshotId).
 *
 * This API fetches a single snapshot (revision) of a given article using both
 * IDs. The response includes the title, body, format, ip address, and the list
 * of related attachments stored at the time of this revision. Used for
 * auditing, difference viewing, or legal evidence of changes.
 *
 * Security checks ensure access to the underlying article. If the snapshot does
 * not exist or is not linked to the specified article, a 'not found' is
 * returned. No soft-delete applies to originals here; evidence is never
 * removed.
 *
 * Related: PATCH /bbs/articles/{articleId}/snapshots for revision history.
 *
 * @param articleId UUID of the article to which the snapshot belongs.
 * @param id UUID of the snapshot to fetch.
 * @path /bbs/articles/:articleId/snapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByArticleidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
): Promise<getByArticleidAndId.Output> {
  return !!connection.simulate
    ? getByArticleidAndId.simulate(connection, articleId, id)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByArticleidAndId.METADATA,
          path: getByArticleidAndId.path(articleId, id),
          status: null,
        },
      );
}
export namespace getByArticleidAndId {
  export type Output = IBbsArticleSnapshot;

  export const METADATA = {
    method: "GET",
    path: "/bbs/articles/:articleId/snapshots/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/snapshots/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleSnapshot => typia.random<IBbsArticleSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByArticleidAndId.path(articleId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("id")(() => typia.assert(id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update content or metadata of a specific article snapshot
 * ('bbs_article_snapshots' table, by articleId and snapshotId); admin/system
 * only.
 *
 * This API updates a snapshot 'bbs_article_snapshots' record. Normally,
 * snapshot changes are forbidden for users (evidence preservation), but certain
 * admin/system roles may execute corrections (e.g., unlawful content, typo
 * fix). Updates may include modifications to title, body, format, or attachment
 * relations; logs must track all changes for auditing.
 *
 * Security: restricted to admins or evidence maintainers. Standard validations
 * apply, and revert possible for audit reasons. Related to PATCH
 * /bbs/articles/{articleId}/snapshots.
 *
 * @param articleId UUID of the article containing the snapshot.
 * @param id UUID of the snapshot to update.
 * @param body Snapshot fields to update (title/body/attachments/format).
 *   Usually only by admin/system.
 * @path /bbs/articles/:articleId/snapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByArticleidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
  body: putByArticleidAndId.Input,
): Promise<putByArticleidAndId.Output> {
  return !!connection.simulate
    ? putByArticleidAndId.simulate(connection, articleId, id, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByArticleidAndId.METADATA,
          path: putByArticleidAndId.path(articleId, id),
          status: null,
        },
        body,
      );
}
export namespace putByArticleidAndId {
  export type Input = IBbsArticleSnapshot.IUpdate;
  export type Output = IBbsArticleSnapshot;

  export const METADATA = {
    method: "PUT",
    path: "/bbs/articles/:articleId/snapshots/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/snapshots/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleSnapshot => typia.random<IBbsArticleSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
    body: putByArticleidAndId.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByArticleidAndId.path(articleId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("id")(() => typia.assert(id));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Logically delete a snapshot of an article ('bbs_article_snapshots'),
 * admin/system only, for evidence management.
 *
 * This API marks a specific article snapshot as deleted (logically), removing
 * it from default user access. The actual snapshot record is not physically
 * deleted, preserving historical evidence and references, but a status or
 * timestamp is set as deleted.
 *
 * Security: strictly restricted to admin/system users. Normal users cannot
 * delete snapshots (only create new ones for revisions). Soft-deleted snapshots
 * may be included in audit/admin views with proper roles.
 *
 * Related: PATCH /bbs/articles/{articleId}/snapshots for revisions, GET
 * /bbs/articles/{articleId}/snapshots/{id} for detail.
 *
 * @param articleId UUID of the article containing the snapshot.
 * @param id UUID of the snapshot to delete.
 * @param body Credentials or reason for deletion (admin/system use only).
 * @path /bbs/articles/:articleId/snapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseByArticleidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
  body: eraseByArticleidAndId.Input,
): Promise<eraseByArticleidAndId.Output> {
  return !!connection.simulate
    ? eraseByArticleidAndId.simulate(connection, articleId, id, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByArticleidAndId.METADATA,
          path: eraseByArticleidAndId.path(articleId, id),
          status: null,
        },
        body,
      );
}
export namespace eraseByArticleidAndId {
  export type Input = IBbsArticleSnapshot.IDelete;
  export type Output = IBbsArticleSnapshot;

  export const METADATA = {
    method: "DELETE",
    path: "/bbs/articles/:articleId/snapshots/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/snapshots/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleSnapshot => typia.random<IBbsArticleSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
    body: eraseByArticleidAndId.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByArticleidAndId.path(articleId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("id")(() => typia.assert(id));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
