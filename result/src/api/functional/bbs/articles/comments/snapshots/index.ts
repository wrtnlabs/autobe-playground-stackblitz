import { IConnection, HttpError } from "@nestia/fetcher";
import typia, { tags } from "typia";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IBbsArticleCommentSnapshot } from "../../../../../structures/IBbsArticleCommentSnapshot";
import { IPageBbsArticleCommentSnapshot } from "../../../../../structures/IPageBbsArticleCommentSnapshot";
export * as files from "./files";

/**
 * List all snapshots (bbs_article_comment_snapshots) for a comment on an
 * article, with search/pagination.
 *
 * This PATCH operation retrieves all snapshots (revision history) for a given
 * comment attached to an article. Returns paginated and/or filtered results,
 * including metadata such as format, timestamp, author IP, and relevant
 * attachments (linkage only). This allows evidence presentation and rollback
 * investigation for all comment changes.
 *
 * Access is restricted depending on logical deletion status and permissions
 * (admins vs. general users). Snapshots provide information for audit, dispute
 * resolution, or version comparison in the UI.
 *
 * Handles errors for invalid parameters, not-found comment/article ancestors,
 * and respects maximum page size/policy limits.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param commentId Comment ID in bbs_article_comments to which the snapshots
 *   belong
 * @param body Parameters for searching, pagination, and filtering of comment
 *   snapshots.
 * @path /bbs/articles/:articleId/comments/:commentId/snapshots
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByArticleidAndCommentid(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  commentId: string & tags.Format<"uuid">,
  body: patchByArticleidAndCommentid.Input,
): Promise<patchByArticleidAndCommentid.Output> {
  return !!connection.simulate
    ? patchByArticleidAndCommentid.simulate(
        connection,
        articleId,
        commentId,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByArticleidAndCommentid.METADATA,
          path: patchByArticleidAndCommentid.path(articleId, commentId),
          status: null,
        },
        body,
      );
}
export namespace patchByArticleidAndCommentid {
  export type Input = IBbsArticleCommentSnapshot.IRequest;
  export type Output = IPageBbsArticleCommentSnapshot;

  export const METADATA = {
    method: "PATCH",
    path: "/bbs/articles/:articleId/comments/:commentId/snapshots",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(commentId ?? "null")}/snapshots`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageBbsArticleCommentSnapshot =>
    typia.random<IPageBbsArticleCommentSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    body: patchByArticleidAndCommentid.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByArticleidAndCommentid.path(articleId, commentId),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("commentId")(() => typia.assert(commentId));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a specific comment snapshot (bbs_article_comment_snapshots) for a
 * given comment on an article.
 *
 * This GET operation retrieves a single revision snapshot for a comment
 * (bbs_article_comment_snapshots). The snapshot is uniquely identified by its
 * attachment to a specific article, comment, and snapshot UUID.
 *
 * Returns detailed information about the snapshot content, including format,
 * body, creation metadata, author IP, and file attachments (linkage only —
 * actual files accessed through separate API calls).
 *
 * Fails with not-found errors if any identified entity does not exist or is not
 * accessible, and enforces necessary permissions and logical deletion rules.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param commentId Comment ID in bbs_article_comments to which the snapshot
 *   belongs
 * @param id Comment snapshot ID (UUID) in bbs_article_comment_snapshots
 * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByArticleidAndCommentidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  commentId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
): Promise<getByArticleidAndCommentidAndId.Output> {
  return !!connection.simulate
    ? getByArticleidAndCommentidAndId.simulate(
        connection,
        articleId,
        commentId,
        id,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByArticleidAndCommentidAndId.METADATA,
          path: getByArticleidAndCommentidAndId.path(articleId, commentId, id),
          status: null,
        },
      );
}
export namespace getByArticleidAndCommentidAndId {
  export type Output = IBbsArticleCommentSnapshot;

  export const METADATA = {
    method: "GET",
    path: "/bbs/articles/:articleId/comments/:commentId/snapshots/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(commentId ?? "null")}/snapshots/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleCommentSnapshot => typia.random<IBbsArticleCommentSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByArticleidAndCommentidAndId.path(articleId, commentId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("commentId")(() => typia.assert(commentId));
      assert.param("id")(() => typia.assert(id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update content or metadata for a specific comment snapshot
 * (bbs_article_comment_snapshots) by ID.
 *
 * This PUT operation updates metadata or content for a particular comment
 * snapshot in the evidence system. While general edits typically create new
 * snapshots, this can allow corrections under special administrative
 * circumstances, for evidence correction or dispute resolution.
 *
 * Accepts content (body), format, and possibly file association adjustments.
 * Must strictly validate parent article and comment, existing snapshot, and
 * business rules for evidentiary control — typical users may not be allowed
 * unless it's for error correction or privileged access.
 *
 * Side-effects are limited to only the indicated snapshot; evidence/integrity
 * must be preserved.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param commentId Comment ID in bbs_article_comments to which the snapshot
 *   belongs
 * @param id Comment snapshot ID (UUID) in bbs_article_comment_snapshots
 * @param body The content, format, or attachment linkage updates for this
 *   comment snapshot.
 * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByArticleidAndCommentidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  commentId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
  body: putByArticleidAndCommentidAndId.Input,
): Promise<putByArticleidAndCommentidAndId.Output> {
  return !!connection.simulate
    ? putByArticleidAndCommentidAndId.simulate(
        connection,
        articleId,
        commentId,
        id,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByArticleidAndCommentidAndId.METADATA,
          path: putByArticleidAndCommentidAndId.path(articleId, commentId, id),
          status: null,
        },
        body,
      );
}
export namespace putByArticleidAndCommentidAndId {
  export type Input = IBbsArticleCommentSnapshot.IUpdate;
  export type Output = IBbsArticleCommentSnapshot;

  export const METADATA = {
    method: "PUT",
    path: "/bbs/articles/:articleId/comments/:commentId/snapshots/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(commentId ?? "null")}/snapshots/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleCommentSnapshot => typia.random<IBbsArticleCommentSnapshot>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
    body: putByArticleidAndCommentidAndId.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByArticleidAndCommentidAndId.path(articleId, commentId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("commentId")(() => typia.assert(commentId));
      assert.param("id")(() => typia.assert(id));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Logically deletes a comment snapshot (bbs_article_comment_snapshots) by ID,
 * nested under specific article and comment, as per evidence-preservation
 * policy.
 *
 * This operation enables the logical deletion (soft delete) of a comment
 * snapshot record in the bbs_article_comment_snapshots table, nested under a
 * specific comment within a specific article. According to the system's
 * requirements for evidence preservation, this operation sets a deleted flag or
 * timestamp field (rather than actually removing any history data) to make the
 * snapshot invisible to regular end users but still retained in the system for
 * administrative/audit purposes.
 *
 * The operation involves several security considerations: only users with the
 * correct password or administrators can perform deletions; IP addresses and
 * audit trail information remain intact for compliance. The operation will fail
 * if provided IDs do not correspond to existing entities.
 *
 * This endpoint should be used only when absolutely necessary, such as in
 * compliance with legal requirements or gross abuse. Otherwise, all history
 * should remain permanently retained.
 *
 * @param articleId Target article's ID
 * @param commentId Target comment's ID
 * @param id Target comment snapshot's ID
 * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseByArticleidAndCommentidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  commentId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
): Promise<void> {
  return !!connection.simulate
    ? eraseByArticleidAndCommentidAndId.simulate(
        connection,
        articleId,
        commentId,
        id,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByArticleidAndCommentidAndId.METADATA,
          path: eraseByArticleidAndCommentidAndId.path(
            articleId,
            commentId,
            id,
          ),
          status: null,
        },
      );
}
export namespace eraseByArticleidAndCommentidAndId {
  export const METADATA = {
    method: "DELETE",
    path: "/bbs/articles/:articleId/comments/:commentId/snapshots/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(commentId ?? "null")}/snapshots/${encodeURIComponent(id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByArticleidAndCommentidAndId.path(articleId, commentId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("commentId")(() => typia.assert(commentId));
      assert.param("id")(() => typia.assert(id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
