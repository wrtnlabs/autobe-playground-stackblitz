import { IConnection, HttpError } from "@nestia/fetcher";
import typia, { tags } from "typia";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommentSnapshotFile } from "../../../../../../structures/ICommentSnapshotFile";

/**
 * Associates new file(s) with a comment snapshot
 * (bbs_article_comment_snapshot_files), specifying attachment and order.
 *
 * This endpoint enables the creation/association of one or several attachment
 * files to a given comment snapshot (reference
 * bbs_article_comment_snapshot_files in schema). File IDs must be valid and
 * refer to pre-uploaded resources defined in attachment_files. The request body
 * (ICommentSnapshotFile.ICreate) allows specification of the file(s) to attach
 * and their display sequence/order, in accordance with UX/UI requirements.
 *
 * Upon success, the endpoint returns the new relationship(s) and order in the
 * response type. All additions occur in a database transaction. Proper
 * authentication, permission, and validation against duplicate/illegal
 * operations are required. Usage of this endpoint is fundamental to supporting
 * evidence‚Äêpreserving file associations in comment histories.
 *
 * @param articleId Target article's ID
 * @param commentId Target comment's ID
 * @param snapshotId Target comment snapshot's ID
 * @param body Association info (file IDs and any sequence/order) for new
 *   attachments to the comment snapshot.
 * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function postByArticleidAndCommentidAndSnapshotid(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  commentId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  body: postByArticleidAndCommentidAndSnapshotid.Input,
): Promise<postByArticleidAndCommentidAndSnapshotid.Output> {
  return !!connection.simulate
    ? postByArticleidAndCommentidAndSnapshotid.simulate(
        connection,
        articleId,
        commentId,
        snapshotId,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...postByArticleidAndCommentidAndSnapshotid.METADATA,
          path: postByArticleidAndCommentidAndSnapshotid.path(
            articleId,
            commentId,
            snapshotId,
          ),
          status: null,
        },
        body,
      );
}
export namespace postByArticleidAndCommentidAndSnapshotid {
  export type Input = ICommentSnapshotFile.ICreate;
  export type Output = ICommentSnapshotFile;

  export const METADATA = {
    method: "POST",
    path: "/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(commentId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICommentSnapshotFile => typia.random<ICommentSnapshotFile>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    body: postByArticleidAndCommentidAndSnapshotid.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: postByArticleidAndCommentidAndSnapshotid.path(
        articleId,
        commentId,
        snapshotId,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("commentId")(() => typia.assert(commentId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Partially updates attachment files (bbs_article_comment_snapshot_files) for a
 * specific comment snapshot, with support for sequence/order changes.
 *
 * This endpoint provides partial update capability for attachment files on a
 * specific comment snapshot, using a request body referencing
 * ICommentSnapshotFile.IRequest or a similar input type. The underlying table
 * is the bbs_article_comment_snapshot_files, which is responsible for
 * maintaining the association and sequence of each file for each snapshot.
 *
 * Request validation ensures atomicity and transactional integrity: all
 * add/remove/order changes are applied in a single transaction. Each update
 * respects the unique sequence field to preserve file display order, a feature
 * critical for end-user UX. Security checks must ensure that users have
 * permission to alter the snapshot (password check/admin rights), and
 * operations must be logged for audit. Related endpoints for attachment_files
 * management should be referenced for holistic file lifecycle control.
 *
 * @param articleId Target article's ID
 * @param commentId Target comment's ID
 * @param snapshotId Target comment snapshot's ID
 * @param body Partial update info with the new and/or reordered list of
 *   attachment files for the comment snapshot.
 * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByArticleidAndCommentidAndSnapshotid(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  commentId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  body: patchByArticleidAndCommentidAndSnapshotid.Input,
): Promise<patchByArticleidAndCommentidAndSnapshotid.Output> {
  return !!connection.simulate
    ? patchByArticleidAndCommentidAndSnapshotid.simulate(
        connection,
        articleId,
        commentId,
        snapshotId,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByArticleidAndCommentidAndSnapshotid.METADATA,
          path: patchByArticleidAndCommentidAndSnapshotid.path(
            articleId,
            commentId,
            snapshotId,
          ),
          status: null,
        },
        body,
      );
}
export namespace patchByArticleidAndCommentidAndSnapshotid {
  export type Input = ICommentSnapshotFile.IRequest;
  export type Output = ICommentSnapshotFile.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(commentId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICommentSnapshotFile.ISummary =>
    typia.random<ICommentSnapshotFile.ISummary>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    body: patchByArticleidAndCommentidAndSnapshotid.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByArticleidAndCommentidAndSnapshotid.path(
        articleId,
        commentId,
        snapshotId,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("commentId")(() => typia.assert(commentId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieves a specific attached file (bbs_article_comment_snapshot_files) for a
 * comment snapshot, with file metadata and order.
 *
 * Fetch comprehensive metadata and relational info for a specific attachment
 * file linked to a given comment snapshot. This involves joining
 * bbs_article_comment_snapshot_files to bbs_article_comment_snapshots and
 * attachment_files entities. The response provides display order (sequence),
 * file name, extension, and URL for download/display purposes. Logical
 * deletion/visibility rules apply as per system evidence-retaining policy, and
 * audit trails/documentation should describe how to acquire both current and
 * historical attachment file relationships.
 *
 * @param articleId Target article's ID
 * @param commentId Target comment's ID
 * @param snapshotId Target comment snapshot's ID
 * @param id Target attachment relation (bbs_article_comment_snapshot_files.id)
 * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByArticleidAndCommentidAndSnapshotidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  commentId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
): Promise<getByArticleidAndCommentidAndSnapshotidAndId.Output> {
  return !!connection.simulate
    ? getByArticleidAndCommentidAndSnapshotidAndId.simulate(
        connection,
        articleId,
        commentId,
        snapshotId,
        id,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByArticleidAndCommentidAndSnapshotidAndId.METADATA,
          path: getByArticleidAndCommentidAndSnapshotidAndId.path(
            articleId,
            commentId,
            snapshotId,
            id,
          ),
          status: null,
        },
      );
}
export namespace getByArticleidAndCommentidAndSnapshotidAndId {
  export type Output = ICommentSnapshotFile;

  export const METADATA = {
    method: "GET",
    path: "/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(commentId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICommentSnapshotFile => typia.random<ICommentSnapshotFile>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByArticleidAndCommentidAndSnapshotidAndId.path(
        articleId,
        commentId,
        snapshotId,
        id,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("commentId")(() => typia.assert(commentId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.param("id")(() => typia.assert(id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Updates order/association data for an attached file
 * (bbs_article_comment_snapshot_files) for a comment snapshot.
 *
 * This operation enables updating the relationship data between a comment
 * snapshot and an attached file by modifying the join table record
 * (bbs_article_comment_snapshot_files). It's primarily for changing the file's
 * display order (sequence) or other association-specific metadata. The request
 * body conforms to ICommentSnapshotFile.IUpdate. This operation does not affect
 * the physical file resource stored in attachment_files; use the dedicated API
 * for file asset updates.
 *
 * Permission and integrity checks are necessary; only authorized users can
 * update attachment associations. Related endpoints for partial update and file
 * creation/deletion should be referenced for a complete file management
 * lifecycle.
 *
 * @param articleId Target article's ID
 * @param commentId Target comment's ID
 * @param snapshotId Target comment snapshot's ID
 * @param id Target attachment relation (bbs_article_comment_snapshot_files.id)
 * @param body Update information, typically just the sequence/order, for the
 *   attached file association.
 * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByArticleidAndCommentidAndSnapshotidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  commentId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
  body: putByArticleidAndCommentidAndSnapshotidAndId.Input,
): Promise<putByArticleidAndCommentidAndSnapshotidAndId.Output> {
  return !!connection.simulate
    ? putByArticleidAndCommentidAndSnapshotidAndId.simulate(
        connection,
        articleId,
        commentId,
        snapshotId,
        id,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByArticleidAndCommentidAndSnapshotidAndId.METADATA,
          path: putByArticleidAndCommentidAndSnapshotidAndId.path(
            articleId,
            commentId,
            snapshotId,
            id,
          ),
          status: null,
        },
        body,
      );
}
export namespace putByArticleidAndCommentidAndSnapshotidAndId {
  export type Input = ICommentSnapshotFile.IUpdate;
  export type Output = ICommentSnapshotFile;

  export const METADATA = {
    method: "PUT",
    path: "/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(commentId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): ICommentSnapshotFile => typia.random<ICommentSnapshotFile>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
    body: putByArticleidAndCommentidAndSnapshotidAndId.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByArticleidAndCommentidAndSnapshotidAndId.path(
        articleId,
        commentId,
        snapshotId,
        id,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("commentId")(() => typia.assert(commentId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.param("id")(() => typia.assert(id));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Deletes a comment snapshot's file association
 * (bbs_article_comment_snapshot_files) by record ID, keeping asset file
 * intact.
 *
 * This endpoint removes the association between a specific attachment file and
 * a comment snapshot by deleting the join table record
 * (bbs_article_comment_snapshot_files). The file asset remains in the system
 * unless explicitly deleted elsewhere. All deletions must be authorized by
 * permissions consistent with the evidence retention policy. Cascade rules in
 * Prisma model keep referential integrity; access is restricted to users with
 * modification/review rights.
 *
 * This operation supports the requirement that, although all evidence must be
 * preserved, attachment relationships may sometimes be retracted per user
 * request or content update, but full delete of history is by exception only.
 *
 * @param articleId Target article's ID
 * @param commentId Target comment's ID
 * @param snapshotId Target comment snapshot's ID
 * @param id Target attachment relation (bbs_article_comment_snapshot_files.id)
 * @path /bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseByArticleidAndCommentidAndSnapshotidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  commentId: string & tags.Format<"uuid">,
  snapshotId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
): Promise<void> {
  return !!connection.simulate
    ? eraseByArticleidAndCommentidAndSnapshotidAndId.simulate(
        connection,
        articleId,
        commentId,
        snapshotId,
        id,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByArticleidAndCommentidAndSnapshotidAndId.METADATA,
          path: eraseByArticleidAndCommentidAndSnapshotidAndId.path(
            articleId,
            commentId,
            snapshotId,
            id,
          ),
          status: null,
        },
      );
}
export namespace eraseByArticleidAndCommentidAndSnapshotidAndId {
  export const METADATA = {
    method: "DELETE",
    path: "/bbs/articles/:articleId/comments/:commentId/snapshots/:snapshotId/files/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(commentId ?? "null")}/snapshots/${encodeURIComponent(snapshotId ?? "null")}/files/${encodeURIComponent(id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    commentId: string & tags.Format<"uuid">,
    snapshotId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByArticleidAndCommentidAndSnapshotidAndId.path(
        articleId,
        commentId,
        snapshotId,
        id,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("commentId")(() => typia.assert(commentId));
      assert.param("snapshotId")(() => typia.assert(snapshotId));
      assert.param("id")(() => typia.assert(id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
