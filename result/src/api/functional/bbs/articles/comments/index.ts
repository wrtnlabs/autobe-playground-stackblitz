import { IConnection, HttpError } from "@nestia/fetcher";
import typia, { tags } from "typia";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IBbsArticleComment } from "../../../../structures/IBbsArticleComment";
import { IPageBbsArticleComment } from "../../../../structures/IPageBbsArticleComment";
export * as snapshots from "./snapshots";

/**
 * Create a new comment (bbs_article_comments) on an article.
 *
 * This POST operation creates a new comment on a specific article in the
 * bulletin board system. New comments must include required fields such as
 * writer, password, and initial content, referenced by a parentId if this is a
 * reply to another comment (enables hierarchical threading).
 *
 * The operation first creates an entry in 'bbs_article_comments', then creates
 * an initial bbs_article_comment_snapshots record with the comment's content.
 * If files are attached, relevant mapping records are also created in
 * bbs_article_comment_snapshot_files and attachment_files.
 *
 * Enforces password hashing, IP logging, timestamp recording, and initializes
 * all evidence features.
 *
 * Handles validation errors (missing fields), permission enforcement, and
 * ensures parent entities exist (article, parent comment if reply). Responds
 * with the created comment structure, including snapshot references and
 * attachment linkage.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param body Comment creation input for bbs_article_comments, including
 *   parentId, writer, password, and initial content.
 * @path /bbs/articles/:articleId/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function postByArticleid(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  body: postByArticleid.Input,
): Promise<postByArticleid.Output> {
  return !!connection.simulate
    ? postByArticleid.simulate(connection, articleId, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...postByArticleid.METADATA,
          path: postByArticleid.path(articleId),
          status: null,
        },
        body,
      );
}
export namespace postByArticleid {
  export type Input = IBbsArticleComment.ICreate;
  export type Output = IBbsArticleComment;

  export const METADATA = {
    method: "POST",
    path: "/bbs/articles/:articleId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (articleId: string & tags.Format<"uuid">) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    body: postByArticleid.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: postByArticleid.path(articleId),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * List all comments (bbs_article_comments) for an article, with search/filter.
 *
 * This PATCH operation fetches a paginated and searchable list of all comments
 * related to a specific article, as defined in the requirements (nested
 * structure, logical deletion, evidence). Search criteria can include author
 * fields, timestamp range, parent/child linkage for hierarchical display, etc.
 *
 * Results present only comments not logically deleted for public users. Admins
 * may access deleted items with proper authorization.
 *
 * Handles edge cases such as no results, excessive pagination, and filter
 * security. Data comes from the 'bbs_article_comments' table, potentially
 * joined with the latest comment snapshot for list views.
 *
 * Fails with 404 if article doesn't exist, or appropriate error for permission
 * issues.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param body Parameters for searching, filtering, and pagination for comment
 *   list.
 * @path /bbs/articles/:articleId/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByArticleid(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  body: patchByArticleid.Input,
): Promise<patchByArticleid.Output> {
  return !!connection.simulate
    ? patchByArticleid.simulate(connection, articleId, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByArticleid.METADATA,
          path: patchByArticleid.path(articleId),
          status: null,
        },
        body,
      );
}
export namespace patchByArticleid {
  export type Input = IBbsArticleComment.IRequest;
  export type Output = IPageBbsArticleComment;

  export const METADATA = {
    method: "PATCH",
    path: "/bbs/articles/:articleId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (articleId: string & tags.Format<"uuid">) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IPageBbsArticleComment => typia.random<IPageBbsArticleComment>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    body: patchByArticleid.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByArticleid.path(articleId),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Retrieve a specific comment (bbs_article_comments) within an article by ID.
 *
 * This GET operation retrieves a single comment by its unique identifier,
 * attached to a specific article. It pulls data from 'bbs_article_comments',
 * confirming article and comment association, and validates that the comment is
 * not logically deleted for public views.
 *
 * Inherited relationships allow easy nesting for replies. The result returns
 * only top-level comment record info (writer, timestamps, parent,
 * etc)â€“attachable snapshots and files are accessed through other APIs.
 *
 * Permission and logical deletion rules are enforced: only non-deleted comments
 * are shown publicly, while admins may retrieve deleted comments for evidence
 * or audit purposes.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param id Target comment ID (UUID) in bbs_article_comments
 * @path /bbs/articles/:articleId/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByArticleidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
): Promise<getByArticleidAndId.Output> {
  return !!connection.simulate
    ? getByArticleidAndId.simulate(connection, articleId, id)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByArticleidAndId.METADATA,
          path: getByArticleidAndId.path(articleId, id),
          status: null,
        },
      );
}
export namespace getByArticleidAndId {
  export type Output = IBbsArticleComment;

  export const METADATA = {
    method: "GET",
    path: "/bbs/articles/:articleId/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByArticleidAndId.path(articleId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("id")(() => typia.assert(id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Update a specific comment (metadata/relationships) in bbs_article_comments
 * within an article.
 *
 * This PUT operation modifies a comment on a given article, addressing certain
 * updatable fields in 'bbs_article_comments' such as writer, password, or
 * parentId (for reply/nesting structure). The revision of contents (body) is
 * handled by subsequent snapshot creation in a nested or parallel API.
 *
 * Updates trigger standard evidence retention (audit trails, password
 * verification), and may affect hierarchical threading. Parent entity existence
 * must be verified. Logical deletion rules and permissions apply â€“ deleted
 * comments cannot be modified by typical users.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param id Target comment ID (UUID) in bbs_article_comments
 * @param body Details for comments update, including writer, password, or
 *   parentId for nesting.
 * @path /bbs/articles/:articleId/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function putByArticleidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
  body: putByArticleidAndId.Input,
): Promise<putByArticleidAndId.Output> {
  return !!connection.simulate
    ? putByArticleidAndId.simulate(connection, articleId, id, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByArticleidAndId.METADATA,
          path: putByArticleidAndId.path(articleId, id),
          status: null,
        },
        body,
      );
}
export namespace putByArticleidAndId {
  export type Input = IBbsArticleComment.IUpdate;
  export type Output = IBbsArticleComment;

  export const METADATA = {
    method: "PUT",
    path: "/bbs/articles/:articleId/comments/:id",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
    body: putByArticleidAndId.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByArticleidAndId.path(articleId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("id")(() => typia.assert(id));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}

/**
 * Logically delete (soft-delete) a comment (bbs_article_comments) from an
 * article.
 *
 * This DELETE operation performs a logical (soft) deletion of a comment on a
 * given article. Instead of removing the record from 'bbs_article_comments',
 * the 'deleted_at' timestamp is set to the current time (soft delete),
 * preserving audit trails for evidence and dispute resolution as mandated by
 * system requirements.
 *
 * Checks that the targeted comment exists, is not already deleted, and that any
 * user access or password verification requirements are satisfied. Deleted
 * comments are excluded from public retrieval but available for evidence by
 * administrators.
 *
 * Handles not-found, already-deleted, and access-denial errors appropriately.
 *
 * @param articleId Target article ID (UUID) in bbs_articles
 * @param id Target comment ID (UUID) in bbs_article_comments
 * @path /bbs/articles/:articleId/comments/:id
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseByArticleidAndId(
  connection: IConnection,
  articleId: string & tags.Format<"uuid">,
  id: string & tags.Format<"uuid">,
): Promise<eraseByArticleidAndId.Output> {
  return !!connection.simulate
    ? eraseByArticleidAndId.simulate(connection, articleId, id)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByArticleidAndId.METADATA,
          path: eraseByArticleidAndId.path(articleId, id),
          status: null,
        },
      );
}
export namespace eraseByArticleidAndId {
  export type Output = IBbsArticleComment;

  export const METADATA = {
    method: "DELETE",
    path: "/bbs/articles/:articleId/comments/:id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ) =>
    `/bbs/articles/${encodeURIComponent(articleId ?? "null")}/comments/${encodeURIComponent(id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);
  export const simulate = (
    connection: IConnection,
    articleId: string & tags.Format<"uuid">,
    id: string & tags.Format<"uuid">,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByArticleidAndId.path(articleId, id),
      contentType: "application/json",
    });
    try {
      assert.param("articleId")(() => typia.assert(articleId));
      assert.param("id")(() => typia.assert(id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
